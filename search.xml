<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CDN概念学习</title>
    <url>/2020/11/04/CDN%E6%A6%82%E5%BF%B5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="什么叫DNS"><a href="#什么叫DNS" class="headerlink" title="什么叫DNS"></a>什么叫DNS</h1><p>DNS就是域名解析器  把域名解析成ip地址 通过ip地址进行计算机的互联  核心概念就是 我们现在的互联网 就和书上讲的一样 由计算机连成的网络 一台计算机要连接另外一台计算机 需要知道另外一台计算机在哪里 我才能去找到他 拿到我想要的东西 详情请参考 <a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">阮一峰互联网协议入门</a><br>我们其中的DNS 就是通过我们人好识别的域名 比如说<a href="http://www.baidu.com/">www.baidu.com</a> 知道他是百度  他的资源放在一个计算机上 我们要找到那台计算机 然后告诉他我要搜个啥  找到这台计算机 DNS服务器会通过域名解析系统 将域名解析成ip地址供给我们的计算机去找（老婆）  域名解析的实现请参考<a href="http://www.ruanyifeng.com/blog/2016/06/dns.html">DNS原理入门</a> 这里只需要知道 DNS负责把域名转换为 我们要去请求的ip地址</p>
<p>为什么DNS会污染 这不是谁干的 而是运营商干的 比如github这种 “危险网站”  里面的个人博客 都要给你全部污染掉 这也是采用阿里 tx 这一些稳定的DNS服务器的原因</p>
<h1 id="CDN粗解"><a href="#CDN粗解" class="headerlink" title="CDN粗解"></a>CDN粗解</h1><h2 id="CDN处于什么层面"><a href="#CDN处于什么层面" class="headerlink" title="CDN处于什么层面"></a>CDN处于什么层面</h2><p>现在的互联网 大多数包含了大量的静态内容 比如说你现在看到的博客 图片储存 js代码储存 这些静态内容是最耗费带宽的 也就是加载页面的速度 如果你的网站已经是全国知名的博客 如果所有慕名而来的小伙子都想看你的博客 那么他们都会输入你的域名 通过DNS服务器找到你放博客的计算机的ip地址 （顺着网线把你抓出来） 这样的话 你的服务器再强也顶不住 </p>
<p>这个时候就需要提供一个缓存的阶段 俗话说人不能在一棵树上吊死 我们就把我们的内容存在其他的地方 当做是备份 （分布式储存） 这个备份会有很多份，我们当然是找到越近的服务器当然是越快啦。 综上所述 CDN就是<b>处于</b>在我们知道的人能理解的域名<b>和</b>最快的储存着我们资源的计算机的ip地址之间的东西啦 他和DNS是怎么样协作的呢</p>
<p>首先 我们先提交域名 就像上文一样 先检查本地是不是有这个域名的ip缓存 如果没有 那么就去请求我们配置的DNS服务器 告诉他  3秒钟之内 我要这个域名的ip！(3s有点久) 然后DNS服务器开始解析域名 当他解析到这个域名的CNAME（重定向 将当前请求域名重定向到目标ip）记录时  他就会把这个请求丢给CNAME 记录的ip地址 这个时候的ip地址还不是你想要的  这个ip地址是那个万人迷网站在DNS服务器上 加上的CNAME 记录 指向CDN均衡负载系统 也就是说  你要请求我的万人迷网站 首先我会把你的第一次请求给CNAME指向的CDN均衡负载系统 这个均衡负载系统接收到你的请求 他就会看你发请求的ip  开始分析emmmmm 你这个人是深圳来的啊  然后就系统就把深圳最快的ip（CDN节点）返回给你自己 </p>
<p>现在为止 你的第一次请求结束 你获得了一个深圳CDN节点ip</p>
<p>接下来你就会拿着这个距离深圳最快的ip 去找（万人迷网站还没找到呢） 你找到了深圳的CDN节点 这个节点  如果是第一次访问 那么这个节点 就去访问那台储存着万人迷网站的  真正的主机 然后把数据储存在节点 然后把数据返回给你  接下来 每一次深圳周围的人想访问这个网站 这个CDN节点就相当于 一个备份啦 而且访问速度会很快 主机也不会疯狂被请求 CDN加速的意义就此体现</p>
<h2 id="来张图"><a href="#来张图" class="headerlink" title="来张图"></a>来张图</h2><img src="/2020/11/04/CDN%E6%A6%82%E5%BF%B5%E5%AD%A6%E4%B9%A0/cdn.png" class="" title="This is an example image">
<p>图片转载自：<a href="https://www.cnblogs.com/lianghe01/p/11132133.html">CDN详解</a></p>
]]></content>
      <categories>
        <category>NET相关</category>
      </categories>
  </entry>
  <entry>
    <title>搭建博客采坑指南</title>
    <url>/2020/11/03/First-Page/</url>
    <content><![CDATA[<p>倒腾了半个下午，倒腾出博客的雏形。<br><br>配置一系列的cli和开发环境，之前倒腾angular的时候，已经下了npm和node.js git等 这里不赘述<br>记录一下自己的采坑之旅</p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>有一说一，hexo自带的主题真的丑的我没话讲，上面丑陋的背景图 丑陋的比例，以及丑陋的布局<br></p>
<img src="/2020/11/03/First-Page/back.webp" class="" title="This is an example image">



]]></content>
      <categories>
        <category>Start</category>
      </categories>
  </entry>
  <entry>
    <title>CSS之难题解决和知识补充</title>
    <url>/2020/12/23/CSS%E4%B9%8B%E9%9A%BE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%92%8C%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>这里学习一下 CSS 很多的之前没用过的东西</p>
<style>
div{
    margin-bottom:20px;
}
@keyframes ants {
  to {
    background-position: 100%;
  }
}
#test1 {
  height: 200px;
  width: 200px;
  background: linear-gradient(to right, red 50%, blue 50%);
  background-size: 30px 100%;
}
#test2 {
  height: 200px;
  width: 200px;
  background: repeating-linear-gradient(
    45deg,
    red,
    red 15px,
    blue 0,
    blue 30px
  );
}
#test3 {
  height: 200px;
  width: 200px;
  background-color: blue;
  background-size: 30px 30px;
  background-image: linear-gradient(white 1px, transparent 0), linear-gradient(90deg, white
        1px, transparent 0);
}
#test4 {
  height: 200px;
  width: 200px;
  background-color: blue;
  background-size: 30px 30px;
  background-image: radial-gradient(red 30%, transparent 0);
}
#test5 {
  height: 200px;
  width: 200px;
  background-color: blue;
  background-size: 30px 30px;
  background-image: linear-gradient(45deg, red 25%, transparent 0),
    linear-gradient(45deg, transparent 75%, red 0), linear-gradient(
      45deg,
      red 25%,
      transparent 0
    ), linear-gradient(45deg, transparent 75%, red 0);
  background-position: 0 0, 15px 15px, 15px 15px, 0 0;
}
#test6 {
  height: 200px;
  width: 200px;
  background-color: blue;
  background-size: 30px 30px;
  background-image: linear-gradient(
      45deg,
      red 25%,
      transparent 0,
      transparent 75%,
      red 0
    ), linear-gradient(45deg, red 25%, transparent 0, transparent 75%, red 0);

  background-position: 0 0, 15px 15px, 15px 15px, 0 0;
}
#test7 {
  width: 200px;
  height: 100px;
  padding: 20px;
  border: 1px solid transparent;
  background-image: linear-gradient(white, white), repeating-linear-gradient(-45deg, black
        0, black 25%, white 25%, white 50%);
  background-size: 20px 20px;
  background-clip: padding-box, border-box;
  background-position: 0;
  animation: ants 12s linear infinite;
}
#test8 {
  height: 200px;
  width: 300px;
  background-color: blue;
  border-radius: 50%/50%;
}
    </style>

<h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><p>上来就是一个 RGBA 和 HSLA<br>RGBA 都比较熟悉了 A === Alpha 透明度啦<br>HSLA A=== 透明度<br>其实都是颜色 问题不是很大 和前端的关系不大 但是面试可能问到颜色的其他的函数 这里补充一下</p>
<h1 id="border-我不知道的秘密"><a href="#border-我不知道的秘密" class="headerlink" title="border 我不知道的秘密"></a>border 我不知道的秘密</h1><p>border 其实就是边框 但是我们不知道的是 边框默认是会覆盖掉我们的 div 标签内部的东西的<br>这个时候 有一个属性叫做 background-clip<br>顾名思义 这个属性是确定我们的背景是如何进行保留的 三个值</p>
<ul>
<li>padding-box 从 padding 就开始有背景了 这个时候 div 的大小是 content+padding+border</li>
<li>content-box 从 content 才会有背景 这个时候如果设置 padding 那么就是无背景的 padding</li>
<li>border-box border 覆盖背景</li>
</ul>
<p>所以设置外边框 或者是四周的阴影之类的 直接使用 background-clip 设置为 padding-box 然后进行 border 样式的修改就 ok 啦</p>
<p>但是有一个缺点就是 我们只能设置一个边框 如果要多个边框？</p>
<h1 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h1><p>这个属性是 CSS3 的 其实他的原理很简单 就是在我们的盒子模型的后面一层 加上一个指定大小的 颜色色块 我们可以设置这个颜色色块的延伸 可以设置模糊度 可以设置这个颜色色块的位置 以及内阴影还是外阴影 我们甚至可以设置许多个阴影<br>我们只需要设置不同的延伸就行啦 注意必须比前一个大</p>
<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><p>设置描边 当然是描边框啦 这个是在边框之外的 但是和边框不同的是 边框是占据大小的 但是 outline 是不占据大小的</p>
<blockquote>
<p>至此为止 我们现在给 div 加上边框有几种办法</p>
<ol>
<li>直接加 border 但是这个时候要注意 border 占据大小</li>
</ol>
</blockquote>
<pre><code>- border-box
- padding-box
- content-box</code></pre>
<blockquote>
<ol start="2">
<li>border 外面套 outline outline 不占据大小</li>
<li>直接 box-shadow 无偏移 伸张量就是大小</li>
<li>多层边框就是多个 box-shadow</li>
</ol>
</blockquote>
<pre><code>- 两个边框可以border+outline</code></pre>
<h1 id="垂直和水平条纹的-CSS-实现"><a href="#垂直和水平条纹的-CSS-实现" class="headerlink" title="垂直和水平条纹的 CSS 实现"></a>垂直和水平条纹的 CSS 实现</h1><p>直接上代码</p>
<div id="test1"></div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test1</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, red <span class="number">50%</span>, blue <span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 liner-gradient 默认是从下到上 然后偏转的角度是顺时针 或者我们可以直接使用 to right 这种关键字</p>
<div id="test2"></div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test2</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">repeating-linear-gradient</span>(</span><br><span class="line">    <span class="number">45deg</span>,</span><br><span class="line">    red,</span><br><span class="line">    red <span class="number">15px</span>,</span><br><span class="line">    blue <span class="number">0</span>,</span><br><span class="line">    blue <span class="number">30px</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现桌布-背景"><a href="#实现桌布-背景" class="headerlink" title="实现桌布 背景"></a>实现桌布 背景</h1><blockquote>
<p>桌布就是背景加上分割线啦<br>实际上就是应用了我们的渐变 然后控制我们的线条的渐变控制在 1 2px 也就是线条的粗细 然后紧接着通过控制 background-size 控制我们方格的大小</p>
</blockquote>
<div id="test3"></div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test3</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(white <span class="number">1px</span>, transparent <span class="number">0</span>), <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, white</span><br><span class="line">        <span class="number">1px</span>, transparent <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现圆点排列"><a href="#实现圆点排列" class="headerlink" title="实现圆点排列"></a>实现圆点排列</h1><div id="test4"></div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test4</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(red <span class="number">30%</span>, transparent <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里解释一下我们的 radial-gradient 就是从背景的中心进行拓展</p>
<blockquote>
<p>通过多个 background-image 的叠加 我们就可以实现很多种不同的图片</p>
</blockquote>
<h1 id="棋盘布局-国际象棋"><a href="#棋盘布局-国际象棋" class="headerlink" title="棋盘布局 国际象棋"></a>棋盘布局 国际象棋</h1><div id="test5"></div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test5</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, red <span class="number">25%</span>, transparent <span class="number">0</span>),</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent <span class="number">75%</span>, red <span class="number">0</span>), <span class="built_in">linear-gradient</span>(</span><br><span class="line">      <span class="number">45deg</span>,</span><br><span class="line">      red <span class="number">25%</span>,</span><br><span class="line">      transparent <span class="number">0</span></span><br><span class="line">    ), <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent <span class="number">75%</span>, red <span class="number">0</span>);</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>, <span class="number">15px</span> <span class="number">15px</span>, <span class="number">15px</span> <span class="number">15px</span>, <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是分别构造了 25%的三角形边角 然后原来两张图 不加上 position 是分布在右上角和左下角 然后通过移动我们的 background-image 的 position 用四张图 构成一个 30*30 的重复方块<br>上面当然也可以两个 linear 就搞定</p>
<div id="test6"></div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test6</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(</span><br><span class="line">      <span class="number">45deg</span>,</span><br><span class="line">      red <span class="number">25%</span>,</span><br><span class="line">      transparent <span class="number">0</span>,</span><br><span class="line">      transparent <span class="number">75%</span>,</span><br><span class="line">      red <span class="number">0</span></span><br><span class="line">    ), <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, red <span class="number">25%</span>, transparent <span class="number">0</span>, transparent <span class="number">75%</span>, red <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>, <span class="number">15px</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题之-实现蚂蚁行军效果"><a href="#面试题之-实现蚂蚁行军效果" class="headerlink" title="面试题之 实现蚂蚁行军效果"></a>面试题之 实现蚂蚁行军效果</h1><p>直接上效果</p>
<div id="test7"></div>
康康代码

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test7</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(white, white), <span class="built_in">repeating-linear-gradient</span>(-<span class="number">45deg</span>, black</span><br><span class="line">        <span class="number">0</span>, black <span class="number">25%</span>, white <span class="number">25%</span>, white <span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background-clip</span>: padding-box, border-box;</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">animation</span>: ants <span class="number">12s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> ants &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">100%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的华点就是 我们首先设置我们的背景颜色是白色 这里的背景是运用到之前我们说的 border-clip 实现的是简单的背景剪切 这样从 padding 开始的背景都是白色<br>然后我们再加多一层背景 运用了之前说到的 linear-gradient 实现了我们的条纹背景 观察上面实现的条纹背景 发现只截取周边的 1px 就形成了我们静态的虚线边框 这个遮盖用的就是我们的 border-box 实现的 背景从 border 开始 这样 padding-box 就会覆盖掉我们的内部的条纹 然后加上一个 animation 就实现了我们的动态效果</p>
<h1 id="实现椭圆半圆角"><a href="#实现椭圆半圆角" class="headerlink" title="实现椭圆半圆角"></a>实现椭圆半圆角</h1><p>我们的 border-radius 可以接受两个值 可以指定两个值 一个是 a 轴 一个 b 轴 期间用/间隔 下面直接上例子</p>
<div id="test8"></div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test8</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>/<span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是指定了 a 轴和 b 轴 就可以动态绑定我们的椭圆了 这样只要是长度比高度大 那就会自适应变成椭圆</p>
<ul>
<li>我们一般的两个值都是通过/分隔开的</li>
</ul>
<h1 id="实现菱形背景"><a href="#实现菱形背景" class="headerlink" title="实现菱形背景"></a>实现菱形背景</h1><p>这里面涉及到两个之前没用过的知识</p>
<h2 id="css3-的-skew-属性"><a href="#css3-的-skew-属性" class="headerlink" title="css3 的 skew 属性"></a>css3 的 skew 属性</h2><p>这个属性可以在已有的图形下面进行制定边的变形 比如下面代码</p>
<style>
#test10 {
  background-color: red;
  height: 200px;
  width: 300px;
  margin: 20px;
  padding: 10px;
  font-size: 1.2em;
  transform: skewX(-15deg);
}
#test11 {
  height: 200px;
  width: 200px;
  position: relative;
  text-align: center;
  margin: 20px;
}
#test11::before {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  content: "";
  background-color: blue;
  z-index: -1;
  transform: skewX(15deg);
}
#test12 {
  height: 200px;
  width: 200px;
  margin: 20px;
  background: red;
  background: linear-gradient(-45deg, transparent 15px, red 0) right, linear-gradient(
        45deg,
        transparent 15px,
        red 0
      ) left;
  background-size: 50% 100%;
  background-repeat: no-repeat;
}
#test13 {
        height: 200px;
        width: 200px;
        margin: 20px;
        background: red;
        background: radial-gradient(circle at top left, transparent 15px, red 0)
          top left;
      }
#test14 {
  height: 200px;
  width: 200px;
  margin: 30px;
  background: red;
  transform: perspective(15.5em) rotateX(45deg);
  transform-origin: left;
}
#test15 {
        height: 200px;
        width: 200px;
        margin: 30px;
        background: red;
        border-radius: 50%;
        background-image: linear-gradient(to right, transparent 50%, blue 0);
      }
      #test15::before {
        display: block;
        content: "";
        margin-left: 50%;
        height: 100%;
        background: red;
        border-radius: 0 100% 100% 0 / 50%;
        transform: perspective(0) rotateZ(20deg);
        transform-origin: left;
      }
</style>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test10</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skewX</span>(-<span class="number">15deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="test10">
This is a diamond
</div>

<p>x 轴就是和 y 轴平行的两根边进行倾斜 正数代表逆时针倾斜 以右下角为圆心<br>y 轴就是和 x 轴平行的两根边进行倾斜 正数代表顺时针倾斜 以左上角为圆心</p>
<p>但是这样的话 我们的内容也会跟着改变</p>
<p>两种方法实现</p>
<ol>
<li>就是我们的两个 html 元素 对里面的元素再进行一次方向相反的 skew</li>
<li>用我们的伪元素</li>
</ol>
<h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><p>一开始听到这个伪元素选择器 还不知道是个啥 其实我们的 first-line 和 letter 之类的都是<br>我们下面实现我们的菱形背景 用的就是伪元素选择器里面的 before 选择器 下面直接上代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test11</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#test11</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skewX</span>(<span class="number">15deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="test11">
This is a diamond
</div>

<p>这上面就实现了我们的背景和我们的 content 的分开 不需要嵌套两个 html 元素 直接是 使用伪元素选择器创建了一个伪元素 相当于两个元素</p>
<h1 id="实现切角"><a href="#实现切角" class="headerlink" title="实现切角"></a>实现切角</h1><p>切角直接用 linear-gradient 然后用 transparent 颜色就行 具体的代码上面有 下面讲的是如何实现两个切角</p>
<p>这个时候就需要两个背景了 但是注意 这两个背景有新的语法 一个是背景的位置 一个是背景的尺寸 直接上代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test12</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(-<span class="number">45deg</span>, transparent <span class="number">15px</span>, red <span class="number">0</span>) right, <span class="built_in">linear-gradient</span>(</span><br><span class="line">        <span class="number">45deg</span>,</span><br><span class="line">        transparent <span class="number">15px</span>,</span><br><span class="line">        red <span class="number">0</span></span><br><span class="line">      ) left;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">50%</span> <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="test12">
</div>

<p>上面的华点就是 两个背景图片的 position 一个是 right 一个是 left<br>还有下面背景的 no-repeat 和 background-size 实际上就是指定了每一块背景的宽度是 50% 高度是全部 然后两个门神 一个在左边 个在右边 然后分别设置我们熟悉的 linear-gradient</p>
<blockquote>
<p>如果要实现我们的四个切角的话 那就是 4 块背景 然后使用 top left 这种进行定位之后 在指定我们的 size 长和高都是 50%</p>
</blockquote>
<h2 id="实现凹陷的圆角边框"><a href="#实现凹陷的圆角边框" class="headerlink" title="实现凹陷的圆角边框"></a>实现凹陷的圆角边框</h2><p>这个时候就不能使用我们的 border-radius 应该用我们的 radial-gradient</p>
<blockquote>
<p>奇妙的是 radial-gradient 可以指定我们圆心的位置 四角或者是我们的 center 下面上代码</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test13</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(circle at top left, transparent <span class="number">15px</span>, red <span class="number">0</span>) top left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="test13"></div>

<h1 id="实现梯形"><a href="#实现梯形" class="headerlink" title="实现梯形"></a>实现梯形</h1><p>这里我们复习一下 CSS3 的 3D 变幻</p>
<p>这里复习一下坐标轴 x 轴 是水平的 y 轴是竖直的 z 轴是垂直于屏幕向外</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">X</th>
<th align="center">Y</th>
<th align="center">Z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">正数</td>
<td align="center">上边向里</td>
<td align="center">右边向里</td>
<td align="center">顺时针</td>
</tr>
</tbody></table>
<p>所以实现梯形 直接 rotateX 就完事了</p>
<p>下面是比较常见的代码 可以实现两边不同的梯形</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test14</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">15.5em</span>) <span class="built_in">rotateX</span>(<span class="number">45deg</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="test14"></div>

<h1 id="实现一个饼图"><a href="#实现一个饼图" class="headerlink" title="实现一个饼图"></a>实现一个饼图</h1><p>我们先来看看效果</p>
<div id="test15"></div>

<p>先上代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test15</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, transparent <span class="number">50%</span>, blue <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#test15</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">100%</span> <span class="number">100%</span> <span class="number">0</span> / <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">perspective</span>(<span class="number">0</span>) <span class="built_in">rotateZ</span>(<span class="number">20deg</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们一步一步讲述</p>
<ol>
<li>首先先创建我们的根本的圆形  各一半是我们想要的不同的颜色 这里用之前说到的linear-gradient</li>
<li>然后设置圆角边框啥的  一个二色圆形实现</li>
<li>然后设置伪元素  为什么这里不同position  relative 呢  因为我们的伪元素 before是默认覆盖的 我们这里要的就是覆盖的效果 而不是我们的沉底  如果是沉底 用了position  那么就用用top来定位 如果没有position absolute 那么直接用margin 定位</li>
<li>这个时候 伪元素是一个矩形 无颜色  占整个圆形的右边50%</li>
<li>直接把矩形用border-radius 变成半圆 然后设置旋转位置 进行旋转就行了</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此我们讲述了背景与边框以及  我们的形状的实现</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>JS原始数据类型的对象包装</title>
    <url>/2020/11/11/JS%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85/</url>
    <content><![CDATA[<p>在JS的原始数据类型 也有内置的对象封装 里面有一些常见的方法 如果我们对原始数据类型进行对象的使用 那么就会隐式转化为对象 然后对象执行方法 然后对象在当前行被清除  类似下面代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1=<span class="string">&quot;Some String&quot;</span>;</span><br><span class="line"><span class="comment">/////////////////////////</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>s1会在一瞬间变成一个对象然后被销毁</p>
<h1 id="Boolean对象"><a href="#Boolean对象" class="headerlink" title="Boolean对象"></a>Boolean对象</h1><p>建议不要使用<br>在进行逻辑表达式运算的时候 一个Object&amp;&amp;其他 == true&amp;&amp;其他<br>这样的话  如果你的Boolean对象里面是false  但是还是会当做true进行运算</p>
<h1 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h1><p>需要注意的有以下的函数</p>
<h2 id="x-toFix"><a href="#x-toFix" class="headerlink" title="x.toFix()"></a>x.toFix()</h2><p>四舍五入 保留指定参数的小数位数</p>
<h2 id="x-toExponential"><a href="#x-toExponential" class="headerlink" title="x. toExponential()"></a>x. toExponential()</h2><p>指的是将数字转化为科学计数法 参数指定的是 在小数点后面保留多少位小数 比如说</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">16.191111</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1.toExponential(<span class="number">2</span>)); <span class="comment">// &quot;1.62e+1&quot;</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">16.111111</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1.toExponential(<span class="number">0</span>)); <span class="comment">// &quot;2e+1&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="x-toPrecision"><a href="#x-toPrecision" class="headerlink" title="x.toPrecision()"></a>x.toPrecision()</h2><p>表示的是 用几位数字来表示 注意这个时候不是几位小数 而是几位数字 他会自动选择科学计数法还是填0来进行输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">1</span>)); <span class="comment">// &quot;1e+2&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">2</span>)); <span class="comment">// &quot;99&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">3</span>)); <span class="comment">// &quot;99.0&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h2><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>顾名思义</p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>直接上代码  注意是将结果储存在另外一个变量 而不是把本身的变量进行修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.concat(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>当然可以有很多的参数</p>
<h2 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h2><h3 id="slice-substring-substr"><a href="#slice-substring-substr" class="headerlink" title="slice substring substr"></a>slice substring substr</h3><p>直接上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo worl&quot;</span></span><br><span class="line"><span class="comment">///////////////////</span></span><br><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">-3</span>)); <span class="comment">// &quot;rld&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意如果是一个参数 则是包括当前位置 如果是两个参数 左闭右开</p>
<h2 id="字符串搜索"><a href="#字符串搜索" class="headerlink" title="字符串搜索"></a>字符串搜索</h2><h3 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf() 和 lastIndexOf()"></a>indexOf() 和 lastIndexOf()</h3><p>这两个都接受一个字符串和一个数字 第一个代表target  第二个代表start 返回值顾名思义 如果找不到 则返回-1<br>注意 这个搜索的范围 包括start</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">&quot;e&quot;</span>, <span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h2 id="判断字符串包含"><a href="#判断字符串包含" class="headerlink" title="判断字符串包含"></a>判断字符串包含</h2><p>ES6 特有的  和正则表达式的效果相似</p>
<h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p>接受两个参数 一个是target  一个是开始搜索的位置 返回一个bool</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>, <span class="number">4</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="startsWidth"><a href="#startsWidth" class="headerlink" title="startsWidth"></a>startsWidth</h3><p>接受两个参数 一个target 一个开始搜索的位置 返回一个bool 注意 这个是从头往后搜索<br>很重要的一点是 是包含你传入第二个参数的字符的<br>**从传入第二个参数开始 包括第二个参数 是不是以tar为开头</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="endWidth"><a href="#endWidth" class="headerlink" title="endWidth"></a>endWidth</h3><p>接受两个参数 一个是target 一个是字符串结尾的位置 返回一个bool 开始的位置默认是 (string.length - substring.length)<br>**第二参数就是我们指定的字符串结尾的位置 如果传入pos  那么开始搜索的地方就是pos-substring.length  包括这个值 开始搜索substring.length个字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;baz&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="trim方法"><a href="#trim方法" class="headerlink" title="trim方法"></a>trim方法</h2><p>用于去除字符串的空格 trimRight和trimLeft 顾名思义<br>不会影响到原来字符串 需要新的内存空间进行保存</p>
<h2 id="repeat方法"><a href="#repeat方法" class="headerlink" title="repeat方法"></a>repeat方法</h2><p>直接上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;na &quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.repeat(<span class="number">16</span>) + <span class="string">&quot;batman&quot;</span>);</span><br><span class="line"><span class="comment">// na na na na na na na na na na na na na na na na batman</span></span><br></pre></td></tr></table></figure>
<h2 id="设置字符串长度并且自动填充"><a href="#设置字符串长度并且自动填充" class="headerlink" title="设置字符串长度并且自动填充"></a>设置字符串长度并且自动填充</h2><p>直接上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">6</span>)); <span class="comment">// &quot; foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;......foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">6</span>)); <span class="comment">// &quot;foo &quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;foo......&quot;</span></span><br><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;barbafoo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">2</span>)); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;foobarba&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">2</span>)); <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>
<p>tips:<br>toLocaleString 会根据当前的地区返回不同的值 而toString则不会  字符大小写也同样</p>
<h2 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h2><p> toLowerCase() 、 toLocaleLowerCase()<br> toUpperCase() 和 toLocaleUpperCase()</p>
<h2 id="Compare方法"><a href="#Compare方法" class="headerlink" title="Compare方法"></a>Compare方法</h2><p>localeCompare() 返回值如下面代码所示 这没有除去locale的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;brick&quot;</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;yellow&quot;</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;zoo&quot;</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<h1 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h1><p>global对象就是js的兜底的对象了 它里面有着我们熟悉的很多函数 比如说Number的构造函数等等 parseInt等等  其中我们需要注意的就是 eval() 这个函数可以在当前位置插入js代码 相当于C++的define 或者是include  文本插入<br>global对象其实真正的代理还是window对象  这个是在ECMAScript  window代理了global  但是在具体的js的对es的实现里面 window对象承载了更多的好用的属性</p>
<h1 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h1><p>这个对象也提供了很多的有用的方法 其中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...val);</span><br></pre></td></tr></table></figure>
<p>顾名思义<br> Math.ceil() 方法始终向上舍入为最接近的整数。<br> Math.floor() 方法始终向下舍入为最接近的整数。<br> Math.round() 方法执行四舍五入。<br> Math.fround() 方法返回数值最接近的单精度（32 位）浮点值表示。<br> Math.random() 返回[0,1)随机数<br>其中还有一些一般人想得到的比如正弦余弦 反三角函</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS变量 作用域和内存</title>
    <url>/2020/11/10/JS%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>这里涉及到JS 比较底层的原理 和C++比较不一样 C++是声明变量 指定类型并且分配内存空间 JS内存空间内部实现 并没有在外面实现 C++的指针在JS里面也是隐藏的存在 但是也有相关的原理</p>
<h1 id="原始值和引用值"><a href="#原始值和引用值" class="headerlink" title="原始值和引用值"></a>原始值和引用值</h1><p>原始值就是JS的六种剧本数据类型  他们是储存在变量的内存空间里面的 而引用值 对象 储存的是指针  指针指向了保存在堆栈里面的内存空间 JS是不允许直接访问堆栈的内存的 按引用访问其实就是只能使用变量里面储存的指针进行访问 而不是 let a=0xa848ef<br>*a=10 这一种</p>
<h1 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h1><p>原始值的复制  理论上来说就是深拷贝 在新的变量开辟的内存空间里面 填入被复制的值 这个时候这两个变量就是相互独立的<br>但是如果是引用变量 那么复制的时候就是复制指针 相当于浅拷贝 对指针指向的内存地址空间的值也会产生影响</p>
<h1 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h1><p>JS和C++不同 所有的参数都是值传递 相当于在函数的arguments数组里面 一个萝卜一个坑 然后进行上面说的变量的复制  如果是原始值 那么就是两个相互独立的  如果是引用值  那么就是指针地址的复制 令这个argument指向另外一个新的object并不会改变外面指针的值</p>
<h1 id="确定类型"><a href="#确定类型" class="headerlink" title="确定类型"></a>确定类型</h1><p>typeof是用来确定原始值的 但是这个对object用处就不是很大了 这个时候 instanceof就出现了他的作用了<br>instanceof也是一个操作符 他会在原型链里面去找是不是有这个原型</p>
<h1 id="执行上下文和作用域"><a href="#执行上下文和作用域" class="headerlink" title="执行上下文和作用域"></a>执行上下文和作用域</h1><h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>上下文就是当前语句执行的上下文 和语文的上下文相似</p>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>变量对象就是当前的上下文储存所有变量的对象 最顶级的上下文就是全局上下文 里面储存变量的对象就是window对象 所以说var会在window对象里面注册属性<br>在函数里面 那就是新的上下文 他的变量对象最初只有函数的arguments</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链就是变量对象的一个链 你所需要的函数或者是变量会顺链查找 当前上下文永远在最前面</p>
<p>要是未声明就对变量直接进行赋值不会和let一样进行报错（不使用）let  这样这个变量就会注册在全局 而不是当前上下文</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">sum = num1 + num2;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">sum = num1 + num2;</span><br><span class="line"><span class="keyword">let</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 30</span></span><br><span class="line"><span class="comment">//Uncaught ReferenceError: Cannot access &#x27;sum&#x27; before initialization</span></span><br></pre></td></tr></table></figure>

<p>tips : let 和 const  都是ES6的</p>
<h1 id="CONST修饰符"><a href="#CONST修饰符" class="headerlink" title="CONST修饰符"></a>CONST修饰符</h1><p>const意思是 变量不能重新被赋值 但是按照上文说的 如果一个变量是object  比如 const a={  } 那么就是这个a不能指向其他的变量 但是这个变量里面的属性是可以更改的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;;</span><br><span class="line">o1 = &#123;&#125;; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;;</span><br><span class="line">o2.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o2.name); <span class="comment">// &#x27;Jake&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果要整个变量都不能修改的话 可以使用Object对象的一种构造函数 freeze 冻结</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o3 = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">o3.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o3.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>注意结果是undefined哦</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="*垃圾回收"></a>*垃圾回收</h1><p>JS的垃圾回收机制有两种 一种是标记清理  一种是引用计数 一种是标记清理  </p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>JS会维护一个引用的表 对每一个值都记录了被引用的次数 当这个次数为0的时候 当然可以回收 但是这个引用计数的问题就是 当变量进行套娃引用的时候 就会造成内存泄漏 因为这个时候 两个对象的引用次数都是2</p>
<h2 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h2><p>会标记当前的  正在使用的变量 然后清除没有使用的变量</p>
<h1 id="通过优化垃圾回收-和避免内存泄漏进行性能优化"><a href="#通过优化垃圾回收-和避免内存泄漏进行性能优化" class="headerlink" title="通过优化垃圾回收 和避免内存泄漏进行性能优化"></a>通过优化垃圾回收 和避免内存泄漏进行性能优化</h1><h2 id="尽可能使用const和let"><a href="#尽可能使用const和let" class="headerlink" title="尽可能使用const和let"></a>尽可能使用const和let</h2><p>因为const 和 let 的作用域都是块作用域 这样的话就不会导致注册在全局 会容易被内存清理发现</p>
<h2 id="尽可能解除引用"><a href="#尽可能解除引用" class="headerlink" title="尽可能解除引用"></a>尽可能解除引用</h2><p>解除引用之后 在堆内存里面的内存空间就可以被释放 这样也可以避免内存泄漏</p>
<h2 id="隐藏类"><a href="#隐藏类" class="headerlink" title="*隐藏类"></a>*隐藏类</h2><p>隐藏类 就是两个对象的属性的名字和个数具有相同的值 这样的话 便于JS去追踪这个隐藏类的实例 在对对象进行操作的时候 尽量不要在外面临时进行属性个数的添加和删除 对于不需要的属性可以使用null指针进行解除引用 这样 隐藏类还是共享 还是可以追踪。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>JavaScript 变量可以保存两种类型的值：原始值和引用值。原始值可能是以下 6 种原始数据类型之<br>一： Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。原始值和引用值有以下特点。<br> 原始值大小固定，因此保存在栈内存上。<br> 从一个变量到另一个变量复制原始值会创建该值的第二个副本。<br> 引用值是对象，存储在堆内存上。<br> 包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。<br> 从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。<br> typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。<br>任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个<br>上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结<br>如下。<br> 执行上下文分全局上下文、函数上下文和块级上下文。<br> 代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。<br> 函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃<br>至全局上下文中的变量。<br> 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。<br> 变量的执行上下文用于确定什么时候释放内存。<br>JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript 的垃圾回收<br>程序可以总结如下。<br> 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。<br> 主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。<br> 引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript 引擎不再使用这种算<br>法，但某些旧版本的 IE 仍然会受这种算法的影响，原因是 JavaScript 会访问非原生 JavaScript 对<br>象（如 DOM 元素）。<br> 引用计数在代码中存在循环引用时会出现问题。<br> 解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对<br>象、全局对象的属性和循环引用都应该在不需要时解除引用</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的语句</title>
    <url>/2020/11/09/JS%E7%9A%84%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="for-in语句"><a href="#for-in语句" class="headerlink" title="for-in语句"></a>for-in语句</h1><p>for-in 语句是把一个对象的所有键值都打出来 比如说</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    x:<span class="number">132</span>,</span><br><span class="line">    y:<span class="number">777</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> a) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(propName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x  y</span></span><br></pre></td></tr></table></figure>
<p>这个键值是无序的 根据浏览器而定  所以不知道哪一个先被打印出来</p>
<h1 id="for-of语句"><a href="#for-of语句" class="headerlink" title="for-of语句"></a>for-of语句</h1><p>适用于迭代一个可以遍历的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]) &#123;</span><br><span class="line"><span class="built_in">document</span>.write(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 这里的const和上面一样不是必须的 但是可以确保迭代的时候不会修改</p>
<h1 id="标签语句和循环嵌套的使用"><a href="#标签语句和循环嵌套的使用" class="headerlink" title="标签语句和循环嵌套的使用"></a>标签语句和循环嵌套的使用</h1><p>直接上例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">break</span> outermost;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>
<p>这里的 break当然可以换成continue</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS尾调用优化和闭包</title>
    <url>/2020/12/20/JS%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>好久没看 JS 了 这里重拾一下 为了准备明年去面试试试水 加油打工人 加油 干饭人 期末考试也要加油</p>
<h1 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h1><p>这里说的尾调用就是 我们的函数的递归调用 一个函数返回的是另外一个函数的返回值 这个时候 ES6 的引擎就会进行尾调用优化 我们学 C++知道 函数调用的时候有一个函数栈 要是递归太多层 那么就会 stack overflow ES6 对这种递归尾调用进行优化的时候就是 比如如下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> innerFunction(); <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当代码执行到 outer 的时候 就会把 outer 的函数 push 进函数栈 然后继续执行 执行到 return 语句的时候 如果没有 ES6 优化 那就是直接 push inner 进函数栈<br>这个时候 ES6 的优化就会发现 这个函数的返回值其实就是 inner 的返回值 这个时候发现吧 outer pop 掉也没有关系 这样就会直接 pop outer 然后 push inner 这样就节省的空间</p>
<h2 id="尾部调用优化的条件"><a href="#尾部调用优化的条件" class="headerlink" title="尾部调用优化的条件"></a>尾部调用优化的条件</h2><ol>
<li>首先得是尾部调用</li>
<li>其次得是严格模式</li>
<li>调用之后没有对返回值进行额外操作 直接进行返回</li>
<li>尾部调用是个闭包<blockquote>
<p>闭包后面再讲 来点例子</p>
</blockquote>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无优化：尾调用没有返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  innerFunction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用没有直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> innerFunctionResult = innerFunction();</span><br><span class="line">  <span class="keyword">return</span> innerFunctionResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用返回后必须转型为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> innerFunction().toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用是一个闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innerFunction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论是不是递归调用 只要是尾部调用 ES6 都会去识别 ES6 没那么聪明 不会去判断是不是递归调用 只要在尾部调用了函数 都叫做尾部调用</p>
<blockquote>
<p>为什么是严格模式 因为如果不是严格模式 那么就可以访问 arguments.callee.caller 这样就会访问前面的函数帧 这样 pop 之后就访问不到了</p>
</blockquote>
<h2 id="补充知识-函数如何判断是不是以-new-关键字进行调用"><a href="#补充知识-函数如何判断是不是以-new-关键字进行调用" class="headerlink" title="补充知识 函数如何判断是不是以 new 关键字进行调用"></a>补充知识 函数如何判断是不是以 new 关键字进行调用</h2><p>函数调用的时候 传入一个名字为 new 的对象 里面有一个 target 属性 如果为 1 的话 那么就是使用 new 关键字进行调用的</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><blockquote>
<blockquote>
<p>听说面试最喜欢这个 这里补充一下<br>闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。比如，下面是之前展示的 createComparisonFunction() 函数</p>
</blockquote>
</blockquote>
<p>函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。</p>
<blockquote>
<p>我们讨论的闭包 其实就是在不同的函数的活动对象里面 通过作用域链 对其他父函数 或者是父对象 的上下文里面的局部变量进行引用 通俗一点讲 就是顺着作用域链找到你家 然后进行访问</p>
</blockquote>
<p>我们知道的垃圾回收的知识 引用计数 只要变量还有被引用 那么垃圾回收装置就不会进行回收 这个时候闭包就会出现这个问题 比如我们下面的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value1 = object1[propertyName];        <span class="comment">//引用了propertyName</span></span><br><span class="line">    <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;....&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;....&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="function"><span class="keyword">function</span> = <span class="title">creatComparionFunction</span>(<span class="params"><span class="string">&#x27;aaa&#x27;</span></span>)(<span class="params">obj1,obj2</span>);</span></span><br></pre></td></tr></table></figure>

<p>这里面 这个函数工厂返回的匿名函数引用了 我们传给函数工厂的 propertyName 变量 让我们回顾一下 最后一行代码 首先创建了一个 create 的函数栈 然后创建了这个函数的作用域链 作用域链是根据 这个函数的 scope 进行复制</p>
<ol>
<li>创建作用域链 根据 scope</li>
<li>创建函数的活动对象 活动对象上面有说</li>
<li>把活动对象怼在作用域链的最前端</li>
<li>执行函数</li>
</ol>
<p>这个时候 let function 拿着这个返回的函数 这个函数引用这个 create 的活动对象里面的 propertyName 根据引用计数 这个时候这个函数的活动对象并不会被释放 和我们常常理解的 这个函数执行完之后 就弹出函数栈不同 这就是闭包</p>
<p>当我们执行 function 的时候 这个时候创建的函数活动对象会在 作用域链的 create 的 活动对象前面进行加上 function 本身的活动对象</p>
<blockquote>
<p>总的来说 闭包就是一个上下文里面的一个函数引用了在作用域链上游的变量 导致上游变量的内存因为引用计数的问题不能正确释放</p>
</blockquote>
<h2 id="闭包的面试题"><a href="#闭包的面试题" class="headerlink" title="闭包的面试题"></a>闭包的面试题</h2><blockquote>
<p>这里整理的只是我在网上随手找的 具体的其实还是要实际应用的时候再学习 有一说一 不怕我们对于技术栈的信息量的差异 还是怕我们实际应用的经验的缺失 自己的懒惰以及 我们本身至上的缺陷造就了学习速度的上界 所导致的恶性循环</p>
</blockquote>
<p>IIFE immediately invoked function expression<br>这其实就是为了防止我们的变量外泄 我们需要的就是当前变量只在当前作用域 而且当当前作用域失效之后就进行销毁这个变量 如果我们使用的是 var 变量 这个变量会注册在全局 这样的话 每次我们对这个变量进行取值的时候 就会取得这个在全局作用域的变量 如下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="comment">// 达不到目的！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面很显然 var 被注册在了全局作用 所以每次点击这个 div 的时候 显示的都是 lengtth 这个时候 我们可以使用函数工厂 返回一个回调函数 这个函数工厂接受的变量也是 var 但是只是对当时 var 的值的一个引用 把这个值传进去之后 根据当前 var 的值 进行工厂函数的创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>); <span class="comment">//这里面 addEventListener 可以添加到立即执行函数里面  直接传进来一个i  然后数组的i 的event 等于一个function  引用这个i</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(</span><br><span class="line">    <span class="string">&quot;click&quot;</span>,</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">frozenCounter</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//保存在这一行的参数里面</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(frozenCounter);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针不戳 但是注意这里会形成闭包哦 这里是把当前的值传进了函数 保存在了函数的参数里面<br>或者是 直接使用外部的变量 然后使用一个本地的闭包之内的保存下来 这样我们的闭包函数就不用传参了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(</span><br><span class="line">    <span class="string">&quot;click&quot;</span>,</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> frozenCounter = i;</span><br><span class="line">        <span class="built_in">console</span>.log(frozenCounter);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来一道鬼屎题 这里面的 key 在注释里面给出了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n, o</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    fun: <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fun(m, n);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = fun(<span class="number">0</span>);</span><br><span class="line">a.fun(<span class="number">1</span>);</span><br><span class="line">a.fun(<span class="number">2</span>);</span><br><span class="line">a.fun(<span class="number">3</span>); <span class="comment">//undefined,?,?,?</span></span><br><span class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>); <span class="comment">//undefined,?,?,?</span></span><br><span class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>);</span><br><span class="line">c.fun(<span class="number">2</span>);</span><br><span class="line">c.fun(<span class="number">3</span>); <span class="comment">//undefined,?,?,?</span></span><br><span class="line"><span class="comment">//问:三行a,b,c的输出分别是什么？</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>答案是</p>
<ol>
<li>undefined，0,0,0</li>
<li>undefined，0,1,2</li>
<li>undefined，0,1,1</li>
</ol>
</blockquote>
<p>首先执行了 fun(0) 这里面第一个参数是 0 第二个参数没给 所以 console 出来肯定是 undefined 这没啥问题</p>
<p>然后我们返回了一个对象 这个对象里面有一个 key 为 fun 的一个函数 接受一个参数 然后调用 fun 函数 这里面要清楚的是 这个调用的 fun 并不是我们说的递归调用 递归调用的函数必须是 arguments.callee 或者是非匿名函数 所以这里面调用的 fun 只能是有名字的 最外层的 fun</p>
<p>到现在为止 执行完 fun(0) 我们得到了一个对象 这个对象里面有一个 key 为 fun 的函数 这个函数接受一个参数 加上我们的 n 参数作为第二个参数 调用最外层的 fun 进行返回</p>
<p>执行了 fun(0) a 为返回的对象 执行 a.fun(1) 这个时候 1 作为我们 a 这个对象的 fun 函数的唯一参数 然后调用最外层的 fun 函数 作为 第一个参数 第二个参数 n 从哪里来呢？ 这里就是闭包的概念</p>
<p>我们一开始传入一个 0 作为最外层 fun 函数的第一个参数 n 因为我们 return 的这个对象里 还有对于 n 这个参数的引用 根据引用计数的内存回收原则 这个 n 还是会被保留在函数的作用域链里面 这个时候 当我们这个 1 作为第一个参数 第二个参数 n 就会从作用域链里面去找 就会找到原来闭包的时候的传入的那个 n 也就是 0 这个时候 console 出来的第二个参数就是 n 就是我们一开始创建闭包的那个 0 所以无论我们这个闭包产生的对象调用的函数的参数是什么 第二个参数永远都是我们产生闭包的时候的那个 0</p>
<p>后面两个 在执行完 fun(0)之后产生了第一题的 a 然后执行 fun(0).fun(1) 就相当于 a.fun(1) 输出还是 0</p>
<p>但是这个时候再执行这个函数的返回值的时候 这个时候回去找的第二个参数 n 就是我们上一层闭包传进去的第一个参数 n 上一层闭包传进去的第一个参数 刚好就是我们的 key 为 fun 的函数传进去的 m 参数 也就是 1 啦 这里好好理解一下 我懒得讲了 第一个能理解 进行一下解耦合 后面的都不难其实</p>
<h2 id="闭包作为私有方法和变量的创建方法"><a href="#闭包作为私有方法和变量的创建方法" class="headerlink" title="闭包作为私有方法和变量的创建方法"></a>闭包作为私有方法和变量的创建方法</h2><p>这里比如说我们需要一个计数器 当然可以声明一个计数器变量 但是当我们需要很多计数器的时候呢<br>这个时候 我们就可以使用闭包 把一个计数的变量放在闭包的私有变量里面 然后对外暴露一个++ 的函数 相当于在构造函数里面使用了闭包 就是我们产生的新的对象 对构造函数里面的变量进行了引用 这样 构造函数的局部变量的引用计数就不会是 0 这样就可以进行访问了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.getCount = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cnt = <span class="keyword">new</span> Counter();</span><br><span class="line">cnt.add(); <span class="comment">//1</span></span><br><span class="line">cnt.add(); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(cnt.getCount()); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(cnt.count); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>上面的这个例子 就是我们在创建 Counter 的时候 对每一个 Counter 维护了一个 count 因为不是 this.xx 所以不能进行成员访问 对外是私有的</p>
<p>我们也可以创建一个共享的私有变量 通过一个立即执行函数 创建一个函数栈进行闭包保留我们这些私有的 共享的变量以及方法 为什么是立即执行函数呢 首先 为什么是立即 因为是只执行一次 其次为什么是函数 因为要使用函数的作用域链 根据引用计数不为 0 保留我们的私有变量和函数 上例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有函数 不属于任何 但是可以在这个函数里面进行赋值或者作为子函数调用  只有在当前块可以访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构造函数 这里会直接注册在global</span></span><br><span class="line">  MyObject = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="comment">// 公有和特权方法</span></span><br><span class="line">  MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//操作原型链</span></span><br><span class="line">    privateVariable++;</span><br><span class="line">    <span class="built_in">console</span>.log(privateVariable);</span><br><span class="line">    <span class="keyword">return</span> privateFunction();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(); <span class="comment">//立即执行</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> MyObject();</span><br><span class="line"><span class="built_in">console</span>.log(a.publicMethod()); <span class="comment">//11  false</span></span><br><span class="line"><span class="built_in">console</span>.log(a.publicMethod()); <span class="comment">//12  false</span></span><br></pre></td></tr></table></figure>

<p>表明都是公有的啊 都是三维的</p>
<p>over！ 面试希望闭包无敌</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript从入门到入土-历史</title>
    <url>/2020/11/04/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</url>
    <content><![CDATA[<h1 id="什么是JS"><a href="#什么是JS" class="headerlink" title="什么是JS"></a>什么是JS</h1><h2 id="Javascript和ECMAScript之间的关系"><a href="#Javascript和ECMAScript之间的关系" class="headerlink" title="Javascript和ECMAScript之间的关系"></a>Javascript和ECMAScript之间的关系</h2><p>js一开始是网景公司一开始准备发布服务器语言的时候写的一个脚本语言 后来改名为Lvescript 当时为了跟上JAVA的顺风车 改了个名 实际上和java没有关系<br><br><br>js一开始很成功  于是微软也来插一脚 名字叫Jscript 你说气不气 就是为了不跟你搞名字纠纷 因为微软在业界的响应力 js出现两个版本 一个是创始版本  一个是微软版本。这个时候 国际规范化组织就坐不住了 特别是ECMA （欧洲计算机制造商协会） 他们就牵头找了一批委员 打造出js的标准 也就是ECMAScript 后面国际化组织ISO和IEC同时将ECMAScript采纳标准</p>
<p>虽然JavaScript和ECMAScript基本上是同义词，但JavaScript远远不限于ECMA-262所定义的那样。<br>没错，完整的 JavaScript 实现包含以下几个部分</p>
<p> 核心（ECMAScript）<br> 文档对象模型（DOM）<br> 浏览器对象模型（BOM）</p>
<p>我们平常所说的ES5 ES6就是ECMAScript的若干个版本，其中ES6  又称之为ES2015 是15年发布的修订版 正式支持了类 模块 迭代器 生成器  箭头函数 期约 反射 代理和众多新的数据类型。</p>
<h2 id="DOM-Document-Objeci-Model-文档对象模型"><a href="#DOM-Document-Objeci-Model-文档对象模型" class="headerlink" title="DOM Document Objeci Model 文档对象模型"></a>DOM Document Objeci Model 文档对象模型</h2><p>文档对象模型（DOM，Document Object Model）是一个应用编程接口（API），用于在 HTML 中使<br>用扩展的 XML。DOM 将整个页面抽象为一组分层节点。HTML 或 XML 页面的每个组成部分都是一种<br>节点，包含不同的数据 但是这个时候DOM每个浏览器都有着自己的想法 这就让开发人员头疼 一个HTML界面 在不同浏览器的工作效果是不一样的 这个时候W3C 又来制定标准啦万维网联盟（W3C，World Wide Web<br>Consortium）</p>
<h2 id="BOM浏览器对象模型"><a href="#BOM浏览器对象模型" class="headerlink" title="BOM浏览器对象模型"></a>BOM浏览器对象模型</h2><p>总体来说，BOM 主要针对浏览器窗口和子窗口（frame），不过人们通常会把任何特定于浏览器的<br>扩展都归在 BOM的范畴内。比如，下面就是这样一些扩展：<br> 弹出新浏览器窗口的能力；<br> 移动、缩放和关闭浏览器窗口的能力；<br> navigator 对象，提供关于浏览器的详尽信息；<br> location 对象，提供浏览器加载页面的详尽信息；<br> screen 对象，提供关于用户屏幕分辨率的详尽信息；<br> performance 对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；<br> 对 cookie 的支持；<br> 其他自定义对象，如 XMLHttpRequest 和 IE 的 ActiveXObject</p>
<h2 id="第一篇JS记录-小结一下"><a href="#第一篇JS记录-小结一下" class="headerlink" title="第一篇JS记录 小结一下"></a>第一篇JS记录 小结一下</h2><p>JavaScript 是一门用来与网页交互的脚本语言，包含以下三个组成部分。<br> ECMAScript：由 ECMA-262 定义并提供核心功能。<br> 文档对象模型（DOM）：提供与网页内容交互的方法和接口。<br> 浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。</p>
<h2 id="HTML中的JS-嵌入问题以及用法"><a href="#HTML中的JS-嵌入问题以及用法" class="headerlink" title="HTML中的JS 嵌入问题以及用法"></a>HTML中的JS 嵌入问题以及用法</h2><p>将 JavaScript 插入 HTML 的主要方法是使用 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> async ：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其<br>他脚本加载。只对外部脚本文件有效。<br> charset ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不<br>在乎它的值。<br> crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。 crossorigin=<br>“anonymous” 配置文件请求不必设置凭据标志。 crossorigin=”use-credentials” 设置凭据<br>标志，意味着出站请求会包含凭据。<br> defer ：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。<br>在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。<br> integrity ：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，<br>Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，<br>脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提<br>供恶意内容。</p>
<h3 id="crossorigin属性"><a href="#crossorigin属性" class="headerlink" title="crossorigin属性"></a>crossorigin属性</h3><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>如果两个页面的协议，端口和域名都相同，则两个页面具有相同的源（origin）。<br>同源策略是一种安全机制，它限制了非同源脚本之间的交互方式。<br>例如，在使用XMLHttpRequest或 <img> 标签时，会受到同源策略的约束。</p>
<h4 id="跨域资源共享-CORS"><a href="#跨域资源共享-CORS" class="headerlink" title="跨域资源共享 CORS"></a>跨域资源共享 CORS</h4><p>跨域资源共享 Cross-Origin Resource Sharing (CORS)，通过在服务器端设置 Access-Control-Allow-Origin 响应头，也就是在服务端  通过给资源加上响应header  指定允许域名访问当前资源 也可以设置* 任意资源<br>但是如果服务端没有加上Access-Control-Allow-Origin 但是本地还是使用的crossorigin属性 那么就会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access to Script at <span class="string">&#x27;http://127.0.0.1:8081/index.js&#x27;</span> <span class="keyword">from</span> origin <span class="string">&#x27;http://127.0.0.1:8080&#x27;</span> has been blocked by CORS policy: </span><br><span class="line">No <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> header is present on the requested resource. </span><br><span class="line">Origin <span class="string">&#x27;http://127.0.0.1:8080&#x27;</span> is therefore not allowed access.</span><br></pre></td></tr></table></figure>
<br>
参考: <a href="https://www.jianshu.com/p/a45c9d089c93">script的crossorigin属性</a>
<br>
这个时候添加crossorigin属性可以让浏览器获得更多的error信息 （如果是error 而且服务器添加了响应头Access-Control-Allow-Origin 的情况下） 否则只有简单的 error信息 看不到详细日志

<h3 id="defer和async属性"><a href="#defer和async属性" class="headerlink" title="defer和async属性"></a>defer和async属性</h3><p>defer<br>就是延时加载 告诉浏览器 立即加载 但是要延迟执行 他是在loaded事件执行之前 但是在现实生活中 执行顺序也是不一定的 所以应该只使用一个defer标签</p>
<p>anync<br>就是异步加载 告诉浏览器 下载之后立即执行 但是 因为是异步执行 所以两个文件开始加载的顺序假如是一前一后 但是执行的顺序可能是 后面的文件先下载好 执行之后 前面的文件再完成下载进行执行  所以这个时候如果两个文件有依赖性 那么就会出现问题</p>
<p><br>下面来一些非常直观的图</br></p>
<img src="/2020/11/04/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/defer.png" class="">
<img src="/2020/11/04/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/async.png" class="">
<p>参考： <a href="https://www.cnblogs.com/jiasm/p/7683930.html">浅谈defer和async</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>也就是说 在一般情况下 浏览器会默认顺序去解析html文档 解析到script  会等他加载并且执行完毕 继续进行文档解析  这个时候加上async  就是告诉浏览器 你可以先不管他 交给后<br>台去加载 你先解析着你的文档 然后我这里解析好了 就告诉你一声（promise）然后你就可以来执行我的脚本啦<br>defer就是告诉浏览器 别管 碰到我就继续解析文档 </p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript数据类型Symbol</title>
    <url>/2020/11/09/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BSymbol/</url>
    <content><![CDATA[<p>js独特的数据类型Symbol 期间先介绍一下string类型的使用 然后开始正式介绍Symbol</p>
<h1 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h1><p>String 有几个比较常见的spilce函数等等<br>常用的转义字符和C++的一样 但是如果你要原封不动的输出转义字符的话 有一个标签函数 类似于修饰器的函数可以进行修饰 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line\nsecond line`</span>); <span class="comment">// &quot;first line\nsecond line&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>js原生的 基础数据类型有6种<br>undefined   null    number  string  boolean     symbol<br>其中symbol是ES6 也就是js第六版加进去的 </p>
<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>就是对变量进行声明 但是还没有进行初始化赋值 比如说</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>永远不要给一个变量手动赋值为undefined 不然的话你就不知道究竟这个undefined是因为忘记进行初始化还是别的什么原因 这个undefined一般是用来检测自己是不是忘记对变量进行初始化的</p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>基础数据类型里面没有object  他是一个复杂数据类型 null代表的是一个空对象指针  在定义一个将要保存一个object的变量的时候 可以对他赋值null 表示这个变量我是要赋值一个object 但是我还没干 一边和undefined进行区分 null是一个对象 对他进行typeof运算会得到object 要注意</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="literal">undefined</span>);  <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="literal">null</span>);  <span class="comment">//object</span></span><br></pre></td></tr></table></figure>
<p>这个是特殊的</p>
<h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><p>这个是一个运算符而不是一个函数 它具有下列的输出<br>number string   undefined  function    symbol  boolean     obejct<br>相比于基础数据类型 （6个）<br>多了一个function  将null换成了object  因为我们知道typeof(null) 会输出object</p>
<h1 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h1><p>下面开始探讨symbol这个新的数据类型 因为也是第一次接触 慢慢摸索<br>symbol相当于一个符号  是对对象属性的唯一标识符  不会发生冲突的危险 相当于trackBy 的 agentId 每一个symbol都是唯一的  但是symbol的描述可以是相同的  比如说我有两个标签 一个是1号 一个是2号  我描述1号是一支笔 2号是一支笔 标签的描述是相同的 但是标签的序号本身还是不同的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fooSymbol == otherFooSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是  symbol是不能通过new运算符进行操作的 不能和其他基本数据类型一样  成为一个包装对象<br>意思就是说 new运算符 可以将基础数据类型变成一个object  这个时候进行typeof当然是object</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myBoolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myBoolean); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> myString = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myString); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> myNumber = <span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myNumber); <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>具体符号是用来标识一个对象的 但是如果很多对象需要使用相同的symbol  那么需要在全局符号注册一个</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 创建新符号</span></span><br><span class="line"><span class="keyword">let</span> otherFooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 重用已有符号</span></span><br><span class="line"><span class="built_in">console</span>.log(fooGlobalSymbol === otherFooGlobalSymbol); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。 这个登记指的是在全局进行登记</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>符号可以作为对象的属性 用来标识每一个对象 比如说</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>),</span><br><span class="line">s3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>),</span><br><span class="line">s4 = <span class="built_in">Symbol</span>(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">[s1]: <span class="string">&#x27;foo val&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的方括号就是用现有变量作为属性的标识<br>同样地 也可以使用Object的方法 对对象进行属性的赋值<br>symbol 还可以用于定义一整组常量 保证这一些常量都是不相等的  如果要辨别这一些常量的话 symbol是一个很好地选择 比如说是switch 同时还可以消除魔术字符串和常量</p>
<h3 id="symbol属性的遍历"><a href="#symbol属性的遍历" class="headerlink" title="symbol属性的遍历"></a>symbol属性的遍历</h3><p>如果symbol作为一个对象的属性的名字的话 那么for-in 循环是不能进行输出的 而且 Object.getOwnPropertyNames() 方法也得不到这个键的名字  必须是Object.getOwnPropertySymbols() 或者是 Reflect.ownKeys()    后者可以返回所有类型的键名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;my_key&#x27;</span>)]: <span class="number">1</span>,</span><br><span class="line">  enum: <span class="number">2</span>,</span><br><span class="line">  nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</span><br><span class="line"><span class="comment">//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</span></span><br></pre></td></tr></table></figure>
<h2 id="ES9-内置的symbol"><a href="#ES9-内置的symbol" class="headerlink" title="ES9 内置的symbol"></a>ES9 内置的symbol</h2><p>以后再说</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>互联网协议入门</title>
    <url>/2020/12/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="互联网协议"><a href="#互联网协议" class="headerlink" title="互联网协议"></a>互联网协议</h1><p>今天体侧+打球 没写算法题 总结一下互联网协议安慰一下自己<br>互联网协议分为很多层 我们先讲互联网的五层模型 里面的一些细节可以再分 分为七层 我们先讲五层 互联网的层级 每一层负责不同的通讯 他们的好处就是 层与层之间可以互不干扰的进行运转 这也是计算机自顶向下的一种封装吧 每一个层专注于自己的事 然后暴露好接口 上面的层只管调用这种接口就行啦</p>
<img src="/2020/12/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/wuceng.png" class="" title="This is an example image">

<h2 id="实体层和链接层"><a href="#实体层和链接层" class="headerlink" title="实体层和链接层"></a>实体层和链接层</h2><p>链接层实际上就是网卡之间的通信 通过找寻到 mac 地址 然后进行数据的传输 那么我们一般是通过 DNS 解析器 知道了目标主机的 ip 地址 但是我们实体层的传输是需要 mac 地址的 我们怎么知道 mac 地址呢<br>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的 MAC 地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p>
<p>第二种情况，如果两台主机在同一个子网络，那么我们可以用 ARP 协议，得到对方的 MAC 地址。ARP 协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的 IP 地址，在对方的 MAC 地址这一栏，填的是 FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出 IP 地址，与自身的 IP 地址进行比较。如果两者相同，都做出回复，向对方报告自己的 MAC 地址，否则就丢弃这个包。</p>
<p>总之，有了 ARP 协议之后，我们就可以得到同一个子网络内的主机 MAC 地址，可以把数据包发送到任意一台主机之上了。</p>
<p>到目前为止 我们解决了任意两台机器的传输问题 我们首先会看这个以太网的头 然后判断这个 ip 地址是不是属于同一个子网（利用子网掩码） 这个时候我们是不知道这个目的地的 mac 地址的 我们只能通过 ip 地址知道目前是在一个子网 现在我们要获取 mac 地址才能通讯啊 怎么获取呢 通过我们的 ARP 协议 上面提到过啦 要是不在同一个子网 那就直接发给网关 网关通过路由之类的 传输到目的地的子网 然后目的地的子网 嗯 这个时候通过子网掩码 就知道这个目的地是同一个子网啦 然后再通过 ARP 协议 获取 mac 地址 然后再进行通讯</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>我们现在的通讯 是通过 mac 地址进行两个机子的通讯 上文提到了 ip 和网关 这实际上是网络层之间的关系 上面的连接层和实体层更多的是在子网络 比如一个计算机机房 但是如果是上海的机子和广州的机子 那怎么办咧</p>
<p>必须找到一种方法，能够区分哪些 MAC 地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC 地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p>
<p>那么不同子网之间怎么进行连接呢 这个时候 我们就约定了一个地址 和一个 ip 协议 通过这个协议我们就可以在不同的子网之间进行通讯<br>ip 分为 v4 和 v6 代表着不同的协议 这里我们讲 v4 我们的 ip 层 ip 可以指定相对应的主机 不仅仅是 mac mac 只是在实体层进行数据传输 但是 ip 也可以确定是哪一个主机 在网络层我们在数据包里面再封装一个 ip 层的数据头 包含了目标 ip 和源 ip<br>在网络层 我们的主机会用子网掩码 判断是不是在当前子网 如果是 那就直接用 ARP 找到 mac 然后进行实体层的传输 如果不是 那么目的的 mac 就是网关 网关拿到这个 ip 然后查路由表 然后给其他路由 其他路由再拿到这个包 对比子网掩码 嗯 就是我这个子网 然后查 ip 的 mac 这样就实现了不同子网之间的交流 这个时候 两个子网的包的数据层的目的的 mac 都是网关的 mac 网关收不到目的 mac 因为根本不知道 mac 只会收到 ip 但是 mac 又是必须的 就拿着 ip 去找 mac 嗯</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>我们现在实现了 在子网里面 用 mac 进行数据的传输 也就是链接层和实体层 然后我们在网络层 利用 ip 和子网掩码 和网关 路由 实现了不同子网之间的交流 那么现在 我们不可能两个机子 就只有一个链接吧 比如我们的服务器 同时要和好几个人链接 这个时候 一个机子有端口这个概念 也就是我们的传输层</p>
<p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p>
<p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>“端口”是 0 到 65535 之间的一个整数，正好 16 个二进制位。0 到 1023 的端口被系统占用，用户只能选用大于 1023 的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>
<p>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix 系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p>
<p>这里面也涉及到了面试题 就是我们的有一些自留端口 究竟是干啥的 嗯</p>
<p>有层 当然有协议 UDP 和 TCP 就是在这里面的 这个是重点面试题 单独开一篇<br>这个协议指定了当前的这个应用 使用的是哪一个端口 这个端口出来的和进去的都是这个应用的 这样就不会直接给歪来 具体参考头的套娃</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层就是形形色色的协议的 我们需要知道的就是http和https协议啦 这里直接放上套娃图 然后下一篇讲一下我们的这个套娃图是怎么套娃和解套娃 然后讲一下TCP和UDP</p>
<img src="/2020/12/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/head.png" class="" title="This is an example image">]]></content>
  </entry>
  <entry>
    <title>探索底层-变量和函数的生命周期详解</title>
    <url>/2020/11/05/%E6%8E%A2%E7%B4%A2%E5%BA%95%E5%B1%82-%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>从红宝书里面看到var 和let变量 突然好奇他们的生命周期和我们常学的C和C++有什么区别  查找了网上博客 现在进行总结</p>
<h1 id="变量和函数的生命周期基本过程"><a href="#变量和函数的生命周期基本过程" class="headerlink" title="变量和函数的生命周期基本过程"></a>变量和函数的生命周期基本过程</h1><p>当引擎访问变量的时候，它们的生命周期包括下面几个阶段：</p>
<p>1.声明阶段：在作用域中注册一个变量<br>2.初始化阶段：分配内存，给作用域中的变量创建绑定。在这个阶段，变量自动地被初始化为undefined<br>3.赋值阶段：给已经初始化过的变量赋值<br>声明变量就是告诉js解释器 我现在这个名字就是个变量 但是这个时候还没初始化  对这个名字进行访问是报错的<br>初始化阶段之后就可以对这个变量进行访问了 这个时候分配了undefined 但是还是可以访问<br>赋值阶段 就是字面意思 把undefined 变成赋值的值</p>
<h1 id="var变量的生命周期"><a href="#var变量的生命周期" class="headerlink" title="var变量的生命周期"></a>var变量的生命周期</h1><p>var变量的作用域是函数作用域 而不是块作用域 我们常见的C++ 就是块作用域 在一个函数里面所有的var  都会被一个叫（变量提升） 的 在函数作用域的开始阶段 所有的 不论是在哪里写的var 变量都会在作用域头进行声明和初始化 这个时候是undefined  经历了初始化 意味着可以访问 于是有了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>输出undefined 和预想一样</p>
<h1 id="let变量的生命周期"><a href="#let变量的生命周期" class="headerlink" title="let变量的生命周期"></a>let变量的生命周期</h1><p>let变量就是把声明和初始化解耦合了 同时 let的作用域是块作用域 所以在块作用域的开头 let 变量还是会进行声明  注意是声明 这个时候只有这个名字 但是没分配内存 这个时候的变量 被储存在称之为暂时性死区的地方 连undefined都不是 所以这个时候进行访问就会出错 当解释到 let a的时候 开始进行初始化为undefined 或者进行赋值 let a =10； 变量退出暂时性死区 下面是例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// console.log(number); // =&gt; Throws ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> number;</span><br><span class="line"><span class="built_in">console</span>.log(number); <span class="comment">// =&gt; undefined</span></span><br><span class="line">number = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number); <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure>
<p>输出 error 第二个输出5 和预期一样</p>
<h1 id="函数的生命周期"><a href="#函数的生命周期" class="headerlink" title="函数的生命周期"></a>函数的生命周期</h1><p>函数在js里面 我理解也是一种变量 函数的声明 初始化 赋值 不论写在在父函数作用域的任何位置 都会被提升到一开始  所以任何时候都可以访问 就算是写在return 之后的函数 一个典型例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumArray</span>(<span class="params">array</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> array.reduce(sum);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不会报错 进行正常输出</p>
<h1 id="var-和let的其他区别"><a href="#var-和let的其他区别" class="headerlink" title="var 和let的其他区别"></a>var 和let的其他区别</h1><ol>
<li>var的全局声明 会成为window对象的属性 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// &#x27;Matt&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>for循环括号里面的变量的问题 如果是let变量 那么循环体里面传的都是当前 变量的一个副本 而不是 和var一样是当前变量 典型例子<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 你可能以为会输出 0、1、2、3、4</span></span><br><span class="line"><span class="comment">// 实际上会输出 5、5、5、5、5</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会输出 0、1、2、3、4</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>let 和 var  就是在各自的作用域进行了 声明和初始化的解耦合 理解这两个概念很重要<br>参考 <a href="https://blog.csdn.net/mike_chen2stockings/article/details/79577062">生命周期</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>剑指offer</title>
    <url>/2020/11/09/%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<h2 id="在面试的时候写代码必须要考虑边界值-特殊的输入-而不是一股脑的就开始写答案-面试官会更加考虑你的边界判断能力-以及脏输入-以及代码调试能力"><a href="#在面试的时候写代码必须要考虑边界值-特殊的输入-而不是一股脑的就开始写答案-面试官会更加考虑你的边界判断能力-以及脏输入-以及代码调试能力" class="headerlink" title="在面试的时候写代码必须要考虑边界值 特殊的输入 而不是一股脑的就开始写答案 面试官会更加考虑你的边界判断能力 以及脏输入 以及代码调试能力"></a>在面试的时候写代码必须要考虑边界值 特殊的输入 而不是一股脑的就开始写答案 面试官会更加考虑你的边界判断能力 以及脏输入 以及代码调试能力</h2><h2 id="在介绍项目经历的时候-要表现出自己的合作精神-沟通能力-以及自己良好的学习能力"><a href="#在介绍项目经历的时候-要表现出自己的合作精神-沟通能力-以及自己良好的学习能力" class="headerlink" title="在介绍项目经历的时候 要表现出自己的合作精神  沟通能力 以及自己良好的学习能力"></a>在介绍项目经历的时候 要表现出自己的合作精神  沟通能力 以及自己良好的学习能力</h2><h3 id="查找数组里面重复的元素"><a href="#查找数组里面重复的元素" class="headerlink" title="查找数组里面重复的元素"></a>查找数组里面重复的元素</h3><p>如果没有加以限制的话 那么就是傻逼题 如果是加以限制 比如鸽笼原理<br>在大小为n的数组里面放n+1个数字 那么必须至少两个数字是相同的 下面考虑 时间O(n) 空间O(1)的算法<br>如果是鸽笼原理 那么一个萝卜一个坑 顺序遍历数组 那么当前元素是a[i] 如果不是i 而是 k  那么就看看 a[k] 如果一样 那就找到 如果不一样那就交换 a[k] a[i] 让这个a[i] 回到自己的坑a[k] 的位置上 </p>
<p>如果要求不能改变数组 emmm  那就是 比如说在n+1空间里面放范围n的数字 那么肯定有重复的 那么就是  每一次扫描n+1空间里面所有的数字  然后将数字范围分为前后两个部分 看看前后两个部分的数字在n+1的空间里面出现了多少次 如果出现的比自己的范围大 那么就是在这个范围里面 类似于二分查找 再继续分 时间复杂度O(nlogn)</p>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法-栈之Leetcode</title>
    <url>/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/</url>
    <content><![CDATA[<h1 id="最近做了几题关于栈的-然后也是关于求矩形最大面积的"><a href="#最近做了几题关于栈的-然后也是关于求矩形最大面积的" class="headerlink" title="最近做了几题关于栈的  然后也是关于求矩形最大面积的"></a>最近做了几题关于栈的  然后也是关于求矩形最大面积的</h1><p>这里面涉及到一些类似于动态规划的意思  比如说单调栈 就是用前面的结果可以用于后面  这里面也有涉及 动态规划算是比较难想到的一类算法题吧 然后下面会总结一下算法的思路 下一次遇到算法题就知道大致的思路了</p>
<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>直接上图</p>
<img src="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/rain.png" class="" title="This is an example image">
<p>这里面我们的思路就是  首先我们肯定是要遍历这个柱子的高度的 毋庸置疑<br>这个时候 我们要确定的是 我们什么时候就可以确定已经遍历的柱子可以接雨水了？<br>接了多少雨水？  我们是一次性计算出全部还是分布计算？<br>首先肯定是一部分计算 因为一般这种题  如果不是求最大 或者是最小 一般来说遍历一次我们就可以直接得出答案 那么什么时候开始计算接了多少雨水呢？<br>一个碗  左边高 右边低  根据木桶效应  遍历到右边的时候 我们才知道可以接到多少水<br>在计算多少水的时候 我们需要知道已经遍历的里面的水量  我们只需要知道最近的 几根柱子 所以根据栈的先进先出就可以知道<br>直接上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (pos.empty()&amp;&amp;height[i]==<span class="number">0</span>)</span><br><span class="line">      &#123; <span class="comment">//如果空 那就push进去 然后下一个儿</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (!pos.empty() &amp;&amp; height[i] &gt; height[pos.top()])</span><br><span class="line">      &#123;                      <span class="comment">//不空 而且比栈顶大 就说明 现在构成了一个碗  但是这个碗可能只有右边</span></span><br><span class="line">        <span class="keyword">int</span> top = pos.top(); <span class="comment">//保存当前讨论的那个柱子的位置 因为我们要访问前面的柱子 也就事我们要计算 当前这个一格宽的碗底 的水的高度</span></span><br><span class="line">        pos.pop();<span class="comment">//看左边碗底 如果是左边没有我碗底 那就无</span></span><br><span class="line">        <span class="keyword">if</span> (pos.empty())</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">//如果这个时候已经是空的 那么就五</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> realHeight = min(height[i], height[pos.top()]);<span class="comment">//看一下这个碗真正的高度  是左边碗墙和右边碗墙 i是当前比碗底高的右边碗墙  碗底被pop了 top就是左边碗墙</span></span><br><span class="line">        <span class="keyword">int</span> dis = i - pos.top() - <span class="number">1</span>;</span><br><span class="line">        ans += dis * (realHeight - height[top]);</span><br><span class="line">      &#125;</span><br><span class="line">      pos.push(i); <span class="comment">//进去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这一道题的突破口就是 我们计算水量的时候 计算的方法是 分块计算 每一次计算都是矩形  因为计算机最喜欢公式 如果是什么奇奇怪怪的俄罗斯方块 那当然不行  每一次都是矩形 宽度自然是坐标偏移量 高度就是我们的碗的左右高度的最小值减去碗底的高度  这样一来就可以实现啦<br>至于为什么使用栈 很多人都想不到 栈的特性就是先进先出  我们可以保存数据  然后很方便访问到最近的数据  我们的碗  当发现比碗底高 知道是右边碗墙  我们就需要访问左边碗墙 左边碗墙刚好是最近的数据 方便访问  访问完之后直接出栈  之前保留的数据又可以暴露  nice</p>
<h2 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a>最大矩形</h2><p>这里的最大矩形指的是  直接上图吧hhh</p>
<img src="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/zhuzhuangtu.png" class="" title="This is an example image">
<p>因为是求最大的矩形  我们粗略的想一想 有很多种可能  可能是高度很矮  但是很多个柱子组成  可能是高度很高  一柱擎天  但是不管怎么样 计算机最喜欢的就是公式 矩形的公式就是长和宽 首先有没有办法直接遍历一次就找到？ 好像没有 因为我们不知道后面矩形的情况<br>暴力法 直接枚举每一个高度  找到这个高度的最大的宽度  然后就知道当前高度的矩形的最大值 但是枚举的时候有没有更好的办法  我们找矩形的时候 要找到最左边的地方和最右边的地方<br>如果一个柱子比当前枚举的高度要大  那么就不是当前柱子的边界 那么是不是也不可能是后面柱子的边界呢？  当前柱子代表了我是之前最小的  那么就会直接把结果挡住 嗯 这里后面的计算边界就可以借鉴前面的结果 On 就能解决<br>维护一个单调栈  为什么是单调栈？？ 这是因为 我们要知道离当前枚举的高度 最近的状态 那么就是栈  然后看最近的状态 如果比老子大  那么就不是我的边界  出栈！ 下一个  一直从铜锣湾杀到尖沙咀 就知道边界了 如果杀光了 那么边界就是最左边0了</p>
<h3 id="举个例子-比如图上的"><a href="#举个例子-比如图上的" class="headerlink" title="举个例子 比如图上的"></a>举个例子 比如图上的</h3><p>2   1   5   6   2   3<br>2入栈  他的左边是-1<br>1入栈的时候 看到2  嗯？ 比老子大！ 爬 2出栈 当前栈空 左边界是0<br>1入栈<br>5入栈的时候 看到1 嗯 比我小  留着吧  结果是5和1  不可能会访问到2  因为1已经挡住了 2的价值就不在了 就可以节省时间和空间  当前栈内 1  5<br>6入栈和5相同 直接入栈  1 5 6<br>2入栈  干掉5  6  得到1  站内  1 2  很容易知道结果的正确性</p>
<p>On求出所有左边界 On求出右 再 On求出每一个的值 维护一个最大ans<br>上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heights)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights.empty())        <span class="comment">//检测异常 面试必备</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; leftPos;     <span class="comment">//左边的单调栈</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; rightPos;</span><br><span class="line">        <span class="keyword">int</span> left[heights.size()];   <span class="comment">//储存左边界</span></span><br><span class="line">        <span class="keyword">int</span> right[heights.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!leftPos.empty() &amp;&amp; heights[leftPos.top()] &gt;= heights[i])<span class="comment">//如果比老子大就给爷爬 而且当然不能事空的</span></span><br><span class="line">            &#123;</span><br><span class="line">                leftPos.pop();  <span class="comment">//爬</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftPos.empty())    <span class="comment">//如果已经是空的 证明穿了  直接给最左边的赋值  这里的-1 魔法数字~</span></span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = leftPos.top();            <span class="comment">//碰到比我小的 当我小弟留着</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            leftPos.push(i);    <span class="comment">//统一入栈  因为要访问最近的情况 符合栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heights.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//大同小异</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!rightPos.empty() &amp;&amp; heights[rightPos.top()] &gt;= heights[i])</span><br><span class="line">            &#123;</span><br><span class="line">                rightPos.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightPos.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = heights.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = rightPos.top();</span><br><span class="line">            &#125;</span><br><span class="line">            rightPos.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;        <span class="comment">//在这里我们得到了左边界和右边界  这里的 -1 和 size两个魔法数字就体现了 嗯 这个-1也是魔法数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = max(ans, heights[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总体来说 这题的思维方式就是 如果用人的想法去写 一般写不出来  计算矩形 首先知道高贺宽 高可能是很多个 我们需要枚举  高在枚举的时候已经知道了 剩下的就是宽  宽的话  每一个高的宽  就是找到比我小的 那就是边界了 可以用栈的性质去解决 下一题</p>
<h2 id="最大矩形-1"><a href="#最大矩形-1" class="headerlink" title="最大矩形"></a>最大矩形</h2><p>直接上图 这个和上一个不太一样看起来很男</p>
<img src="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/zuidajuxing2.png" class="" title="This is an example image">
<p>这个呢 我们也可以归结为柱状图的最大矩形 但是这个底可能是在每一层  所以这里我们需要遍历每一层 得出当前这一层的heights数组 然后直接调用上一题的函数<br>这里也有个小技巧  我们每一层的高度数组 和上一层有关系 只和上一层有关系 有人会说 和最近的有关系 那不就是栈 但是 只和最近 注意这个只字  那之前的雨我无瓜 那就不用站 直接if来更新就行<br>上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最大柱状图 其实是最大的为1的矩形  然后使用最大柱状图的解法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;matrix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matrix.empty())<span class="comment">//异常检测 面试搞</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">heights</span><span class="params">(n)</span></span>; <span class="comment">//进行矩形数组的高度的初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//输入第一层 如果是1  那么高度就是1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                heights[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                heights[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = largestRectangleArea(heights);<span class="comment">//来个答案先</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][k] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    heights[k]++;   <span class="comment">//如果是1  那么就在上一层的基础上+1  如果上一层是0  那也是1  不影响</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    heights[k] = <span class="number">0</span>;      <span class="comment">//如果是0  那就不可能是矩形的角  你上面再高都没用</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, largestRectangleArea(heights)); <span class="comment">//当前层的答案</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(v.size())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(v.size())</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; leftPos;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; rightPos;</span><br><span class="line">        <span class="keyword">if</span> (v.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!leftPos.empty() &amp;&amp; v[leftPos.top()] &gt;= v[i])</span><br><span class="line">            &#123;</span><br><span class="line">                leftPos.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftPos.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = leftPos.top();</span><br><span class="line">            &#125;</span><br><span class="line">            leftPos.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!rightPos.empty() &amp;&amp; v[rightPos.top()] &gt;= v[i])</span><br><span class="line">            &#123;</span><br><span class="line">                rightPos.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightPos.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = v.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = rightPos.top();</span><br><span class="line">            &#125;</span><br><span class="line">            rightPos.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = max(ans, v[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总的来说 柱状图的矩形还是很有用的 嗯 over  干就完了</p>
<h2 id="二叉树的锯齿遍历"><a href="#二叉树的锯齿遍历" class="headerlink" title="二叉树的锯齿遍历"></a>二叉树的锯齿遍历</h2><img src="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/juchi.png" class="" title="This is an example image">
<p>如题 二叉树的锯齿遍历 有多种解法 先来个我手撕的 当时看到标题是栈 就自觉地的使用的栈  发现一个栈不太行 因为要同时进行栈顶操作和入栈 而且要把栈直接pop空  所以 一边pop一边push  有点呆 所以直接来两个栈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; s1;       <span class="comment">//来两个栈  </span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; s2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;    <span class="comment">//来个ans</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root)          <span class="comment">//异常检测 爬</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        s1.push(root);  <span class="comment">//首先root先入栈 紧接着就是从右往左 所以入s1</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)           <span class="comment">//这里while  1 是因为 一开始s2是空的 所以不能判断西面的if</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>)           <span class="comment">//往一个空栈里加 这个空栈pop  一直到空</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">                <span class="keyword">while</span> (!s1.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode *temp = s1.top();</span><br><span class="line">                    s1.pop();</span><br><span class="line">                    a.push_back(temp-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span> (temp-&gt;left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        s2.push(temp-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (temp-&gt;right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        s2.push(temp-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(a);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">                <span class="keyword">while</span> (!s2.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode *temp = s2.top();</span><br><span class="line">                    s2.pop();</span><br><span class="line">                    a.push_back(temp-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span> (temp-&gt;right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        s1.push(temp-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (temp-&gt;left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        s1.push(temp-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(a);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s1.empty() &amp;&amp; s2.empty())&#123;      <span class="comment">//这里就是说的 不能在while进行循环 因为一开始有一个是空的 所以无法进循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一开始标签说的是栈 所以一直想的是栈  但是我们二叉树的遍历有两种 一种是基于栈的  DFS的遍历 然后通过栈的特点  可以访问最近的状态 进行回溯<br>一种就是万能BFS  可以求各种高度 宽度  这里讲一下BFS的方法<br>BFS传统来说就是左到右 但是其实判断一下cnt  然后选择是push到vetor的头还是尾就行了 代码就不放了 DFS 因为是递归实现 那就要传level  在相应的ans的层面上去进行push头还是尾 就说到这 溜了 看js</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法之kmp算法和哈夫曼树</title>
    <url>/2020/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8Bkmp%E7%AE%97%E6%B3%95%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    <content><![CDATA[<p>今天数据结构课实验整了两个新东西 这里总结一下</p>
<h1 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h1><p>明明在讲图 突然来个字符串 不知道助教是怎么想的<br>kmp算法  其实实现的就是 从一个字符串里面寻找另外一个字符串是不是他的子串 按照我们暴力的解法 我们可以使用两个指针 从source和target两个字符串里面开始遍历 如果匹配的话 那么就继续 如果遍历到了target的尾部 那就证明找到成功 返回source指针的减去target长度的位置<br>如果发现有一个字符不匹配的话 那么两个指针都需要回退 回退的长度是target指针移动的长度<br>但是我们这里发现 如果发现不匹配了 那么之前匹配的结果可以继续利用 不需要全部回退完<br>这里可以利用的部分就是 我们的target字符串其中  后缀和前缀的重合度  比如说<br>ABCDEFG<b>ABKAB</b>UI<b>ABKABD</b>BB<br>ABKABD<br>这里面 当我们匹配前面的ABKAB的之后 下一个字母U  不是D 所以不匹配<br>如果按照暴力  这个时候应该是退回到B  target退回到A<br>但是这个时候 kmp算法就说 我们可以 只回退tar的指针 不回退source 的指针 为什么呢  其实就是 我们发现其中已经有字符不匹配的时候 我们就在已经匹配的字符里面去找可能成为开头的字符 什么意思呢 就是比如我们已经匹配的ABKAB  这个时候发现D不匹配 我们在ABKAB里面去找可能为tar开头的字符<br>因为匹配的字符我们是知道的  所以我们就可以直接知道当前字符串tar只需要回退多少格  而不是都重来<br>我们给每一个tar的字符的位置都给了一个匹配上的表 代表着当前我们如果匹配不上 那么tar 指针需要回退多少格 就不用再次匹配我们已经知道的 匹配过的头了<br>这个算法的核心就是  找到这个数组 对应着tar的每一个字符的匹配值<br>通俗的讲  就是求前缀和后缀的交集的最长的长度<br>直接上代码吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10000</span>];   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">(<span class="keyword">char</span>* t)</span> </span>&#123;        <span class="comment">//求这个数组  具体的方法见代码 我自己理解不是很透彻 </span></span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> (j &lt; <span class="built_in">strlen</span>(t) - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span> || t[j] == t[k]) &#123;</span><br><span class="line">      j++;</span><br><span class="line">      k++;</span><br><span class="line">      a[j] = k;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      k = a[k];     <span class="comment">//同一个子串里面用了kmp  妙  我讲不清楚</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span> *x, <span class="keyword">char</span> *y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    next(x);</span><br><span class="line">    <span class="keyword">int</span> len1=<span class="built_in">strlen</span>(y);</span><br><span class="line">    <span class="keyword">int</span> len2=<span class="built_in">strlen</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len1&amp;&amp;j&lt;len2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||y[i]==x[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j=a[j];<span class="comment">//如果不匹配 那么就回退到我们记录的地方 sourcce不用回退</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=len2)</span><br><span class="line">        <span class="keyword">return</span> i-len2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>哈夫曼树就是 最优树  每一个叶子节点有不同的权值 叶子节点的权值乘以到叶子的路径长度的值最小 我们称之为哈夫曼树 用于压缩算法  对不同出现频率的进行编码  出现频率高的就在树的比较靠近根节点的位置 出现频率低的就在远离根节点的位置</p>
<h2 id="构建哈弗曼树的原理"><a href="#构建哈弗曼树的原理" class="headerlink" title="构建哈弗曼树的原理"></a>构建哈弗曼树的原理</h2><p>首先每一个字符对应着一个权值  构成一个数组  我们每一次取出两个权值最小的字符 将他们从队列里面剔除  然后连成一个新的节点的二叉树  然后push进数组 权值为二者权值的和  重复这个过程<br>使用优先队列可以轻易每次得到最小的两个 然后push就完事了 具体不是很难</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>         //这里面节点储存着<span class="title">char</span>和权值</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    Node(<span class="keyword">long</span> <span class="keyword">long</span> val, <span class="keyword">char</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">        left = <span class="literal">NULL</span>;</span><br><span class="line">        right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node *a, <span class="keyword">const</span> Node *b)</span> <span class="keyword">const</span><span class="comment">//比较函数  注意这里的操作符是()  包装在一个结构体里面</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node *root, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;path)</span><span class="comment">//后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postorder(root-&gt;left, path);</span><br><span class="line">        postorder(root-&gt;right, path);</span><br><span class="line">        path.push_back(root-&gt;a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Node *, <span class="built_in">vector</span>&lt;Node *&gt;, cmp&gt; pq;<span class="comment">//优先队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">        Node *t = <span class="keyword">new</span> Node(val, a);<span class="comment">//cin初始化</span></span><br><span class="line">        pq.push(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pq.size() == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pq.top()-&gt;val &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//边缘检测</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node *a = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        Node *b = pq.top();</span><br><span class="line">        pq.pop();<span class="comment">//抓头 两个 并且pop</span></span><br><span class="line">        Node *sum = <span class="keyword">new</span> Node(a-&gt;val + b-&gt;val, <span class="string">&#x27; &#x27;</span>);<span class="comment">//把和抓紧去 并且push</span></span><br><span class="line">        <span class="keyword">if</span> (a-&gt;val &lt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            sum-&gt;left = b;</span><br><span class="line">            sum-&gt;right = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a-&gt;val &gt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            sum-&gt;right = b;</span><br><span class="line">            sum-&gt;left = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a-&gt;val == b-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a-&gt;a &lt; b-&gt;a)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum-&gt;left = b;</span><br><span class="line">                    sum-&gt;right = a;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    sum-&gt;right = b;</span><br><span class="line">                    sum-&gt;left = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       <span class="comment">//这谁在左边谁在右边自己定</span></span><br><span class="line">        root = sum;<span class="comment">//每一次更新树根 因为最后会连成一整棵树 得到的就是root</span></span><br><span class="line">        pq.push(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ans;</span><br><span class="line">    postorder(root, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : ans)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到此结束</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法之二叉树补充</title>
    <url>/2020/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>今天翻看代码 发现二叉树的三种遍历还没怼上去 这里说的都是非递归版本 别问 问就是上流 这里补充一下  顺便总结一下最近的烂东西</p>
<h1 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> s = [];</span><br><span class="line">    <span class="keyword">let</span> move = root;</span><br><span class="line">    <span class="keyword">while</span> (move || s.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (move) &#123;</span><br><span class="line">            res.push(move.val);</span><br><span class="line">            s.push(move);</span><br><span class="line">            move = move.left;</span><br><span class="line">        &#125;</span><br><span class="line">        move = s.pop();</span><br><span class="line"></span><br><span class="line">        move = move.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> s = [];</span><br><span class="line">    <span class="keyword">let</span> move = root;</span><br><span class="line">    <span class="keyword">while</span> (move || s.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (move) &#123;</span><br><span class="line">            s.push(move);</span><br><span class="line">            move = move.left;</span><br><span class="line">        &#125;</span><br><span class="line">        move = s.pop();</span><br><span class="line">        res.push(move.val);</span><br><span class="line">        move = move.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h1><p>这里面有两种方法 两种都是基于栈 这里面因为是后序遍历  我们需要记录当前的点是否已经被访问过  这里有两种方法 一种是增加一个last指针 另外一种就是push两次  pop的时候判断是不是在栈里面 直接上代码</p>
<h2 id="基于last指针的后续遍历"><a href="#基于last指针的后续遍历" class="headerlink" title="基于last指针的后续遍历"></a>基于last指针的后续遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> s = [];</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> last = root;</span><br><span class="line">    <span class="keyword">let</span> move = root;</span><br><span class="line">    s.push(move);</span><br><span class="line">    <span class="keyword">while</span> (s.length != <span class="number">0</span>) &#123;</span><br><span class="line">        move = s[s.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> ((move.left === <span class="literal">null</span> &amp;&amp; move.right === <span class="literal">null</span>) || (last == move.left &amp;&amp; move.right === <span class="literal">null</span>) || last == move.right) &#123;</span><br><span class="line">            res.push(move.val);</span><br><span class="line">            last = move;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (move.right) &#123;</span><br><span class="line">                s.push(move.right);    <span class="comment">//这里注意 因为是后序遍历 先访问左边 再是右边 所以栈顶应该是左边  所以左边后入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (move.left) &#123;</span><br><span class="line">                s.push(move.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="基于双push-pop的后续遍历"><a href="#基于双push-pop的后续遍历" class="headerlink" title="基于双push pop的后续遍历"></a>基于双push pop的后续遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal_two_push = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> s = [];</span><br><span class="line">    <span class="keyword">let</span> move = root;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> [];    <span class="comment">//这一行的作用是 如果是空的 那么root进栈之后 访问他的left就会出错  因为null没有left</span></span><br><span class="line">    s.push(root);</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (s.length != <span class="number">0</span>) &#123;</span><br><span class="line">        move = s.pop();</span><br><span class="line">        <span class="keyword">if</span> (move != s[s.length - <span class="number">1</span>] || s.length == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push(move.val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (move.right) &#123;           <span class="comment">//没错 就是这里</span></span><br><span class="line">                s.push(move.right);    </span><br><span class="line">                s.push(move.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (move.left) &#123;</span><br><span class="line">                s.push(move.left);      <span class="comment">//注意 这里也是right先进栈  然后 left再进  </span></span><br><span class="line">                s.push(move.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="这里说一下前端CSS的flex"><a href="#这里说一下前端CSS的flex" class="headerlink" title="这里说一下前端CSS的flex"></a>这里说一下前端CSS的flex</h1><p>如果是左右布局 一左一右  左边的宽度需要自适应 参考如下代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  .left&#123;</span><br><span class="line">    <span class="selector-tag">flex</span>: 1;</span><br><span class="line">    <span class="selector-tag">margin-right</span><span class="selector-pseudo">:auto</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法之并查集和dijktra和走迷宫</title>
    <url>/2020/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%92%8Cdijktra/</url>
    <content><![CDATA[<p>又是周四 今天继续讲图</p>
<h1 id="Dijkstra-算法-求最短路径-无向图"><a href="#Dijkstra-算法-求最短路径-无向图" class="headerlink" title="Dijkstra 算法 求最短路径 无向图"></a>Dijkstra 算法 求最短路径 无向图</h1><p>首先这个和走迷宫是不一样的 走迷宫和图不一样 图是顶点然后连边 但是迷宫可以说是图的搜索了 这个求最短路径一般来说不用到迷宫里面 用于我们的有向图的<br>求从一个顶点出发 到达所有顶点的值 如果到达的了的话<br>直接上代码吧 原理不多说了<br>还是说吧 就是维护一个状态数组 保存我们当前的状态 然后第一步 把 ans 数组全部置位 INT_MAX<br>然后第一步选择就是 source 把 ans[source]置位 0 自己到自己肯定最小就是 0<br>然后遍历所有 source 能到达的点 边权加上到达自己当前讨论的这个点 如果比数组中的状态要小 那么就更新我们的 ans 数组<br>这里不多说 直接上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cases = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; cases;</span><br><span class="line">    <span class="keyword">while</span> (cases--)<span class="comment">//测例</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> vertexs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> edges = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; vertexs &gt;&gt; edges;<span class="comment">//点数和边数</span></span><br><span class="line">        <span class="keyword">int</span> g[vertexs + <span class="number">1</span>][vertexs + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(vertexs + <span class="number">1</span>, INT_MAX)</span></span>;<span class="comment">//我们的答案 第i个表示从source到i的最小值</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(vertexs + <span class="number">1</span>, <span class="number">0</span>)</span></span>;<span class="comment">//是不是已经讨论过了  也就是最小已经是确定的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges; i++)<span class="comment">//邻接矩阵</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> from, to, weight;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to &gt;&gt; weight;</span><br><span class="line">            g[from][to] = weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> source = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; source;</span><br><span class="line">        <span class="keyword">int</span> root = source;</span><br><span class="line">        <span class="keyword">int</span> now_dis = <span class="number">0</span>;<span class="comment">//当前  从source到当前讨论的这个顶点  距离最小值</span></span><br><span class="line">        visited[source] = <span class="number">1</span>;<span class="comment">// 这个头肯定访问过儿了</span></span><br><span class="line">        ans[source] = <span class="number">0</span>;<span class="comment">//00000</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs - <span class="number">1</span>; i++)<span class="comment">//因为是每一个点  所以除了头 要确定N-1个点的最小值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= vertexs; j++)<span class="comment">//看看当前讨论的点 和其他所有点的关系</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[j] == <span class="number">0</span>)<span class="comment">//如果没背讨论过</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g[source][j])<span class="comment">//而且source可以到达</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> dis = now_dis + g[source][j];<span class="comment">//到当前的距离 加上source到这个点的距离</span></span><br><span class="line">                        <span class="keyword">if</span> (dis &lt; ans[j])<span class="comment">//如果通过这个点到j  比之前的情况要小 贪心选择最小的</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            ans[j] = dis;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> minIndex = <span class="number">0</span>;<span class="comment">//这里是寻找我们的下一个source  这里贪心选择每一次都是最小的</span></span><br><span class="line">            <span class="keyword">while</span> (visited[minIndex] == <span class="number">1</span> || ans[minIndex] == INT_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                minIndex++;</span><br><span class="line">                <span class="keyword">if</span> (minIndex == vertexs + <span class="number">1</span>)<span class="comment">//这里是华点 如果有一些点到不了的话 那么minIndex就会爆 这里访问的话就会mem seg了</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minIndex == vertexs + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = minIndex; i &lt;= vertexs; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[i] == <span class="number">0</span> &amp;&amp; ans[i] &lt; ans[minIndex])</span><br><span class="line">                &#123;</span><br><span class="line">                    minIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//上面就是找到当前状态的最小值</span></span><br><span class="line">            now_dis = ans[minIndex];<span class="comment">//找到的当前状态的最小值 就是到达这个点的最小值了 根据贪心算法 不可能有更大的值</span></span><br><span class="line">            source = minIndex;</span><br><span class="line">            visited[source] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= vertexs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; root &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="走迷宫的最短路径-（矩阵两点的最短路径）"><a href="#走迷宫的最短路径-（矩阵两点的最短路径）" class="headerlink" title="走迷宫的最短路径 （矩阵两点的最短路径）"></a>走迷宫的最短路径 （矩阵两点的最短路径）</h1><p>题目就是 从给定的点 到指定的点 能不能走到 求最短路径 直接上代码吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//如果是0  那就是通路 如果是1  那就是障碍物</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    point(<span class="keyword">int</span> xn = <span class="number">0</span>, <span class="keyword">int</span> yn = <span class="number">0</span>) : x(xn), y(yn) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">const</span> point &amp;x, <span class="keyword">const</span> point &amp;y)</span><span class="comment">//两点是不是相等</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x.x == y.x) &amp;&amp; (y.y == x.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_nbr</span><span class="params">(<span class="keyword">const</span> point &amp;p, point &amp;neighbor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p.x &gt; <span class="number">0</span> &amp;&amp; g[p.x - <span class="number">1</span>][p.y] == <span class="number">0</span>)<span class="comment">//把上下左右  都给你访问一遍  相当于BFS  层次遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        neighbor.x = p.x - <span class="number">1</span>;</span><br><span class="line">        neighbor.y = p.y;</span><br><span class="line">        g[neighbor.x][neighbor.y] = <span class="number">1</span>;<span class="comment">//走过就要堵住</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.x &lt; n - <span class="number">1</span> &amp;&amp; g[p.x + <span class="number">1</span>][p.y] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        neighbor.x = p.x + <span class="number">1</span>;</span><br><span class="line">        neighbor.y = p.y;</span><br><span class="line">        g[neighbor.x][neighbor.y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.y &gt; <span class="number">0</span> &amp;&amp; g[p.x][p.y - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        neighbor.x = p.x;</span><br><span class="line">        neighbor.y = p.y - <span class="number">1</span>;</span><br><span class="line">        g[neighbor.x][neighbor.y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.y &lt; m - <span class="number">1</span> &amp;&amp; g[p.x][p.y + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        neighbor.x = p.x;</span><br><span class="line">        neighbor.y = p.y + <span class="number">1</span>;</span><br><span class="line">        g[neighbor.x][neighbor.y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tx, ty, sx, sy;</span><br><span class="line">    point p, neighbor;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; g[i][j];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty;</span><br><span class="line">    sx--;</span><br><span class="line">    sy--;</span><br><span class="line">    tx--;</span><br><span class="line">    ty--;<span class="comment">//读取目标 然后因为矩阵从0开始 所以嗯 你懂得</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;point&gt; q;</span><br><span class="line">    q.push(point(sx, sy));</span><br><span class="line">    g[sx][sy] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>, new_access = <span class="number">0</span>, old_access = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty() &amp;&amp; !isEqual(q.front(), point(tx, ty)))<span class="comment">//找光了 或者是找到了  就会跳出循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = q.front();</span><br><span class="line">        <span class="keyword">while</span> (get_nbr(p, neighbor))<span class="comment">//访问每一个可以访问到的下一个点</span></span><br><span class="line">        &#123;</span><br><span class="line">            q.push(neighbor);</span><br><span class="line">            new_access++;<span class="comment">//这里储存的是 下一个 即将要遍历的层有多少个</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q.pop();</span><br><span class="line">        old_access--;<span class="comment">//这里表示的是当前层有多少个顶点  处理完就--</span></span><br><span class="line">        <span class="keyword">if</span> (old_access == <span class="number">0</span>)<span class="comment">//当前层已经处理完了  让这个等于new  也就是下一层的点数</span></span><br><span class="line">        &#123;</span><br><span class="line">            old_access = new_access;</span><br><span class="line">            new_access = <span class="number">0</span>;</span><br><span class="line">            step++;<span class="comment">//步数++</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEqual(q.front(), point(tx, ty)))<span class="comment">//如果是因为找到了就弹出 那么就输出step</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; step;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集的概念 来自于我们有许多不同的集合 这些集合并不相交 这些集合里面内部的关系我们并不关心 我们只关心这一些集合之间相交的关系</p>
<blockquote>
<p>比如我们江湖上有许多门派 江湖上有上千万个人 不同人属于不同的门派 但是他们自己并不知道自己究竟是那一个门派的 只知道自己的引路人 自己的引路人同样也只知道自己的引路人 但是这样 江湖上两个陌生人见面 怎么样才能知道自己是不是同一个阵营呢？</p>
</blockquote>
<p>这里就应用到了并查集的知识 不同的门派代表不同的集合 我们并不关心这个集合里面的问题 只关心这两个人是不是同一个集合的 所以就是问题所在啦 我们可以在这个集合里面选择一个人作为我们所有人的老大 每个人都知道自己的老大就是他 新加入的人 引路人直接告诉他我们的老大就是他 并不需要把引路人当做老大 这样就 ok</p>
<blockquote>
<p>上面讲述的其实是压缩路径的算法 原本的算法是 引路人问引路人 一层一层找到老大 但是压缩路径之后就只有两层 这样的话 因为不关心集合里面的顺序 所以无所谓 加大的查找的速度</p>
</blockquote>
<p>这里上一道题 我们班级有很多的朋友圈 朋友的朋友就是我的朋友 下面给一个无向图 下面判断这个无向图是不是构成一个朋友圈 就是判断每一个在集合里面的人是不是和其他人都是朋友</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">father</span><span class="params">(<span class="number">150000</span>)</span></span>;<span class="comment">// 这里储存的是 自己的老大是谁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//找老大  找老大的途中 我们一开始 输入的边 意思就是我们只能找到自己的引路人 这个函数就是 引路人告诉他 老大就是我的引路人 一直递归下去 就会找到门派老大  这个递归是个华点 可以进行路径压缩  因为一开始的是没有压缩过的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == father[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> father[x] = findFather(father[x]);<span class="comment">//赋值 告诉他  以后找我的老大就行了 别来找我了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;ll&gt; <span class="title">num</span><span class="params">(<span class="number">150000</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)<span class="comment">//一开始很多个集合</span></span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//给定了边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">int</span> q = findFather(x);<span class="comment">//找我的老大</span></span><br><span class="line">        <span class="keyword">int</span> p = findFather(y);<span class="comment">//同上</span></span><br><span class="line">        father[q] = p;<span class="comment">//老大相同 这一步相当于没做  如果老大不同  那就让一个老大 是另一个的老大 怎么 不服？  爪巴！ 这样的话 如果不进行路径压缩 无疑多了一层  所以这里体现了路径压缩的重要性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)<span class="comment">//这个函数是计算每一个老大有多少个小弟  num数组代表的是 以findFather为老大的集合有多少个</span></span><br><span class="line">    &#123;</span><br><span class="line">        num[findFather(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)<span class="comment">//如果是valid的朋友圈 意思就是任意两个人都是朋友 那么这个朋友圈就有n*(n-1)/2 条边  然后把每一个朋友圈应该的边数加起来</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += (num[i] * (num[i] - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == m)<span class="comment">//如果我们的真正的 输入的边m  等于这么多 那么就是valid 为什么呢 因为这里约定不会输入重复的边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>图图图  秃秃秃  over！</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法之折磨王</title>
    <url>/2020/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8A%98%E7%A3%A8%E7%8E%8B/</url>
    <content><![CDATA[<h1 id="总结一下二叉树的基本算法-很基本很基本-下面课文要求全文背诵"><a href="#总结一下二叉树的基本算法-很基本很基本-下面课文要求全文背诵" class="headerlink" title="总结一下二叉树的基本算法 很基本很基本 下面课文要求全文背诵"></a>总结一下二叉树的基本算法 很基本很基本 下面课文要求全文背诵</h1><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p>首先是递归的写法 很简单 就是当前的高度为 1 然后递归的进行左右子树的递归调用 取左右子树的最高 注意一开始要判断是不是空指针 如果是空指针的话 那么当前的高度就是 0 不能+1 上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTreeHeight</span><span class="params">(Node&lt;<span class="keyword">int</span>&gt;* tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tree) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left = getTreeHeight(tree-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = getTreeHeight(tree-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left &gt; right ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归版本 （一般的难点考察都是非递归的版本）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(pRoot=null)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">while</span> (len--)&#123;</span><br><span class="line">                TreeNode* temp=q.front();<span class="comment">//表头</span></span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left) q.push(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right) q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>非递归类似于 BFS 广度优先遍历 把每一层都遍历完之后 深度自然是+1</p>
<h2 id="二叉树的宽度-其宽度定义为各层结点数的最大值-其实就是顾名思义啦"><a href="#二叉树的宽度-其宽度定义为各层结点数的最大值-其实就是顾名思义啦" class="headerlink" title="二叉树的宽度 其宽度定义为各层结点数的最大值 其实就是顾名思义啦"></a>二叉树的宽度 其宽度定义为各层结点数的最大值 其实就是顾名思义啦</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">width</span><span class="params">(Node&lt;<span class="keyword">int</span>&gt; *bt)</span> <span class="comment">//求二叉树宽度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&lt;<span class="keyword">int</span>&gt; *&gt; q;</span><br><span class="line">    Node&lt;<span class="keyword">int</span>&gt; *p = bt;</span><br><span class="line">    <span class="keyword">int</span> len, width;</span><br><span class="line">    <span class="keyword">if</span> (!bt)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q.push(p);</span><br><span class="line">    width = len = q.size(); <span class="comment">//初始化，width表示当前比较过程中每一层节点个数的最大值，len为循环变量，表示每轮队列的长度，即每层的结点个数</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (len--) <span class="comment">//将上一层踢出去，下一层全部进来</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">                q.push(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        len = q.size();  <span class="comment">//此时的len为刚刚进来的那一层的结点个数</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; width) <span class="comment">//和已知的最大宽度比较，擂台赛</span></span><br><span class="line">            width = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两份代码都很像 其实就是解决了二叉树的层次遍历 这个层次遍历我们可以得到深度和广度 嗯 非常不错 因此层次遍历也有了一个很好听的名字 叫做广度优先遍历 BFS  （breadth first search） 听起来高大上 其实就是利用队列实现的一个遍历算法</p>
<h2 id="二叉树的叶子的数目"><a href="#二叉树的叶子的数目" class="headerlink" title="二叉树的叶子的数目"></a>二叉树的叶子的数目</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leaves</span><span class="params">(<span class="keyword">const</span> BinaryNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123; <span class="comment">// if head is nullptr, return directly</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">const</span> BinaryNode *&gt; qbfs;</span><br><span class="line">  qbfs.push(head);</span><br><span class="line">  <span class="keyword">while</span> (!qbfs.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (qbfs.front()-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123; <span class="comment">// if current queue front has left child</span></span><br><span class="line">      qbfs.push(qbfs.front()-&gt;left);</span><br><span class="line">      flag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (qbfs.front()-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123; <span class="comment">// if current queue front has right child</span></span><br><span class="line">      qbfs.push(qbfs.front()-&gt;right);</span><br><span class="line">      flag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    qbfs.pop(); <span class="comment">// pop if we have alreay visit the BinaryNode</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans=cnt;</span><br><span class="line">  cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又是二叉树的广度遍历 这个BFS  其实就是遍历每一个节点 看看是不是两个指针都是空的 如果都是空 那么就是叶子节点 ans++  求内部节点也可以是相同的道理</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>除了BFS  还有DFS 深度优先遍历  DFS 直接从一道题开始说起</p>
<img src="/2020/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8A%98%E7%A3%A8%E7%8E%8B/DFS.png" class="" title="This is an example image">
<p>DFS 我们根据的是递归调用 如果没有到叶子节点 那么就继续调用DFS  继续深挖</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.emplace_back(root-&gt;val);</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; sum == <span class="number">0</span>) &#123;</span><br><span class="line">            ret.emplace_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, sum);</span><br><span class="line">        dfs(root-&gt;right, sum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        dfs(root, sum);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树进阶AVL"><a href="#二叉搜索树进阶AVL" class="headerlink" title="二叉搜索树进阶AVL"></a>二叉搜索树进阶AVL</h2><p>BST 其实就是左边和右边的节点的大小是有特定含义的二叉树  这里面的进阶版本就是AVL 平衡二叉树 AVL的基础其实就是BST  只是在进行插入的时候 进行了一些列的左旋和右旋 对BST的平衡性进行了一系列的平衡  下面说一下AVL的实现<br>先上代码 再一行一行的分析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">avlnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">avlnode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">avlnode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; AVLNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">avltree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AVLNode *root;</span><br><span class="line">&#125; AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree *<span class="title">CreateAVLTree</span><span class="params">()</span> <span class="comment">//创建一个Tree</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree *tree = <span class="keyword">new</span> AVLTree;</span><br><span class="line">    tree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RootHeight</span><span class="params">(<span class="keyword">const</span> AVLNode *root)</span> <span class="comment">//当前节点的高度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;height; <span class="comment">//返回当前节点高度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> <span class="comment">//求Max</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingleRotateWithLeft</span><span class="params">(AVLNode **root)</span> <span class="comment">//这里用的双指针真的想呕  其实这里就是要改变root  如果传进来的只是一个root的话 那么这个指针指向的东西就不能改变了 否则要穿指针的引用</span></span></span><br><span class="line"><span class="function"></span>&#123;                                         <span class="comment">//这里其实是右旋- -  with left乱起名</span></span><br><span class="line">    AVLNode *temp;</span><br><span class="line">    temp = (*root)-&gt;left;                                                             <span class="comment">//保存需要左旋的头结点</span></span><br><span class="line">    (*root)-&gt;left = temp-&gt;right;                                                      <span class="comment">//需要左旋的root的左边已经不需要了 因为左边要成为新的root</span></span><br><span class="line">    temp-&gt;right = *root;                                                              <span class="comment">//下一个节点的右边等于当前的root</span></span><br><span class="line">    (*root)-&gt;height = Max(RootHeight((*root)-&gt;left), RootHeight((*root)-&gt;right)) + <span class="number">1</span>; <span class="comment">//先更新已经被插到下面节点的height</span></span><br><span class="line">    temp-&gt;height = Max(RootHeight(temp-&gt;left), RootHeight(temp-&gt;right)) + <span class="number">1</span>;          <span class="comment">//再更新已经成为root的height这样得到的高度就是最高</span></span><br><span class="line">    *root = temp;                                                                     <span class="comment">//改变传进来的指针变为左边的子节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingleRotateWithRight</span><span class="params">(AVLNode **root)</span> <span class="comment">//左旋就是头变成左边的子节点  左边子节点的右边变成原来的root  原来的左边子节点的右边变成root的左边</span></span></span><br><span class="line"><span class="function"></span>&#123;                                          <span class="comment">//这里是左旋  也就是右边太高了 旋转到左边 那么就是右边子节点的左边是当前root</span></span><br><span class="line">    AVLNode *temp;</span><br><span class="line">    temp = (*root)-&gt;right;                                                            <span class="comment">//左旋的时候 保存右边的节点</span></span><br><span class="line">    (*root)-&gt;right = temp-&gt;left;                                                      <span class="comment">//左边因为下一行要变成root  所以先对root的右边进行赋值 不然的话就会丢失</span></span><br><span class="line">    temp-&gt;left = *root;                                                               <span class="comment">//要当做root的左边已经被利用完了 可以进行赋值了</span></span><br><span class="line">    (*root)-&gt;height = Max(RootHeight((*root)-&gt;left), RootHeight((*root)-&gt;right)) + <span class="number">1</span>; <span class="comment">//先更新成为子节点的高度</span></span><br><span class="line">    temp-&gt;height = Max(RootHeight(temp-&gt;left), RootHeight(temp-&gt;right)) + <span class="number">1</span>;          <span class="comment">//再更新成为root节点的高度</span></span><br><span class="line">    *root = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoubleRotateWithLeft</span><span class="params">(AVLNode **root)</span> <span class="comment">//先左旋再右旋  整体是右旋  那么就是左子节点先要左旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SingleRotateWithRight(&amp;(*root)-&gt;left);</span><br><span class="line">    SingleRotateWithLeft(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoubleRotateWithRight</span><span class="params">(AVLNode **root)</span> <span class="comment">//先右旋再左旋  整体是左旋 那么就是右子节点先右旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SingleRotateWithLeft(&amp;(*root)-&gt;right);</span><br><span class="line">    SingleRotateWithRight(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AVLInsert</span><span class="params">(AVLNode *&amp;root, <span class="keyword">int</span> data)</span> <span class="comment">//插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == root) <span class="comment">//如果要插入的地方是NULL  那么就在当前节点直接插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> AVLNode; <span class="comment">//就是创建一个新节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == root)   <span class="comment">//申请内存失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;key = data;</span><br><span class="line">        root-&gt;height = <span class="number">0</span>;</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; root-&gt;key)</span><br><span class="line">    &#123;</span><br><span class="line">        AVLInsert(root-&gt;left, data);                               <span class="comment">//从左边插入  因为按照传统功夫的插入  如果比pivot小 那么就是在左边插入</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> == RootHeight(root-&gt;left) - RootHeight(root-&gt;right)) <span class="comment">//如果不平衡了 为什么是左边-右边 因为插入在左边 不可能右边比左边高</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; root-&gt;left-&gt;key) <span class="comment">//如果是插入了左节点的左边 那么就是阶梯式 那么只需要单纯的右旋</span></span><br><span class="line">            &#123;</span><br><span class="line">                SingleRotateWithLeft(&amp;root); <span class="comment">//右旋</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                DoubleRotateWithLeft(&amp;root); <span class="comment">//如果是在左节点的右边 那么就是左节点先左旋 然后根节点右旋</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; root-&gt;key) <span class="comment">//大同小异</span></span><br><span class="line">    &#123;</span><br><span class="line">        AVLInsert(root-&gt;right, data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> == RootHeight(root-&gt;right) - RootHeight(root-&gt;left))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &gt; root-&gt;right-&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                SingleRotateWithRight(&amp;root);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                DoubleRotateWithRight(&amp;root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;height = Max(RootHeight(root-&gt;left), RootHeight(root-&gt;right)) + <span class="number">1</span>;  <span class="comment">//插入完成之后 还要更新高度哦</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AVL的实现基本就是上述代码  这样我们的搜索每一次都可以接近log n  注意每次更新高度的时候 顺序的问题 先更新子节点的高度 然后更新父节点的高度</p>
<h2 id="看起来很简单的算法题—-寻找数组第k大的数"><a href="#看起来很简单的算法题—-寻找数组第k大的数" class="headerlink" title="看起来很简单的算法题—-寻找数组第k大的数"></a>看起来很简单的算法题—-寻找数组第k大的数</h2><h3 id="直接上On的解法-和快速排序相似的方法"><a href="#直接上On的解法-和快速排序相似的方法" class="headerlink" title="直接上On的解法  和快速排序相似的方法"></a>直接上On的解法  和快速排序相似的方法</h3><p>快速排序的理论就是  选择一个pivot  然后对当前的pivot 选择一个合适的位置 进行插入  那么这个插入的位置 就是这个数组里面 他确定的位置 那么要求第k大的数 就可以使用这个 这个只能求1个 而不是前k个大的数字  先上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;    <span class="comment">//这里的函数其实就是模拟了一趟快速排序</span></span><br><span class="line">  <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  swap(arr[left], arr[(left + right) / <span class="number">2</span>]);  <span class="comment">//这里是点睛之笔  如果无脑选择左边当做pivot 那么就会可能陷入出题人的坑  如果是顺序的话 那么时间复杂就会是n^2   这里的pivot 如果换做是一个random函数  这样的话就会更加趋近于平均的情况  这里选择的是中间的</span></span><br><span class="line">  <span class="keyword">int</span> i, j, base, temp;</span><br><span class="line">  i = left, j = right;</span><br><span class="line">  base = arr[left]; <span class="comment">//取最左边的数为基准数</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[j] &gt;= base &amp;&amp; i &lt; j)</span><br><span class="line">      j--;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] &lt;= base &amp;&amp; i &lt; j)</span><br><span class="line">      i++;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">      temp = arr[i];</span><br><span class="line">      arr[i] = arr[j];</span><br><span class="line">      arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//基准数归位</span></span><br><span class="line">  arr[left] = arr[i];</span><br><span class="line">  arr[i] = base;</span><br><span class="line">  <span class="keyword">return</span> i;       <span class="comment">//返回pivot应该呆的位置 如果这个位置就是k-1  就是k第k个小的数字 那么就ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select_kth_smallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">size_t</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (input.empty() || k &gt; input.size()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;wdnmd&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> input[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>, end = input.size() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> index;</span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    index = Partition(input, start, end);  <span class="comment">//先归位  然后获取这个pivot应该在的位置</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; k - <span class="number">1</span>)              <span class="comment">//如果这个位置比k小  那么这个第k个数肯定在这个pivot的右边 因为左边数字不够多了</span></span><br><span class="line">      start = index + <span class="number">1</span>;        <span class="comment">//排除这个pivot的左边 所以排除这个pivot在内的左边的数组</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; k - <span class="number">1</span>)</span><br><span class="line">      end = index;          <span class="comment">//和上面大同小异</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> input[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面选择第k小的数字使用了快速排序的pivot的归位然后使用递归 真不错</p>
<h2 id="判断一个二叉树是否平衡"><a href="#判断一个二叉树是否平衡" class="headerlink" title="判断一个二叉树是否平衡"></a>判断一个二叉树是否平衡</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTreeHeight</span><span class="params">(Node&lt;<span class="keyword">int</span>&gt;* tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tree) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left = getTreeHeight(tree-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = getTreeHeight(tree-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left &gt; right ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(Node&lt;<span class="keyword">int</span>&gt; *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="comment">//空树是平衡二叉树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> leftHeight = getTreeHeight(T-&gt;left); <span class="comment">//求左右子树的高度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rightHeight = getTreeHeight(T-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) <span class="comment">//判断根节点平衡因子不为-1、0、1时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (isBalanced(T-&gt;left) &amp;&amp; isBalanced(T-&gt;right)); <span class="comment">//递归调用，左右子树都为平衡二叉树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面的代码 通俗易懂 但是需要我理解的就是 如何使用递归 去得到树的高度  就是如果是空节点的话 那么就返回0  当前高度是0  如果不是空的  那么就递归返回两个子节点高度  然后取最大值 然后加上自己+1  判断是不是平衡 其实也就是判断左边的子节点是不是平衡的  注意 如果左边的高度等于右边的高度 那么还是不一定是平衡的 可能左右两边都是一条链  这个时候还是需要递归判断两个子节点是否是平衡的</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构预算法之图之邻接表之拓扑排序</title>
    <url>/2020/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%84%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9B%BE%E4%B9%8B%E9%82%BB%E6%8E%A5%E8%A1%A8%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>这里总结一下上一周的数据结构 大体上就是 邻接表的实现 邻接矩阵和邻接表 以及我们的拓扑排序</p>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>拓扑排序可以用于排序我们的有向图 形成一种依赖关系 他的排序原理还可以用于判断一个有向图是不是有环 下面直接上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 1000</span></span><br><span class="line"><span class="comment">// 边表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> adjvex; <span class="comment">//边指向哪个顶点的索引</span></span><br><span class="line">	<span class="keyword">int</span> weight;</span><br><span class="line">	EdgeNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 顶点表结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VertexNode</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> value; <span class="comment">//顶点的值，为了简化与序号相同，第一个是0</span></span><br><span class="line">	EdgeNode *firstedge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 图结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphList</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	VertexNode adjList[MAXVEX];</span><br><span class="line">	<span class="keyword">int</span> numVertex;</span><br><span class="line">	<span class="keyword">int</span> numEdges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这上面的代码 用于我们的邻接表进行图的储存 这是比较官方的做法 可以背诵 下面是根据上图的数据结构进行的拓扑排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphcircle</span><span class="params">(GraphList *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = g-&gt;numVertex;<span class="comment">//点的个数</span></span><br><span class="line">    <span class="keyword">int</span> visited[size] = &#123;<span class="number">0</span>&#125;;<span class="comment">//访问数组</span></span><br><span class="line">    <span class="keyword">int</span> in[g-&gt;numVertex] = &#123;<span class="number">0</span>&#125;;<span class="comment">//入度数组</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">//已经排序的数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)<span class="comment">//首先我们访问每一个点的邻接表  然后对每一条边的入度进行递增</span></span><br><span class="line">    &#123;</span><br><span class="line">        EdgeNode *move = g-&gt;adjList[i].firstedge;<span class="comment">//第i个点的邻接表的头 因为这里我们邻接表用的是一个链表进行实现 然后保存了表头  这里创建一个我们链表里面常用的move指针</span></span><br><span class="line">        <span class="keyword">while</span> (move)<span class="comment">//遍历这个邻接表</span></span><br><span class="line">        &#123;</span><br><span class="line">            in[move-&gt;adjvex]++;<span class="comment">//入度++</span></span><br><span class="line">            move = move-&gt;next;<span class="comment">//下一个儿</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//看到队列是不是就想到了BFS咧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)<span class="comment">//这个循环 首先是把我们的入度为0的都抓出来 因为我们拓扑排序可以是很多起点呀</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())<span class="comment">//对这个队列里面 已经是入度为0的点进行寻找下一个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> from = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        ans++;<span class="comment">//这里是对排序的结果进行输出 你想咋输出就咋输出  这里是一个妙用 下面会讲到</span></span><br><span class="line">        EdgeNode *move = g-&gt;adjList[from].firstedge;<span class="comment">//访问邻接表</span></span><br><span class="line">        <span class="keyword">while</span> (move)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//if (visited[move-&gt;adjvex] == 0)</span></span><br><span class="line"></span><br><span class="line">            in[move-&gt;adjvex]--;<span class="comment">//删除指向下一个的边 也就是下一个的入度--</span></span><br><span class="line">            <span class="keyword">if</span> (in[move-&gt;adjvex] == <span class="number">0</span>)<span class="comment">//如果入度是0  那么就证明这个就是下一个边啦 加入队列  注意我们这个时候 队列里储存的永远都是入度为0的点</span></span><br><span class="line">            &#123;</span><br><span class="line">                q.push(move-&gt;adjvex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            move = move-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans != g-&gt;numVertex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;has circle&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no circle&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此 我们就有了一个拓扑排序结果的输出的出口了  这里我们对排序的结果进行计数的原因就是 我们如果这个有向图里面是有环的 那么这个排序的数量就不会等于我们的点数了<br>上面的实现 如果变成邻接矩阵 其实也是一样的 直接在矩阵的相应的行里面进行查找就行了</p>
<p>上面实现了我们使用BFS 实现了我们的拓扑排序 然后根据拓扑排序的性质 知道了我们的有向图是否有环下面我们讲一下比较难懂的饿递归的DFS<br>从一道题出发  给定了一个依赖关系 需要判断是否有环 直接上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="comment">//bool valid = true;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="comment">//输出我们的环</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == v)</span><br><span class="line">            &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (pos; pos &lt; s.size(); pos++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// for (int i = s.size() - 1; i &gt;= 0; i--)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; s[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visited2[u] = <span class="number">1</span>;</span><br><span class="line">        s.push_back(u);</span><br><span class="line">        visited[u] = <span class="number">1</span>;        <span class="comment">//当前路径  访问过当前这个b了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : edges[u]) <span class="comment">//邻接矩阵 的第一个</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) <span class="comment">//没访问过哦</span></span><br><span class="line">            &#123;</span><br><span class="line">                dfs(v); <span class="comment">//深搜！ 进去！</span></span><br><span class="line">                <span class="comment">// if (!valid)</span></span><br><span class="line">                <span class="comment">// &#123;</span></span><br><span class="line">                <span class="comment">//     return;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) <span class="comment">//哦？ 已经访问过了 嗯 环  干他</span></span><br><span class="line">            &#123;</span><br><span class="line">                printStack(v);</span><br><span class="line">                <span class="comment">//return;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">0</span>; <span class="comment">//回溯</span></span><br><span class="line">        s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;prerequisites)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        visited2.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;info : prerequisites)</span><br><span class="line">        &#123;</span><br><span class="line">            edges[info[<span class="number">0</span>]].push_back(info[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; p; <span class="comment">//有12361    012350   0450三个环</span></span><br><span class="line">    p.push_back(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">0</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">3</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">5</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">3</span>, <span class="number">6</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">6</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    s.canFinish(<span class="number">7</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面的思想就是 我们给每一个点加上一个状态  也就是直接在visited数组上面操作就行<br>0 就是从来没有访问过  就是在以当前为起点没有访问过<br>1 就是当前起点已经访问过了  针对一次DFS而言 因为最后会恢复成0</p>
<p>这里面我们要求是输出所有的环 可能就会比较麻烦 我们不能直接返回有环  如果要返回有环 则直接看注释掉的代码<br>这里面的环是有重复的 需要操作一下  怎么操作 我不会~</p>
<p>下面是判断是不是有环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : edges[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;prerequisites)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;info : prerequisites)</span><br><span class="line">        &#123;</span><br><span class="line">            edges[info[<span class="number">0</span>]].push_back(info[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; p;</span><br><span class="line">    p.push_back(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">0</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">3</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">5</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">4</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    s.canFinish(<span class="number">6</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以 一个是判断有没有环  直接有环返回就行 而且可以剪枝  根据如果深搜之后 全局变量表示没有环 那么就是没有环了也就是说以这个为起点 直接搜到底 没有环 这个点肯定不参与构成环<br>这个算法不能求出所有的环 因为在当前的路走了一遍发现有环之后 不管如何都会置位2 那么再有环经过这里 那么就因为是2 就不会走这里了 2 就是 当前之后 肯定没环！  其实求所有环也可以剪枝 当前之后肯定没环置位2 dfs返回一个bool 而不是一个全局变量搞定 这里脑子不转了 就到这吧<br>讲了DFS和BFS 邻接表 拓扑排序</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法折磨王--图初步</title>
    <url>/2020/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%8A%98%E7%A3%A8%E7%8E%8B-%E5%9B%BE%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<p>今天数据结构老师给了图 这里总结一下自己完全不会的东西 - -</p>
<h1 id="Valid-BFS"><a href="#Valid-BFS" class="headerlink" title="Valid BFS"></a>Valid BFS</h1><p>这一题意思就是 给定一系列的边的父亲和儿子节点 按照顺序 然后给定了一串序列  要判定当前序列是不是按照BFS输出  重点是 这里的BFS不是我们常说的二叉树的BFS 这里的是  我们首先取出这个队列的头 然后这个头的两个子节点 我们按照任意的顺序 push到这个队列里面 注意 这里重点是任意的顺序 而不是我们常说的 从左到右  所以这里我们不能直接BFS 然后比较  我们要使用双指针模仿我们的BFS  也就是我们当前的慢指针 就是我们的队列头 然后我们在BFS的时候 会把这个队列头插入队列里面 然后我们输出的顺序就是按照这个队列 那么我们的快指针就可以判断当前的值是不是慢指针的邻居 如果是的话 那就移动向下一个 直到当前快指针不是当前慢指针的儿子节点  这个判断是不是儿子节点我们可以通过map进行储存  如果是的话 那么map的值就是1嗯  然后如果是BFS正确结果的话 那么应该这个快指针可以直接遍历到尾巴 上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp[maxN]; <span class="comment">//用来储存是不是有效的边 注意这里是数组哦</span></span><br><span class="line"><span class="keyword">int</span> q[maxN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="comment">//这里面只要n-1条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        mp[u][v]  = <span class="number">1</span>; <span class="comment">//这里面保存的是两个顶点是不是有边  如果有的话 那就是正常的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//目标数组</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line">    <span class="keyword">if</span> (q[<span class="number">1</span>] == <span class="number">1</span>) <span class="comment">//如果第一个头不是1  那就是题目傻逼</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>;        <span class="comment">//快慢指针 这里面也就是双指针   这里是重点 我们这里定义的bfs是 每一次从队列里面抓出第一个</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//然后按照任意顺序去插入他的邻居到队列 这里面的任意和我们的先左后右是不一样的 这就是这题的难点</span></span><br><span class="line">            <span class="keyword">for</span> (j; mp[q[i]][q[j]]; ++j)</span><br><span class="line">                ;</span><br><span class="line">        <span class="keyword">if</span> (j == n + <span class="number">1</span>)<span class="comment">//如果遍历到最后 那就是yes</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一题看起来没那么复杂 还是可以写的 那么下面呢？</p>
<h1 id="Obsession-with-Robots"><a href="#Obsession-with-Robots" class="headerlink" title="Obsession with Robots"></a>Obsession with Robots</h1><p>题目讲的就是 有一个机器人 在一个无限大的地图上面跑  然后给定了操作 比如说 U就是往前走 R L就是左走右走  然后到达一个坐标 问你这个机器人到达这个目的地是不是最短距离  意思就是 这个机器人走的路线有没有捷径可以让自己走的更短 我们简单地理解都是 路径有没有成环的地方 如果有 那就证明有捷径（其实不一定 如果这个环上面和下面路径一样长）  所以不能判断是不是成环 应该判断是不是有捷径 直接上代码  这里我们使用的也是BFS 上面讲述了BFS的原理 然后比较无聊的问了不同的顺序push进队列 基本没有什么实用价值 下面我们就是使用正常的BFS 解题<br>BFS究竟用在什么地方呢？ 其实就是 当前的一个状态 我们有很多个操作可以达到子状态的时候  我们去遍历这一些子状态  通过队列进行遍历  还有就是图的比较简单地非递归遍历  我们这里的机器人就是 当前我们可以上下左右4个状态 我们就需要BFS这四种状态 然后判断是不是已经访问过之类的然后进行push进队列  上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> M[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> T[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)<span class="comment">//初始化一个图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; j++)</span><br><span class="line">            M[i][j] = <span class="number">1</span>;<span class="comment">//全是障碍</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;<span class="comment">//输入路径</span></span><br><span class="line">    <span class="keyword">int</span> nowx = maxn / <span class="number">2</span>, nowy = maxn / <span class="number">2</span>;<span class="comment">//让这个B从图的中央开始走</span></span><br><span class="line">    M[nowx][nowy] = <span class="number">0</span>;<span class="comment">//开路  一开始的nowx 和nowy  就是开路</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (s[i])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            nowy++;</span><br><span class="line">            M[nowx][nowy] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">            nowx++;</span><br><span class="line">            M[nowx][nowy] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            nowx--;</span><br><span class="line">            M[nowx][nowy] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">            nowy--;</span><br><span class="line">            M[nowx][nowy] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//这里面走完这个图 开完路</span></span><br><span class="line">    <span class="keyword">int</span> enx = nowx, eny = nowy;</span><br><span class="line">    nowx = maxn / <span class="number">2</span>, nowy = maxn / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">    Q.push(<span class="built_in">make_pair</span>(nowx, nowy));</span><br><span class="line">    vis[nowx][nowy] = <span class="number">1</span>;        <span class="comment">//从头开始 已经访问过了</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())      <span class="comment">//跑bfs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; next = now;</span><br><span class="line">            <span class="keyword">switch</span> (i)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                next.first += <span class="number">1</span>;</span><br><span class="line">                next.second += <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                next.first += <span class="number">-1</span>;</span><br><span class="line">                next.second += <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                next.first += <span class="number">0</span>;</span><br><span class="line">                next.second += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                next.first += <span class="number">0</span>;</span><br><span class="line">                next.second += <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (vis[next.first][next.second])<span class="comment">//拜访过就下一个</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (M[next.first][next.second])<span class="comment">//障碍就下一个 证明没开路</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            T[next.first][next.second] = T[now.first][now.second] + <span class="number">1</span>;<span class="comment">//路程</span></span><br><span class="line">            vis[next.first][next.second] = <span class="number">1</span>;</span><br><span class="line">            Q.push(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T[enx][eny] &lt; s.size())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BUG&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里面的问题就是 这个机器人走的路径到底是不是最短的 也就是说有没有成环 就是从一开始走的时候  BFS就是把当前可能走到的位置直接标记了  比如我一开始就有捷径</span></span><br><span class="line"><span class="comment">可以走到我后面路径的位置  这个位置不是障碍物  然后标记是拜访过  然后就去这个地方  那么到时候在队列里面处理这个地方的时候 距离就是这个捷径+1 那么到终点的</span></span><br><span class="line"><span class="comment">距离就不是我们给的路径了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这里面是如何保证路径是最小的呢  因为我们是从头开始BFS的 有捷径就会先访问 这里也是BFS的优点</p>
<h1 id="Number-Clicker（双向BFS）"><a href="#Number-Clicker（双向BFS）" class="headerlink" title="Number Clicker（双向BFS）"></a>Number Clicker（双向BFS）</h1><p>嗯 双向BFS  听起来很牛逼 但是我们只要选好了数据结构 也没那么难  上面第一个 我们选择了MAP进行储存是不是当前两个点有边  第二个用了二维数组 进行储存我们走过的路径  二维数组更好体现了我们的路径 map体现的是边<br>这一题的意思就是给定两个数字 然后还有一个常数  然后第一个数字可以经过3种运算之后  得到第二个数字 问我们最少的操作数  还要输出我们是经过什么顺序的那种操作  这里我们肯定不能一次性在数组里面push 和pop  我们应该进行BFS然后储存当前的状态  这个状态包含什么呢 包含了我们上一个状态 上一个状态用了什么操作到当前状态  以及当前的步骤数 这里我们的key就是当前的状态 那就是map啦 储存一个struct 上代码  然后我们进行双向BFS  一边步骤数是减的 而且是负数 这里也是华点 然后我们从结果和开始双向BFS  然后如果当前的下一个状态已经被访问过了 那么就是相遇了 为什么呢 因为我们是BFS  具体的情况代码里说</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>//这里记录的是 当前的这个数字的  前身 以及前面用的是什么<span class="title">button</span> 和第几步</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> step, but;</span><br><span class="line">    LL pre;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;LL, Node&gt; path;<span class="comment">//这里建立的就是这个表 当前的LL对应的状态</span></span><br><span class="line">LL u, v, p;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">fpow</span><span class="params">(LL a, LL n)</span><span class="comment">//好家伙 快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            res = (res * a) % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(LL a, LL b, <span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, path[a].step - <span class="number">1</span> - path[b].step);</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">while</span> (a != u)</span><br><span class="line">    &#123;</span><br><span class="line">        Node ap = path[a];</span><br><span class="line">        S.push(ap.but);</span><br><span class="line">        a = ap.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, op);</span><br><span class="line">    <span class="keyword">while</span> (b != v)</span><br><span class="line">    &#123;</span><br><span class="line">        Node bp = path[b];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, bp.but);</span><br><span class="line">        b = bp.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    path.clear();</span><br><span class="line">    path[u] = (Node)&#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;<span class="comment">//双向BFS  为什么这里是BFS呢  其实BFS代表的就是 如果当前有很多个操作的状态 那么就我们需要记录每一种状态可能的结果  然后加入队列 等下下一轮的遍历</span></span><br><span class="line">    path[v] = (Node)&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;<span class="comment">//BFS的另一头</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;LL&gt; qf, qb;<span class="comment">//两个BFS的待处理的队列</span></span><br><span class="line">    qf.push(u);</span><br><span class="line">    qb.push(v);</span><br><span class="line">    <span class="keyword">while</span> (!qf.empty() || !qb.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!qf.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            LL x = qf.front();<span class="comment">//抓头</span></span><br><span class="line">            qf.pop();</span><br><span class="line">            Node xp = path[x];<span class="comment">//抓出当前这个头的状态</span></span><br><span class="line">            LL next = (x + <span class="number">1</span>) % p;<span class="comment">//第一个操作</span></span><br><span class="line">            Node np = path[next];<span class="comment">//map 如果没创建 那么就是0</span></span><br><span class="line">            <span class="keyword">if</span> (np.step == <span class="number">0</span>)</span><br><span class="line">            &#123; <span class="comment">//未访问</span></span><br><span class="line">                path[next] = (Node)&#123;xp.step + <span class="number">1</span>, <span class="number">1</span>, x&#125;;<span class="comment">//这个button之后的值的状态就是  步骤是+1  然后 使用的button就是1 x就是我们之前的</span></span><br><span class="line">                qf.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &lt; <span class="number">0</span>)<span class="comment">//当前的这个值的状态已经被初始化过了 那就是相遇啦  这里我们是可以保证是最短的 怎么说呢 想象一个树  每一层的状态*3  每一层代表了一个步骤  那么从上往下 这个的数的交点肯定是最小的 不可能绕弯路</span></span><br><span class="line">            &#123; <span class="comment">//相遇</span></span><br><span class="line">                Print(x, next, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next = (x + p - <span class="number">1</span>) % p; <span class="comment">//op2</span></span><br><span class="line">            np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (np.step == <span class="number">0</span>)<span class="comment">//这里也是华点  我们这里首先判断是不是访问过  如果不是 那就是第一次访问 然后因为是BFS  第一次访问肯定是最短的距离 所以直接保存</span></span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step + <span class="number">1</span>, <span class="number">2</span>, x&#125;;</span><br><span class="line">                qf.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &lt; <span class="number">0</span>)<span class="comment">//要是已经被保存过了  这里判断是不是相遇不是通过是不是已经保存 而是判断当前的step是不是和自己符号相反 因为如果是符号相同的话 那么现在的步骤肯定是比之前要多的 因为是BFS  如果符号相同 直接舍弃当前结果</span></span><br><span class="line">            &#123;</span><br><span class="line">                Print(x, next, <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next = fpow(x, p - <span class="number">2</span>);</span><br><span class="line">            np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (np.step == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step + <span class="number">1</span>, <span class="number">3</span>, x&#125;;</span><br><span class="line">                qf.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Print(x, next, <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!qb.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            LL x = qb.front();</span><br><span class="line">            qb.pop();</span><br><span class="line">            Node xp = path[x];</span><br><span class="line"></span><br><span class="line">            LL next = (x + p - <span class="number">1</span>) % p;</span><br><span class="line">            Node np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (!np.step)</span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step - <span class="number">1</span>, <span class="number">1</span>, x&#125;;</span><br><span class="line">                qb.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Print(next, x, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next = (x + <span class="number">1</span>) % p;</span><br><span class="line">            np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (!np.step)</span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step - <span class="number">1</span>, <span class="number">2</span>, x&#125;;</span><br><span class="line">                qb.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Print(next, x, <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next = fpow(x, p - <span class="number">2</span>);</span><br><span class="line">            np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (!np.step)</span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step - <span class="number">1</span>, <span class="number">3</span>, x&#125;;</span><br><span class="line">                qb.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Print(next, x, <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, tmp, T;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;u, &amp;v, &amp;p) == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (u == v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BFS();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>好了以上就是我们的全部内容了 其实今天有4题  我只看懂了3题  嗯  只写了3题 另外一个是树形DP 我爪巴</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理之期末临时抱佛脚</title>
    <url>/2020/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9C%9F%E6%9C%AB%E4%B8%B4%E6%97%B6%E6%8A%B1%E4%BD%9B%E8%84%9A/</url>
    <content><![CDATA[<p>临时抱佛脚 不知道还来不来得及  只记录了觉得记不住的东西</p>
<h1 id="第一章-计算机概要"><a href="#第一章-计算机概要" class="headerlink" title="第一章 计算机概要"></a>第一章 计算机概要</h1><h2 id="主储存器-运行内存"><a href="#主储存器-运行内存" class="headerlink" title="主储存器 运行内存~"></a>主储存器 运行内存~</h2><p>储存器的结构<br>DRAM dynamic random access memory 动态随机存取存储器  访问不同的地址的数据的速度都是一样的 在断电之后 数据消失<br>SRAM static ~ 速度更快  相当于DRAM里面的缓存  具体效果可以参考CPU的三级缓存  越高级 越快 越小 越贵</p>
<p>以上都是我们断电之后就会消失的储存器<br>当然还有断电之后不会消失的储存器 磁盘  我们把会消失的叫做主储存器 后者叫做二级储存器</p>
<h2 id="二级储存器-硬盘和闪存"><a href="#二级储存器-硬盘和闪存" class="headerlink" title="二级储存器 硬盘和闪存"></a>二级储存器 硬盘和闪存</h2><p>闪存就是比硬盘小 比硬盘快 比硬盘贵  而且不会断电消失</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU当然讲究性能<br>性能的两个度量指标<br>execution time 响应时间<br>bandwidth   吞吐率<br>性能之比就是执行相同的程序所需要的时间之比的倒数</p>
<h2 id="CPU性能"><a href="#CPU性能" class="headerlink" title="CPU性能"></a>CPU性能</h2><p>时钟周期       时钟周期就是CPU的上升沿和下降沿的时间差 这里不同的CPU有不同的时钟周期<br>CPI         cycle per instruction  平均每一条指令需要的时钟周期<br>指令数          从高级语言编译成汇编语言的数目<br>CPU频率         就是我们买的时候看到的GHz =  1/时钟周期</p>
<p><span style='color:red; font-size:30px'>key：       T = N * CPI / CPU频率 = N * CPI * 时钟周期 </span></p>
<h1 id="第二章-计算机指令"><a href="#第二章-计算机指令" class="headerlink" title="第二章 计算机指令"></a>第二章 计算机指令</h1><p>我们的指令一般是从op code和funct code 就能知道是什么操作<br>从op code 知道后面的指令的分割方法  有不同类型的指令</p>
<p>R type指令<br>op code 一般是0    re  rt 代表source寄存器 rd 是把结果储存的寄存器 shamt是移位  func 就是function code</p>
<table>
<thead>
<tr>
<th align="center">op (6)</th>
<th align="center">rs (5)</th>
<th align="center">rt (5)</th>
<th align="center">rd (5)</th>
<th align="center">shamt (5)</th>
<th align="center">func (6)</th>
</tr>
</thead>
</table>
<h2 id="转移地址表"><a href="#转移地址表" class="headerlink" title="转移地址表"></a>转移地址表</h2><p>就是把我们mips代码里面的前面的标签 转换成一个类似于map的数据结构<br>然后  每次进行branch  或者是j  jr的时候 就会在这个map里面 用标签作为key 去查找map里面的值 然后load 地址到寄存器里面  然后再跳转到寄存器的储存的地址</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>马克思主义原理-期末临时抱佛脚</title>
    <url>/2020/12/28/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86-%E6%9C%9F%E6%9C%AB%E4%B8%B4%E6%97%B6%E6%8A%B1%E4%BD%9B%E8%84%9A/</url>
    <content><![CDATA[<p>如题 抱佛脚 记录一下</p>
<h1 id="第一章-导论"><a href="#第一章-导论" class="headerlink" title="第一章 导论"></a>第一章 导论</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>1、马克思主义三个组成部分：<br>马克思主义哲学，马克思主义政治经济学，科学社会主义</p>
<p>2、中共和中国特色社会主义事业指导思想：<br>马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新<br>时代中国特色社会主义思想。<br>不仅包含由马克思、恩格斯建立并由列宁等发展了的马克思主义，也有联系中国社会实际的<br>马克思主义，是马克思主义中国化的理论成果。</p>
<p>3、三个组成部分的含义及关系：<br>马克思主义哲学是世界观和方法论的基础；<br>马克思主义政治经济学是对资本主义的理论剖析；<br>科学社会主义是马克思主义的结论和归宿，是马克思主义中最核心的内容。</p>
<p>4、马克思主义基本原理：<br>马克思主义基本原理是对马克思主义立场、观点、方法的集中概括，是马克思主义在其<br>形成、发展和运用过程中经过实践反复检验而确立起来的具有普遍真理性的理论。它体现马<br>克思主义的根本性质和整体特征，体现马克思主义科学性和革命性的统一。相对于特定历史<br>条件下所作的个别理论判断和具体结论，马克思主义基本原理具有普遍的、根本的和长远的<br>指导意义。<br>我们可以从基本立场、基本观点、基本方法的有机统一中，来学习和把握马克思主义基<br>本原理。</p>
<p>5、马克思主义直接理论来源<br>批判地吸收、继承德国古典哲学，英国古典政治经济学，英法的空想社会主义的合理成分。</p>
<p>6、马克思主义的公开问世：1848《共产党宣言》<br>问世的意义：为人们认识世界和时代问题提供了全新的世界观和方法论</p>
<p>①马克思主义是观察当代世界变化的认识工具。<br>②马克思主义是指引当代中国青年发展的行动指南。<br>③马克思主义是引领人类社会进步的科学真理。</p>
<h2 id="什么是马克思主义"><a href="#什么是马克思主义" class="headerlink" title="什么是马克思主义"></a>什么是马克思主义</h2><p>谁谁谁创建的<br>是关于<br>自然、社会和人类思维发展一般规律的学说，是关于社会主义必然代替资本主义、最终实现<br>共产主义的学说，是关于无产阶级解放、全人类解放和每个人自由而全面发展的学说，是指<br>引人民创造美好生活的行动指南。<br>3个组成部分  然后海纳百川</p>
<h1 id="第二章-唯物主义-物质的世界性和发展规律"><a href="#第二章-唯物主义-物质的世界性和发展规律" class="headerlink" title="第二章-唯物主义-物质的世界性和发展规律"></a>第二章-唯物主义-物质的世界性和发展规律</h1><ol>
<li>物质是客观实在的  不依赖人的意识存在</li>
<li>物质是世界唯一的本源   ———- 一元性</li>
<li>物质是联系的 发展的 发展的根本原因是矛盾</li>
</ol>
<p>马克思主义的物质观的理论意义在于：第一，坚持了唯物主义一元论，同唯<br>心主义和二元论划清了界限；<br>第二，坚持了能动的反映论和可知论，批判了不可<br>知论；<br>第三，体现了唯物论和辩证法的统一，克服了形而上学唯物主义的缺陷；<br>第四，体现了唯物主义自然观与唯物主义历史观的统一，为彻底的唯物主义奠定<br>了理论基础。</p>
<h2 id="主观能动性和客观规律性之间的辩证关系"><a href="#主观能动性和客观规律性之间的辩证关系" class="headerlink" title="主观能动性和客观规律性之间的辩证关系"></a>主观能动性和客观规律性之间的辩证关系</h2><p>首先 尊重客观规律是发挥主观能动性的前提<br>** 瞎扯 **<br>充分发挥主观能动性才能正确认识和利用客观规律<br>并不是说人在规律面前无能为力、无所作为。人能够通过自觉活<br>动去认识规律，并按照客观规律去改造世界，以满足自身的需要。因此，尊重事<br>物发展的客观规律性与发挥人的主观能动性是辩证统一的，实践是客观规律性与<br>主观能动性统一的基础</p>
<p>意思就是说 前提是客观规律 这个比较理解 我们首先用主观能动性去了解客观规律 然后再用主观能动性去改变世界  认识世界和改变世界都是用主观能动性</p>
<p>正确发挥人的主观能动性，有以下三个方面的前提和条件：<br>第一，从实际出<br>发是正确发挥人的主观能动性的前提。只有从实际出发、充分反映客观规律的认<br>识，才是正确的认识；只有以正确的认识为指导，才能形成正确的行动。<br>第二，<br>实践是正确发挥人的主观能动性的基本途径。正确的认识要变为现实的物质力<br>量，只能通过物质的活动一实践才能达到。<br>第三，正确发挥人的主观能动性，还<br>需要依赖于一定的物质条件和物质手段。没有现实的原材料，人的意识创造不出<br>任何物质的东西来</p>
<p>其实第一点就是要求符合客观规律<br>第二就是实践<br>第三就是依赖于物质条件和手段</p>
<h2 id="唯物辩证法的主要理念"><a href="#唯物辩证法的主要理念" class="headerlink" title="唯物辩证法的主要理念"></a>唯物辩证法的主要理念</h2><p>注意这里是唯物辩证法 而不是唯物主义 也不是物质观  物质观说的是世界和物质之间的关系  但是唯物辩证法讲的是  物质和我们问题之间的关系 低了一个层次</p>
<p>其一，事物是永恒发展的。经济发展不能以浪费资源、破坏环境和牺牲子孙<br>后代的利益为代价。在发展经济的同时，要注意合理利用资源，保护生态环境，<br>促进人与自然和谐相处，实现可持续发展。</p>
<p>其二，事物是普遍联系的。我们既要按照经济社会发展规律全面推进经济建<br>设、政治建设、文化建设和社会建设，又要遵循自然规律推动人与自然和谐发展，<br>实现经济发展与资源、人口、环境相协调。</p>
<p>其三，矛盾无处不在、无时不有，是一切事物发展的内在动力。只有通过解<br>决矛盾，求得协调和统一，才能实现人与人、人与社会、人与自然之间的和谐，<br>实现不同国家、不同文明之间的友好相处与共同繁荣</p>
<p>第四，唯物辩证法认为，整个世界处在由低级向高级的发展之中，它的发展<br>是由量的不断积累，超出度的范围，达到质的飞跃。这提示我们在学习和生和中<br>要重视量的积累，以实现质的飞跃。</p>
<h2 id="唯物辩证法和思维能力之间的关系"><a href="#唯物辩证法和思维能力之间的关系" class="headerlink" title="唯物辩证法和思维能力之间的关系"></a>唯物辩证法和思维能力之间的关系</h2><p>学习和掌握唯物辩证法的科学思维方法，要求我们在实践中不断增强思维能<br>力，特别是不断增强辩证思维能力、历史思维能力、战略思维能力、底线思维能<br>力和创新思维能力。</p>
<p>下面可以根据这几个不同的思维能力进行拓展叙述  其中需要注意的点就是</p>
<p>战略思维能力强调思维的整体性、全局性、长期性，是高瞻远瞩、统揽全局、<br>善于把握事物发展总体趋势和方向的能力。</p>
<p>底线思维是我们在认识世界和改造世界的过程中，根据我们的需要和客观的<br>条件，划清并坚守底线，尽力化解风险，避免最坏结果，同时争取实现最大期望<br>值的一种积极的思维。把握底线思维，就要“凡事从坏处准备，努力争取最好的<br>结果，这样才能有备无患、遇事不慌，牢牢把握主动权”。</p>
<h2 id="矛盾的特殊性和普遍性"><a href="#矛盾的特殊性和普遍性" class="headerlink" title="矛盾的特殊性和普遍性"></a>矛盾的特殊性和普遍性</h2><p>矛盾的普遍性是指矛盾存在于一切事物中，存在于一切事物发展过程的始<br>终，旧的矛盾解决了，新的矛盾又产生，事物始终在矛盾中运动。矛盾无处不在，<br>矛盾无时不有。<br>矛盾的特殊性是指各个具体事物的矛盾、每个矛盾的各个方面在发展的不同<br>阶段上各有其特点。矛盾的特殊性决定了事物的不同性质。只有具体分析矛盾的<br>特殊性，才能认清事物的本质和发展规律，并采取正确的方法和措施去解决矛盾，<br>推动事物的发展。</p>
]]></content>
      <categories>
        <category>马原</category>
      </categories>
  </entry>
  <entry>
    <title>CSS之视觉效果和字体排印和用户体验</title>
    <url>/2020/12/29/CSS%E4%B9%8B%E8%A7%86%E8%A7%89%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>这里讲一下 css 的第四章和第五章</p>
<h1 id="单侧投影和双侧投影"><a href="#单侧投影和双侧投影" class="headerlink" title="单侧投影和双侧投影"></a>单侧投影和双侧投影</h1><p>首先讲一下我们的 box-shadow box-shadow 有若干个参数</p>
<ol>
<li>水平偏移量</li>
<li>竖直偏移量</li>
<li>模糊距离</li>
<li>缩放尺寸</li>
<li>颜色</li>
</ol>
<p>我们的 shadow 实际上就是在我们的 box 后面 画一个纯色的矩形 然后以左上角为原点 进行平移 然后我们的模糊的尺寸 会影响到我们之际的大小我们实际的 shadow 大小 如果设置了模糊的话 那么就会比实际的要大<br>这里实现我们的单侧阴影就是利用我们的扩张值和我们的模糊值 下面直接上我们的 两侧阴影的代码</p>
<style>
@keyframes topDown {
        from {
          top: -300px;
          opacity: 0;
        }
        to {
          top: 95%;
          opacity: 1;
        }
      }
      .popBoxContainer {
        display: none;
        position: fixed;
        z-index: 11;
        height: 200px;
        width: 200px;
        top: 95%;
        right: 0;
        left: 40%;
        bottom: 0;
        background: rgb(78, 201, 180);
        animation: topDown 0.4s;
      }
      .popBoxHeader {
        background-color: rosybrown;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
      }
      .popBoxLayer {
        height: 100%;
        width: 100%;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        display: none;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.3);
        z-index: 10;
      }
input[type="checkbox"] {
  position: absolute; /*这两行实现了隐藏效果 以后就这么干就行了 原理太奇怪了*/
  clip: rect(0, 0, 0, 0);
}
input[type="checkbox"] + label::before {
  content: "\a0"; /*空格*/
  display: inline-block;
  width: 0.8em;
  height: 0.8em;
  margin-right: 0.2em;
  border-radius: 0.2em;
  background: silver;
  line-height: 0.65;
  text-indent: 0.15em;
}
input[type="checkbox"]:checked + label::before {
  content: "\2713";
  background-color: yellowgreen;
}
#test21 {
  height: 200px;
  width: 200px;
  margin: 30px;
  background: red;
  box-shadow: 10px 0px 10px -10px black, -10px 0px 10px -10px black;
}

#test22 {
        height: 200px;
        width: 200px;
        margin: 30px;
        background: linear-gradient(
              45deg,
              rgba(255, 0, 0, 0.8) 50%,
              transparent 0
            )
            100% 0 / 2.1em 2.1em no-repeat,
          linear-gradient(-135deg, transparent 1.5em, #85a 0);
      }

      #test23 {
        line-height: 1.5;
        background: beige;
        background-size: auto 3em;
        background-image: linear-gradient(
          rgba(0, 0, 0, 0.2) 50%,
          transparent 0
        );
      }

      #test24 {
  background-clip: content-box;
  height: 200px;
  width: 200px;
  background-color: burlywood;
  border-radius: 50% 50%;
  font-size: 35px;
  cursor: pointer;
  margin-left: 80px;
  border: 15px solid transparent;
}
</style>

<script>
      var popButton = document.getElementsByClassName("popButton");
      var closeButton = document.getElementsByClassName("closeButton");
      var card = document.getElementsByClassName("popBoxContainer");
      var layer = document.getElementsByClassName("popBoxLayer");
      function popOut() {
        layer[0].style.display = "block";
        card[0].style.display = "block";
      }
      function popIn() {
        layer[0].style.display = "none";
        card[0].style.display = "none";
      }
    </script>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test21</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">10px</span> <span class="number">0px</span> <span class="number">10px</span> -<span class="number">10px</span> black, -<span class="number">10px</span> <span class="number">0px</span> <span class="number">10px</span> -<span class="number">10px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="test21"></div>

<p>上面就是利用了我们的模糊进行扩张 然后利用扩展的负值进行把我们不需要的阴影给中和掉</p>
<h1 id="实现主色调图片处理-hover-恢复"><a href="#实现主色调图片处理-hover-恢复" class="headerlink" title="实现主色调图片处理 hover 恢复"></a>实现主色调图片处理 hover 恢复</h1><p>什么意思呢 就是在图片上 加上一层主色调 比如变灰度照片 然后 hover 的时候 恢复 这里本来需要使用滤镜 但是太复杂 这里给出了一些比较常见的实现方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test15</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">hsl</span>(<span class="number">335</span>, <span class="number">100%</span>, <span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">background-blend-mode</span>: luminosity;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(./temp/avatar.jpg);</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">10px</span> <span class="number">0px</span> <span class="number">10px</span> -<span class="number">10px</span> black, -<span class="number">10px</span> <span class="number">0px</span> <span class="number">10px</span> -<span class="number">10px</span> black;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.5s</span> background-color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#test15</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面的华点就是我们的 blend-mode 意思就是我们的背景就是可以混合模式 颜色和图片混合在一起</p>
<h1 id="毛玻璃效果-感觉像是一层玻璃"><a href="#毛玻璃效果-感觉像是一层玻璃" class="headerlink" title="毛玻璃效果 感觉像是一层玻璃"></a>毛玻璃效果 感觉像是一层玻璃</h1><p>先上效果图</p>
<img src="/2020/12/29/CSS%E4%B9%8B%E8%A7%86%E8%A7%89%E6%95%88%E6%9E%9C/maoboli.png" class="" title="This is an example image">

<p>下面上代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test15</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">2</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(./temp/avatar.jpg) <span class="number">0</span> / cover fixed;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#test16</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">90px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100%</span>, <span class="number">0.3</span>);</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#test16</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">margin</span>: -<span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(./temp/avatar.jpg) <span class="number">0</span> / cover fixed;</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">7px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码 我们直接一步一步来</p>
<ol>
<li>首先创建了一个底盘的 div 然后潜逃了一层 div 第二层 div 用来放我们的内容</li>
<li>其次 我们把我们的底盘的背景设置为一个图片 然后我们的内容设置一个 before 的伪元素 这个伪元素也是以我们的图片为背景 然后设置背景的样式 这样就可以实现我们的图片的无缝衔接</li>
<li>然后处理好我们的 position 关系 z-index 设置好我们的层</li>
<li>重点来了 因为们的模糊滤镜会把边缘也一起模糊掉 这样的话就没有玻璃的质感 就是明显的边缘 所以我们需要设置 margin 为负数这样对图片进行放大 然后 overflow hidden 就可以切割出我们的边缘效果</li>
<li>还需要注意的就是 如果我们要对毛玻璃加上颜色 那就对我们的内层 div 加上背景颜色注意 一定要是透明的 也就是需要的颜色 然后 alpha 是透明的 这样才能看到我们后面的 blur 滤镜之后的背景图片 实现毛玻璃</li>
</ol>
<blockquote>
<p>这里补充很多我们的 background 的语法</p>
</blockquote>
<blockquote>
<p>简写的顺序如下: bg-color || bg-image || bg-position [ / bg-size]? || bg-repeat || bg-attachment || bg-origin || bg-clip</p>
</blockquote>
<p>这里面的 补充下面几点知识</p>
<ul>
<li>background-origin: 设置背景图像显示的原点[background-position 相对定位的原点];</li>
<li>background-clip: 设置背景图像向外剪裁的区域;</li>
<li>background-attachment: 指定背景图像是滚动还是固定; 就跟 absolute 一样</li>
<li>background-position: 设置背景图像的位置; 这里面可以设置我们的 top right 之类的 如果是 0 就直接一个 0</li>
<li>background-size: 设置背景图像的大小; 这里面 我们一般有几种填充的方法<ul>
<li>一种是 cover 就是覆盖 但是会保持原来的比例 不会在高和宽上面进行延伸 所以可能图片会超出范围 然后超出的会被直接剪切</li>
<li>一种是 contain 图片会在原来的比例下 保持在 div 里面</li>
<li>一种是 100% 会被拉伸</li>
</ul>
</li>
</ul>
<p>下面需要注意的就是</p>
<blockquote>
<ol>
<li>background-position 和 background-size 属性, 之间需使用/分隔, 且 position 值在前, size 值在后。 这个相当于一个语法糖 并不是之前我们的简写 上面的代码有用到</li>
<li>如果同时使用 background-origin 和 background-clip 属性, origin 属性值需在 clip 属性值之前, 如果 origin 与 clip 属性值相同, 则可只设置一个值。</li>
<li>origin 是背景开始的地方 可以是</li>
</ol>
<ul>
<li>padding-box</li>
<li>border-box</li>
<li>content-box</li>
</ul>
<ol start="4">
<li>这里我们的 clip 只是简单地剪切 并不能指定开始 所以直接 clip 可能会丢失</li>
</ol>
</blockquote>
<h1 id="实现书页折角"><a href="#实现书页折角" class="headerlink" title="实现书页折角"></a>实现书页折角</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test22</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, rgba(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.8</span>) <span class="number">50%</span>, transparent <span class="number">0</span>) <span class="number">100%</span></span><br><span class="line">      <span class="number">0</span> / <span class="number">2.1em</span> <span class="number">2.1em</span> no-repeat, <span class="built_in">linear-gradient</span>(</span><br><span class="line">      -<span class="number">135deg</span>,</span><br><span class="line">      transparent <span class="number">1.5em</span>,</span><br><span class="line">      #<span class="number">85</span>a <span class="number">0</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="test22"></div>

<p>用两个背景图片 linear-gradient 一个是形成右上角的 transparent 一个形成我们折角的覆盖</p>
<blockquote>
<p>这里有一个需要注意的点就是 如果我们有多个背景图片 那么先声明的会覆盖在后声明的上面 不信你改动这两个位置试试</p>
</blockquote>
<h1 id="巧妙利用选择器进行换行等布局"><a href="#巧妙利用选择器进行换行等布局" class="headerlink" title="巧妙利用选择器进行换行等布局"></a>巧妙利用选择器进行换行等布局</h1><p>这里拿的是我们的自定义表格<br>如果我们要实现下面的情况</p>
<img src="/2020/12/29/CSS%E4%B9%8B%E8%A7%86%E8%A7%89%E6%95%88%E6%9E%9C/biaoge.png" class="" title="This is an example image">

<p>怎么实现呢？ 我们的 dt 和 dd 都是 block 元素 默认换行 所以直接上下面的代码 细细品味吧</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">dd</span> + <span class="selector-tag">dt</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;\A&quot;</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">dt</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">dd</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">dd</span> + <span class="selector-tag">dd</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">0.25em</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;,&quot;</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择器的奥妙 细细品味吧 这里不多说了</p>
<h1 id="实现我们文本的斑马纹"><a href="#实现我们文本的斑马纹" class="headerlink" title="实现我们文本的斑马纹"></a>实现我们文本的斑马纹</h1><p>其实就是实现代码高亮的效果 但是不是文字颜色的变化 而是我们的背景的斑马条纹 下面直接上效果</p>
<p id="test23">
        while.br <br />
        hahhab <br />
        int a <br />
        hhsihs <br />
</p>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">  <span class="attribute">background</span>: beige;</span><br><span class="line">  <span class="attribute">background-size</span>: auto <span class="number">3em</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>) <span class="number">50%</span>, transparent <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面运用到了比较重要的思想就是 我们背景的自适应</p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">normal</td>
<td align="center">默认 设置合理的行间距</td>
</tr>
<tr>
<td align="center">length</td>
<td align="center">设置固定的行间距 px 啥的</td>
</tr>
<tr>
<td align="center">% 百分比</td>
<td align="center">你懂得</td>
</tr>
<tr>
<td align="center">数字 number</td>
<td align="center">设置数字，此数字会与当前的字体尺寸相乘来设置行间距。</td>
</tr>
</tbody></table>
<ol>
<li>首先设置我们的行高是我们字体大小的 1.5 倍</li>
<li>背景颜色首先设置平铺</li>
<li>背景的大小 我们设置为我们的可以重复的片段 这里的高度是 3em 因为字体大小是 1em 行高是 1.5 字体大小 那就是 1.5em 两行一个重复 那就是 3em 啦</li>
</ol>
<h1 id="tab-size"><a href="#tab-size" class="headerlink" title="tab-size"></a>tab-size</h1><p>我们的浏览器默认的 tab 字符是 8 宽度 所以在 pre 标签和 code 标签之内 慎用 tab 但是我们可以用 css 直接给你格式化咯<br>但是貌似我的浏览器不太支持</p>
<h1 id="用户体验之按钮热区域扩大"><a href="#用户体验之按钮热区域扩大" class="headerlink" title="用户体验之按钮热区域扩大"></a>用户体验之按钮热区域扩大</h1><p>热区域就是我们的鼠标可以点击的区域 我们用户的可点击范围应该是比我们视觉要宽的 这个法则叫做 Fitts 法则</p>
<blockquote>
<p>Fitts 法则 人类移动到某个目标区域所需的最短时间是巴拉巴拉 意思就是必须扩张热区域</p>
</blockquote>
<p>我们具体是怎么实现的呢</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#test24</span> &#123;</span><br><span class="line">  <span class="attribute">background-clip</span>: content-box;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: burlywood;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">35px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">15px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><button id="test24">wdnmd</button></p>
<p>我们其实就是实现了一个 transparent 的边框 然后这里的重点就是我们设置了背景不是默认的 border-box 了 而是我们的 content-box 这样的话 我们的 border 就不会显示我们的背景颜色了</p>
<h1 id="实现自定义-checkbox"><a href="#实现自定义-checkbox" class="headerlink" title="实现自定义 checkbox"></a>实现自定义 checkbox</h1><p>下面我们先补充一下 css 的属性 clip<br>这个属性就是对元素进行剪切 上右下左 相对于左上角画一个矩形进行裁剪 下面直接上代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="comment">/*这两行实现了隐藏效果 以后就这么干就行了 原理太奇怪了这样这个元素只会隐藏 而且tab键进行下一个的时候可以访问到*/</span></span><br><span class="line">  <span class="attribute">clip</span>: <span class="built_in">rect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;\a0&quot;</span>; <span class="comment">/*空格*/</span></span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.8em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.8em</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">background</span>: silver;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">0.65</span>;</span><br><span class="line">  <span class="attribute">text-indent</span>: <span class="number">0.15em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;\2713&quot;</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellowgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体效果是（点点看）<br><input type="checkbox" id="good" /> <label for="good">wdnmd</label></p>
<h1 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h1><p>！！！ 这里是我一直想学的 认真听!</p>
<p><button class="popButton" onclick="popOut()">点点看</button></p>
<div class="popBoxLayer">
      <div class="popBoxContainer" id="aaa">
        <div class="popBoxHeader">
          <span>This is a head</span>
          <button class="closeButton" onclick="popIn()">X</button>
        </div>
        <div class="popBoxContent">
          <p>wdnmd good very good</p>
        </div>
      </div>
    </div>

<p>下面上代码哦</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.popBoxContainer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">11</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">78</span>, <span class="number">201</span>, <span class="number">180</span>);</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">animation</span>: topDown <span class="number">0.4s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.popBoxHeader</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: rosybrown;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.popBoxLayer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>);</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是设置背景直接填满 然后需要注意的就是 position fixed 然后从左上角开始 这个 layer<br>这个 layer 可以嵌套也可以进行单独独立出来 反正就是用于阻断用户和背景的交互</p>
<p>再加上一点 js 代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> popButton = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;popButton&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> closeButton = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;closeButton&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> card = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;popBoxContainer&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> layer = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;popBoxLayer&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popOut</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  layer[<span class="number">0</span>].style.display = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">  card[<span class="number">0</span>].style.display = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popIn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  layer[<span class="number">0</span>].style.display = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">  card[<span class="number">0</span>].style.display = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单的啦</p>
<h1 id="实现两张图骨片滑动比对"><a href="#实现两张图骨片滑动比对" class="headerlink" title="实现两张图骨片滑动比对"></a>实现两张图骨片滑动比对</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;below&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;over&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./temp/avatar.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./temp/avatar.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#below</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#below</span> &gt; <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">2px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#over</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">resize</span>: horizontal;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<style>
  #below {
    position: relative;
    display: inline-block;
  }
  #below > img {
    filter: blur(2px);
  }
  #over {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    resize: horizontal;
    overflow: hidden;
    width: 50%;
    max-width: 100%;
    z-index:5;
  }
  #overimg{
    max-width: none;
    margin-bottom:0;
  }
</style>
<div id="below">
  <div id="over">
    <img src="/2020/12/29/CSS%E4%B9%8B%E8%A7%86%E8%A7%89%E6%95%88%E6%9E%9C/maliao.png" alt="" id="overimg"/>
  </div>
  <img src="/2020/12/29/CSS%E4%B9%8B%E8%A7%86%E8%A7%89%E6%95%88%E6%9E%9C/maliao.png" alt="" />
</div>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
</search>
