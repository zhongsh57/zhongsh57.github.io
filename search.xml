<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建博客采坑指南</title>
    <url>/2020/11/03/First-Page/</url>
    <content><![CDATA[<p>倒腾了半个下午，倒腾出博客的雏形。<br><br>配置一系列的cli和开发环境，之前倒腾angular的时候，已经下了npm和node.js git等 这里不赘述<br>记录一下自己的采坑之旅</p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>有一说一，hexo自带的主题真的丑的我没话讲，上面丑陋的背景图 丑陋的比例，以及丑陋的布局<br></p>
<img src="/2020/11/03/First-Page/back.webp" class="" title="This is an example image">



]]></content>
      <categories>
        <category>Start</category>
      </categories>
  </entry>
  <entry>
    <title>CDN概念学习</title>
    <url>/2020/11/04/CDN%E6%A6%82%E5%BF%B5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="什么叫DNS"><a href="#什么叫DNS" class="headerlink" title="什么叫DNS"></a>什么叫DNS</h1><p>DNS就是域名解析器  把域名解析成ip地址 通过ip地址进行计算机的互联  核心概念就是 我们现在的互联网 就和书上讲的一样 由计算机连成的网络 一台计算机要连接另外一台计算机 需要知道另外一台计算机在哪里 我才能去找到他 拿到我想要的东西 详情请参考 <a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">阮一峰互联网协议入门</a><br>我们其中的DNS 就是通过我们人好识别的域名 比如说<a href="http://www.baidu.com/">www.baidu.com</a> 知道他是百度  他的资源放在一个计算机上 我们要找到那台计算机 然后告诉他我要搜个啥  找到这台计算机 DNS服务器会通过域名解析系统 将域名解析成ip地址供给我们的计算机去找（老婆）  域名解析的实现请参考<a href="http://www.ruanyifeng.com/blog/2016/06/dns.html">DNS原理入门</a> 这里只需要知道 DNS负责把域名转换为 我们要去请求的ip地址</p>
<p>为什么DNS会污染 这不是谁干的 而是运营商干的 比如github这种 “危险网站”  里面的个人博客 都要给你全部污染掉 这也是采用阿里 tx 这一些稳定的DNS服务器的原因</p>
<h1 id="CDN粗解"><a href="#CDN粗解" class="headerlink" title="CDN粗解"></a>CDN粗解</h1><h2 id="CDN处于什么层面"><a href="#CDN处于什么层面" class="headerlink" title="CDN处于什么层面"></a>CDN处于什么层面</h2><p>现在的互联网 大多数包含了大量的静态内容 比如说你现在看到的博客 图片储存 js代码储存 这些静态内容是最耗费带宽的 也就是加载页面的速度 如果你的网站已经是全国知名的博客 如果所有慕名而来的小伙子都想看你的博客 那么他们都会输入你的域名 通过DNS服务器找到你放博客的计算机的ip地址 （顺着网线把你抓出来） 这样的话 你的服务器再强也顶不住 </p>
<p>这个时候就需要提供一个缓存的阶段 俗话说人不能在一棵树上吊死 我们就把我们的内容存在其他的地方 当做是备份 （分布式储存） 这个备份会有很多份，我们当然是找到越近的服务器当然是越快啦。 综上所述 CDN就是<b>处于</b>在我们知道的人能理解的域名<b>和</b>最快的储存着我们资源的计算机的ip地址之间的东西啦 他和DNS是怎么样协作的呢</p>
<p>首先 我们先提交域名 就像上文一样 先检查本地是不是有这个域名的ip缓存 如果没有 那么就去请求我们配置的DNS服务器 告诉他  3秒钟之内 我要这个域名的ip！(3s有点久) 然后DNS服务器开始解析域名 当他解析到这个域名的CNAME（重定向 将当前请求域名重定向到目标ip）记录时  他就会把这个请求丢给CNAME 记录的ip地址 这个时候的ip地址还不是你想要的  这个ip地址是那个万人迷网站在DNS服务器上 加上的CNAME 记录 指向CDN均衡负载系统 也就是说  你要请求我的万人迷网站 首先我会把你的第一次请求给CNAME指向的CDN均衡负载系统 这个均衡负载系统接收到你的请求 他就会看你发请求的ip  开始分析emmmmm 你这个人是深圳来的啊  然后就系统就把深圳最快的ip（CDN节点）返回给你自己 </p>
<p>现在为止 你的第一次请求结束 你获得了一个深圳CDN节点ip</p>
<p>接下来你就会拿着这个距离深圳最快的ip 去找（万人迷网站还没找到呢） 你找到了深圳的CDN节点 这个节点  如果是第一次访问 那么这个节点 就去访问那台储存着万人迷网站的  真正的主机 然后把数据储存在节点 然后把数据返回给你  接下来 每一次深圳周围的人想访问这个网站 这个CDN节点就相当于 一个备份啦 而且访问速度会很快 主机也不会疯狂被请求 CDN加速的意义就此体现</p>
<h2 id="来张图"><a href="#来张图" class="headerlink" title="来张图"></a>来张图</h2><img src="/2020/11/04/CDN%E6%A6%82%E5%BF%B5%E5%AD%A6%E4%B9%A0/cdn.png" class="" title="This is an example image">
<p>图片转载自：<a href="https://www.cnblogs.com/lianghe01/p/11132133.html">CDN详解</a></p>
]]></content>
      <categories>
        <category>NET相关</category>
      </categories>
  </entry>
  <entry>
    <title>JS原始数据类型的对象包装</title>
    <url>/2020/11/11/JS%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85/</url>
    <content><![CDATA[<p>在JS的原始数据类型 也有内置的对象封装 里面有一些常见的方法 如果我们对原始数据类型进行对象的使用 那么就会隐式转化为对象 然后对象执行方法 然后对象在当前行被清除  类似下面代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1=<span class="string">&quot;Some String&quot;</span>;</span><br><span class="line"><span class="comment">/////////////////////////</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>s1会在一瞬间变成一个对象然后被销毁</p>
<h1 id="Boolean对象"><a href="#Boolean对象" class="headerlink" title="Boolean对象"></a>Boolean对象</h1><p>建议不要使用<br>在进行逻辑表达式运算的时候 一个Object&amp;&amp;其他 == true&amp;&amp;其他<br>这样的话  如果你的Boolean对象里面是false  但是还是会当做true进行运算</p>
<h1 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h1><p>需要注意的有以下的函数</p>
<h2 id="x-toFix"><a href="#x-toFix" class="headerlink" title="x.toFix()"></a>x.toFix()</h2><p>四舍五入 保留指定参数的小数位数</p>
<h2 id="x-toExponential"><a href="#x-toExponential" class="headerlink" title="x. toExponential()"></a>x. toExponential()</h2><p>指的是将数字转化为科学计数法 参数指定的是 在小数点后面保留多少位小数 比如说</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">16.191111</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1.toExponential(<span class="number">2</span>)); <span class="comment">// &quot;1.62e+1&quot;</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">16.111111</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1.toExponential(<span class="number">0</span>)); <span class="comment">// &quot;2e+1&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="x-toPrecision"><a href="#x-toPrecision" class="headerlink" title="x.toPrecision()"></a>x.toPrecision()</h2><p>表示的是 用几位数字来表示 注意这个时候不是几位小数 而是几位数字 他会自动选择科学计数法还是填0来进行输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">1</span>)); <span class="comment">// &quot;1e+2&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">2</span>)); <span class="comment">// &quot;99&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">3</span>)); <span class="comment">// &quot;99.0&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h2><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>顾名思义</p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>直接上代码  注意是将结果储存在另外一个变量 而不是把本身的变量进行修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.concat(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>当然可以有很多的参数</p>
<h2 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h2><h3 id="slice-substring-substr"><a href="#slice-substring-substr" class="headerlink" title="slice substring substr"></a>slice substring substr</h3><p>直接上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo worl&quot;</span></span><br><span class="line"><span class="comment">///////////////////</span></span><br><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">-3</span>)); <span class="comment">// &quot;rld&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意如果是一个参数 则是包括当前位置 如果是两个参数 左闭右开</p>
<h2 id="字符串搜索"><a href="#字符串搜索" class="headerlink" title="字符串搜索"></a>字符串搜索</h2><h3 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf() 和 lastIndexOf()"></a>indexOf() 和 lastIndexOf()</h3><p>这两个都接受一个字符串和一个数字 第一个代表target  第二个代表start 返回值顾名思义 如果找不到 则返回-1<br>注意 这个搜索的范围 包括start</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">&quot;e&quot;</span>, <span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h2 id="判断字符串包含"><a href="#判断字符串包含" class="headerlink" title="判断字符串包含"></a>判断字符串包含</h2><p>ES6 特有的  和正则表达式的效果相似</p>
<h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p>接受两个参数 一个是target  一个是开始搜索的位置 返回一个bool</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>, <span class="number">4</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="startsWidth"><a href="#startsWidth" class="headerlink" title="startsWidth"></a>startsWidth</h3><p>接受两个参数 一个target 一个开始搜索的位置 返回一个bool 注意 这个是从头往后搜索<br>很重要的一点是 是包含你传入第二个参数的字符的<br>**从传入第二个参数开始 包括第二个参数 是不是以tar为开头</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="endWidth"><a href="#endWidth" class="headerlink" title="endWidth"></a>endWidth</h3><p>接受两个参数 一个是target 一个是字符串结尾的位置 返回一个bool 开始的位置默认是 (string.length - substring.length)<br>**第二参数就是我们指定的字符串结尾的位置 如果传入pos  那么开始搜索的地方就是pos-substring.length  包括这个值 开始搜索substring.length个字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;baz&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="trim方法"><a href="#trim方法" class="headerlink" title="trim方法"></a>trim方法</h2><p>用于去除字符串的空格 trimRight和trimLeft 顾名思义<br>不会影响到原来字符串 需要新的内存空间进行保存</p>
<h2 id="repeat方法"><a href="#repeat方法" class="headerlink" title="repeat方法"></a>repeat方法</h2><p>直接上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;na &quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.repeat(<span class="number">16</span>) + <span class="string">&quot;batman&quot;</span>);</span><br><span class="line"><span class="comment">// na na na na na na na na na na na na na na na na batman</span></span><br></pre></td></tr></table></figure>
<h2 id="设置字符串长度并且自动填充"><a href="#设置字符串长度并且自动填充" class="headerlink" title="设置字符串长度并且自动填充"></a>设置字符串长度并且自动填充</h2><p>直接上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">6</span>)); <span class="comment">// &quot; foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;......foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">6</span>)); <span class="comment">// &quot;foo &quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;foo......&quot;</span></span><br><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;barbafoo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">2</span>)); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;foobarba&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">2</span>)); <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>
<p>tips:<br>toLocaleString 会根据当前的地区返回不同的值 而toString则不会  字符大小写也同样</p>
<h2 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h2><p> toLowerCase() 、 toLocaleLowerCase()<br> toUpperCase() 和 toLocaleUpperCase()</p>
<h2 id="Compare方法"><a href="#Compare方法" class="headerlink" title="Compare方法"></a>Compare方法</h2><p>localeCompare() 返回值如下面代码所示 这没有除去locale的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;brick&quot;</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;yellow&quot;</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;zoo&quot;</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<h1 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h1><p>global对象就是js的兜底的对象了 它里面有着我们熟悉的很多函数 比如说Number的构造函数等等 parseInt等等  其中我们需要注意的就是 eval() 这个函数可以在当前位置插入js代码 相当于C++的define 或者是include  文本插入<br>global对象其实真正的代理还是window对象  这个是在ECMAScript  window代理了global  但是在具体的js的对es的实现里面 window对象承载了更多的好用的属性</p>
<h1 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h1><p>这个对象也提供了很多的有用的方法 其中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...val);</span><br></pre></td></tr></table></figure>
<p>顾名思义<br> Math.ceil() 方法始终向上舍入为最接近的整数。<br> Math.floor() 方法始终向下舍入为最接近的整数。<br> Math.round() 方法执行四舍五入。<br> Math.fround() 方法返回数值最接近的单精度（32 位）浮点值表示。<br> Math.random() 返回[0,1)随机数<br>其中还有一些一般人想得到的比如正弦余弦 反三角函</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS变量 作用域和内存</title>
    <url>/2020/11/10/JS%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>这里涉及到JS 比较底层的原理 和C++比较不一样 C++是声明变量 指定类型并且分配内存空间 JS内存空间内部实现 并没有在外面实现 C++的指针在JS里面也是隐藏的存在 但是也有相关的原理</p>
<h1 id="原始值和引用值"><a href="#原始值和引用值" class="headerlink" title="原始值和引用值"></a>原始值和引用值</h1><p>原始值就是JS的六种剧本数据类型  他们是储存在变量的内存空间里面的 而引用值 对象 储存的是指针  指针指向了保存在堆栈里面的内存空间 JS是不允许直接访问堆栈的内存的 按引用访问其实就是只能使用变量里面储存的指针进行访问 而不是 let a=0xa848ef<br>*a=10 这一种</p>
<h1 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h1><p>原始值的复制  理论上来说就是深拷贝 在新的变量开辟的内存空间里面 填入被复制的值 这个时候这两个变量就是相互独立的<br>但是如果是引用变量 那么复制的时候就是复制指针 相当于浅拷贝 对指针指向的内存地址空间的值也会产生影响</p>
<h1 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h1><p>JS和C++不同 所有的参数都是值传递 相当于在函数的arguments数组里面 一个萝卜一个坑 然后进行上面说的变量的复制  如果是原始值 那么就是两个相互独立的  如果是引用值  那么就是指针地址的复制 令这个argument指向另外一个新的object并不会改变外面指针的值</p>
<h1 id="确定类型"><a href="#确定类型" class="headerlink" title="确定类型"></a>确定类型</h1><p>typeof是用来确定原始值的 但是这个对object用处就不是很大了 这个时候 instanceof就出现了他的作用了<br>instanceof也是一个操作符 他会在原型链里面去找是不是有这个原型</p>
<h1 id="执行上下文和作用域"><a href="#执行上下文和作用域" class="headerlink" title="执行上下文和作用域"></a>执行上下文和作用域</h1><h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>上下文就是当前语句执行的上下文 和语文的上下文相似</p>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>变量对象就是当前的上下文储存所有变量的对象 最顶级的上下文就是全局上下文 里面储存变量的对象就是window对象 所以说var会在window对象里面注册属性<br>在函数里面 那就是新的上下文 他的变量对象最初只有函数的arguments</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链就是变量对象的一个链 你所需要的函数或者是变量会顺链查找 当前上下文永远在最前面</p>
<p>要是未声明就对变量直接进行赋值不会和let一样进行报错（不使用）let  这样这个变量就会注册在全局 而不是当前上下文</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">sum = num1 + num2;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">sum = num1 + num2;</span><br><span class="line"><span class="keyword">let</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 30</span></span><br><span class="line"><span class="comment">//Uncaught ReferenceError: Cannot access &#x27;sum&#x27; before initialization</span></span><br></pre></td></tr></table></figure>

<p>tips : let 和 const  都是ES6的</p>
<h1 id="CONST修饰符"><a href="#CONST修饰符" class="headerlink" title="CONST修饰符"></a>CONST修饰符</h1><p>const意思是 变量不能重新被赋值 但是按照上文说的 如果一个变量是object  比如 const a={  } 那么就是这个a不能指向其他的变量 但是这个变量里面的属性是可以更改的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;;</span><br><span class="line">o1 = &#123;&#125;; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;;</span><br><span class="line">o2.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o2.name); <span class="comment">// &#x27;Jake&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果要整个变量都不能修改的话 可以使用Object对象的一种构造函数 freeze 冻结</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o3 = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">o3.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o3.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>注意结果是undefined哦</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="*垃圾回收"></a>*垃圾回收</h1><p>JS的垃圾回收机制有两种 一种是标记清理  一种是引用计数 一种是标记清理  </p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>JS会维护一个引用的表 对每一个值都记录了被引用的次数 当这个次数为0的时候 当然可以回收 但是这个引用计数的问题就是 当变量进行套娃引用的时候 就会造成内存泄漏 因为这个时候 两个对象的引用次数都是2</p>
<h2 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h2><p>会标记当前的  正在使用的变量 然后清除没有使用的变量</p>
<h1 id="通过优化垃圾回收-和避免内存泄漏进行性能优化"><a href="#通过优化垃圾回收-和避免内存泄漏进行性能优化" class="headerlink" title="通过优化垃圾回收 和避免内存泄漏进行性能优化"></a>通过优化垃圾回收 和避免内存泄漏进行性能优化</h1><h2 id="尽可能使用const和let"><a href="#尽可能使用const和let" class="headerlink" title="尽可能使用const和let"></a>尽可能使用const和let</h2><p>因为const 和 let 的作用域都是块作用域 这样的话就不会导致注册在全局 会容易被内存清理发现</p>
<h2 id="尽可能解除引用"><a href="#尽可能解除引用" class="headerlink" title="尽可能解除引用"></a>尽可能解除引用</h2><p>解除引用之后 在堆内存里面的内存空间就可以被释放 这样也可以避免内存泄漏</p>
<h2 id="隐藏类"><a href="#隐藏类" class="headerlink" title="*隐藏类"></a>*隐藏类</h2><p>隐藏类 就是两个对象的属性的名字和个数具有相同的值 这样的话 便于JS去追踪这个隐藏类的实例 在对对象进行操作的时候 尽量不要在外面临时进行属性个数的添加和删除 对于不需要的属性可以使用null指针进行解除引用 这样 隐藏类还是共享 还是可以追踪。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>JavaScript 变量可以保存两种类型的值：原始值和引用值。原始值可能是以下 6 种原始数据类型之<br>一： Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。原始值和引用值有以下特点。<br> 原始值大小固定，因此保存在栈内存上。<br> 从一个变量到另一个变量复制原始值会创建该值的第二个副本。<br> 引用值是对象，存储在堆内存上。<br> 包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。<br> 从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。<br> typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。<br>任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个<br>上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结<br>如下。<br> 执行上下文分全局上下文、函数上下文和块级上下文。<br> 代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。<br> 函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃<br>至全局上下文中的变量。<br> 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。<br> 变量的执行上下文用于确定什么时候释放内存。<br>JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript 的垃圾回收<br>程序可以总结如下。<br> 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。<br> 主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。<br> 引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript 引擎不再使用这种算<br>法，但某些旧版本的 IE 仍然会受这种算法的影响，原因是 JavaScript 会访问非原生 JavaScript 对<br>象（如 DOM 元素）。<br> 引用计数在代码中存在循环引用时会出现问题。<br> 解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对<br>象、全局对象的属性和循环引用都应该在不需要时解除引用</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的语句</title>
    <url>/2020/11/09/JS%E7%9A%84%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="for-in语句"><a href="#for-in语句" class="headerlink" title="for-in语句"></a>for-in语句</h1><p>for-in 语句是把一个对象的所有键值都打出来 比如说</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    x:<span class="number">132</span>,</span><br><span class="line">    y:<span class="number">777</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> a) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(propName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x  y</span></span><br></pre></td></tr></table></figure>
<p>这个键值是无序的 根据浏览器而定  所以不知道哪一个先被打印出来</p>
<h1 id="for-of语句"><a href="#for-of语句" class="headerlink" title="for-of语句"></a>for-of语句</h1><p>适用于迭代一个可以遍历的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]) &#123;</span><br><span class="line"><span class="built_in">document</span>.write(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 这里的const和上面一样不是必须的 但是可以确保迭代的时候不会修改</p>
<h1 id="标签语句和循环嵌套的使用"><a href="#标签语句和循环嵌套的使用" class="headerlink" title="标签语句和循环嵌套的使用"></a>标签语句和循环嵌套的使用</h1><p>直接上例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">break</span> outermost;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>
<p>这里的 break当然可以换成continue</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript从入门到入土-历史</title>
    <url>/2020/11/04/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</url>
    <content><![CDATA[<h1 id="什么是JS"><a href="#什么是JS" class="headerlink" title="什么是JS"></a>什么是JS</h1><h2 id="Javascript和ECMAScript之间的关系"><a href="#Javascript和ECMAScript之间的关系" class="headerlink" title="Javascript和ECMAScript之间的关系"></a>Javascript和ECMAScript之间的关系</h2><p>js一开始是网景公司一开始准备发布服务器语言的时候写的一个脚本语言 后来改名为Lvescript 当时为了跟上JAVA的顺风车 改了个名 实际上和java没有关系<br><br><br>js一开始很成功  于是微软也来插一脚 名字叫Jscript 你说气不气 就是为了不跟你搞名字纠纷 因为微软在业界的响应力 js出现两个版本 一个是创始版本  一个是微软版本。这个时候 国际规范化组织就坐不住了 特别是ECMA （欧洲计算机制造商协会） 他们就牵头找了一批委员 打造出js的标准 也就是ECMAScript 后面国际化组织ISO和IEC同时将ECMAScript采纳标准</p>
<p>虽然JavaScript和ECMAScript基本上是同义词，但JavaScript远远不限于ECMA-262所定义的那样。<br>没错，完整的 JavaScript 实现包含以下几个部分</p>
<p> 核心（ECMAScript）<br> 文档对象模型（DOM）<br> 浏览器对象模型（BOM）</p>
<p>我们平常所说的ES5 ES6就是ECMAScript的若干个版本，其中ES6  又称之为ES2015 是15年发布的修订版 正式支持了类 模块 迭代器 生成器  箭头函数 期约 反射 代理和众多新的数据类型。</p>
<h2 id="DOM-Document-Objeci-Model-文档对象模型"><a href="#DOM-Document-Objeci-Model-文档对象模型" class="headerlink" title="DOM Document Objeci Model 文档对象模型"></a>DOM Document Objeci Model 文档对象模型</h2><p>文档对象模型（DOM，Document Object Model）是一个应用编程接口（API），用于在 HTML 中使<br>用扩展的 XML。DOM 将整个页面抽象为一组分层节点。HTML 或 XML 页面的每个组成部分都是一种<br>节点，包含不同的数据 但是这个时候DOM每个浏览器都有着自己的想法 这就让开发人员头疼 一个HTML界面 在不同浏览器的工作效果是不一样的 这个时候W3C 又来制定标准啦万维网联盟（W3C，World Wide Web<br>Consortium）</p>
<h2 id="BOM浏览器对象模型"><a href="#BOM浏览器对象模型" class="headerlink" title="BOM浏览器对象模型"></a>BOM浏览器对象模型</h2><p>总体来说，BOM 主要针对浏览器窗口和子窗口（frame），不过人们通常会把任何特定于浏览器的<br>扩展都归在 BOM的范畴内。比如，下面就是这样一些扩展：<br> 弹出新浏览器窗口的能力；<br> 移动、缩放和关闭浏览器窗口的能力；<br> navigator 对象，提供关于浏览器的详尽信息；<br> location 对象，提供浏览器加载页面的详尽信息；<br> screen 对象，提供关于用户屏幕分辨率的详尽信息；<br> performance 对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；<br> 对 cookie 的支持；<br> 其他自定义对象，如 XMLHttpRequest 和 IE 的 ActiveXObject</p>
<h2 id="第一篇JS记录-小结一下"><a href="#第一篇JS记录-小结一下" class="headerlink" title="第一篇JS记录 小结一下"></a>第一篇JS记录 小结一下</h2><p>JavaScript 是一门用来与网页交互的脚本语言，包含以下三个组成部分。<br> ECMAScript：由 ECMA-262 定义并提供核心功能。<br> 文档对象模型（DOM）：提供与网页内容交互的方法和接口。<br> 浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。</p>
<h2 id="HTML中的JS-嵌入问题以及用法"><a href="#HTML中的JS-嵌入问题以及用法" class="headerlink" title="HTML中的JS 嵌入问题以及用法"></a>HTML中的JS 嵌入问题以及用法</h2><p>将 JavaScript 插入 HTML 的主要方法是使用 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> async ：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其<br>他脚本加载。只对外部脚本文件有效。<br> charset ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不<br>在乎它的值。<br> crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。 crossorigin=<br>“anonymous” 配置文件请求不必设置凭据标志。 crossorigin=”use-credentials” 设置凭据<br>标志，意味着出站请求会包含凭据。<br> defer ：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。<br>在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。<br> integrity ：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，<br>Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，<br>脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提<br>供恶意内容。</p>
<h3 id="crossorigin属性"><a href="#crossorigin属性" class="headerlink" title="crossorigin属性"></a>crossorigin属性</h3><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>如果两个页面的协议，端口和域名都相同，则两个页面具有相同的源（origin）。<br>同源策略是一种安全机制，它限制了非同源脚本之间的交互方式。<br>例如，在使用XMLHttpRequest或 <img> 标签时，会受到同源策略的约束。</p>
<h4 id="跨域资源共享-CORS"><a href="#跨域资源共享-CORS" class="headerlink" title="跨域资源共享 CORS"></a>跨域资源共享 CORS</h4><p>跨域资源共享 Cross-Origin Resource Sharing (CORS)，通过在服务器端设置 Access-Control-Allow-Origin 响应头，也就是在服务端  通过给资源加上响应header  指定允许域名访问当前资源 也可以设置* 任意资源<br>但是如果服务端没有加上Access-Control-Allow-Origin 但是本地还是使用的crossorigin属性 那么就会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access to Script at <span class="string">&#x27;http://127.0.0.1:8081/index.js&#x27;</span> <span class="keyword">from</span> origin <span class="string">&#x27;http://127.0.0.1:8080&#x27;</span> has been blocked by CORS policy: </span><br><span class="line">No <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> header is present on the requested resource. </span><br><span class="line">Origin <span class="string">&#x27;http://127.0.0.1:8080&#x27;</span> is therefore not allowed access.</span><br></pre></td></tr></table></figure>
<br>
参考: <a href="https://www.jianshu.com/p/a45c9d089c93">script的crossorigin属性</a>
<br>
这个时候添加crossorigin属性可以让浏览器获得更多的error信息 （如果是error 而且服务器添加了响应头Access-Control-Allow-Origin 的情况下） 否则只有简单的 error信息 看不到详细日志

<h3 id="defer和async属性"><a href="#defer和async属性" class="headerlink" title="defer和async属性"></a>defer和async属性</h3><p>defer<br>就是延时加载 告诉浏览器 立即加载 但是要延迟执行 他是在loaded事件执行之前 但是在现实生活中 执行顺序也是不一定的 所以应该只使用一个defer标签</p>
<p>anync<br>就是异步加载 告诉浏览器 下载之后立即执行 但是 因为是异步执行 所以两个文件开始加载的顺序假如是一前一后 但是执行的顺序可能是 后面的文件先下载好 执行之后 前面的文件再完成下载进行执行  所以这个时候如果两个文件有依赖性 那么就会出现问题</p>
<p><br>下面来一些非常直观的图</br></p>
<img src="/2020/11/04/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/defer.png" class="">
<img src="/2020/11/04/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/async.png" class="">
<p>参考： <a href="https://www.cnblogs.com/jiasm/p/7683930.html">浅谈defer和async</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>也就是说 在一般情况下 浏览器会默认顺序去解析html文档 解析到script  会等他加载并且执行完毕 继续进行文档解析  这个时候加上async  就是告诉浏览器 你可以先不管他 交给后<br>台去加载 你先解析着你的文档 然后我这里解析好了 就告诉你一声（promise）然后你就可以来执行我的脚本啦<br>defer就是告诉浏览器 别管 碰到我就继续解析文档 </p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Java数据类型Symbol</title>
    <url>/2020/11/09/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BSymbol/</url>
    <content><![CDATA[<p>js独特的数据类型Symbol 期间先介绍一下string类型的使用 然后开始正式介绍Symbol</p>
<h1 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h1><p>String 有几个比较常见的spilce函数等等<br>常用的转义字符和C++的一样 但是如果你要原封不动的输出转义字符的话 有一个标签函数 类似于修饰器的函数可以进行修饰 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line\nsecond line`</span>); <span class="comment">// &quot;first line\nsecond line&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>js原生的 基础数据类型有6种<br>undefined   null    number  string  boolean     symbol<br>其中symbol是ES6 也就是js第六版加进去的 </p>
<h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>就是对变量进行声明 但是还没有进行初始化赋值 比如说</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>永远不要给一个变量手动赋值为undefined 不然的话你就不知道究竟这个undefined是因为忘记进行初始化还是别的什么原因 这个undefined一般是用来检测自己是不是忘记对变量进行初始化的</p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>基础数据类型里面没有object  他是一个复杂数据类型 null代表的是一个空对象指针  在定义一个将要保存一个object的变量的时候 可以对他赋值null 表示这个变量我是要赋值一个object 但是我还没干 一边和undefined进行区分 null是一个对象 对他进行typeof运算会得到object 要注意</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="literal">undefined</span>);  <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="literal">null</span>);  <span class="comment">//object</span></span><br></pre></td></tr></table></figure>
<p>这个是特殊的</p>
<h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><p>这个是一个运算符而不是一个函数 它具有下列的输出<br>number string   undefined  function    symbol  boolean     obejct<br>相比于基础数据类型 （6个）<br>多了一个function  将null换成了object  因为我们知道typeof(null) 会输出object</p>
<h1 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h1><p>下面开始探讨symbol这个新的数据类型 因为也是第一次接触 慢慢摸索<br>symbol相当于一个符号  是对对象属性的唯一标识符  不会发生冲突的危险 相当于trackBy 的 agentId 每一个symbol都是唯一的  但是symbol的描述可以是相同的  比如说我有两个标签 一个是1号 一个是2号  我描述1号是一支笔 2号是一支笔 标签的描述是相同的 但是标签的序号本身还是不同的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fooSymbol == otherFooSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是  symbol是不能通过new运算符进行操作的 不能和其他基本数据类型一样  成为一个包装对象<br>意思就是说 new运算符 可以将基础数据类型变成一个object  这个时候进行typeof当然是object</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myBoolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myBoolean); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> myString = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myString); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> myNumber = <span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myNumber); <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>具体符号是用来标识一个对象的 但是如果很多对象需要使用相同的symbol  那么需要在全局符号注册一个</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 创建新符号</span></span><br><span class="line"><span class="keyword">let</span> otherFooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 重用已有符号</span></span><br><span class="line"><span class="built_in">console</span>.log(fooGlobalSymbol === otherFooGlobalSymbol); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。 这个登记指的是在全局进行登记</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>符号可以作为对象的属性 用来标识每一个对象 比如说</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>),</span><br><span class="line">s3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>),</span><br><span class="line">s4 = <span class="built_in">Symbol</span>(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">[s1]: <span class="string">&#x27;foo val&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的方括号就是用现有变量作为属性的标识<br>同样地 也可以使用Object的方法 对对象进行属性的赋值<br>symbol 还可以用于定义一整组常量 保证这一些常量都是不相等的  如果要辨别这一些常量的话 symbol是一个很好地选择 比如说是switch 同时还可以消除魔术字符串和常量</p>
<h3 id="symbol属性的遍历"><a href="#symbol属性的遍历" class="headerlink" title="symbol属性的遍历"></a>symbol属性的遍历</h3><p>如果symbol作为一个对象的属性的名字的话 那么for-in 循环是不能进行输出的 而且 Object.getOwnPropertyNames() 方法也得不到这个键的名字  必须是Object.getOwnPropertySymbols() 或者是 Reflect.ownKeys()    后者可以返回所有类型的键名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;my_key&#x27;</span>)]: <span class="number">1</span>,</span><br><span class="line">  enum: <span class="number">2</span>,</span><br><span class="line">  nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</span><br><span class="line"><span class="comment">//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</span></span><br></pre></td></tr></table></figure>
<h2 id="ES9-内置的symbol"><a href="#ES9-内置的symbol" class="headerlink" title="ES9 内置的symbol"></a>ES9 内置的symbol</h2><p>以后再说</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>互联网协议入门</title>
    <url>/2020/12/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="互联网协议"><a href="#互联网协议" class="headerlink" title="互联网协议"></a>互联网协议</h1><p>今天体侧+打球 没写算法题 总结一下互联网协议安慰一下自己<br>互联网协议分为很多层 我们先讲互联网的五层模型 里面的一些细节可以再分 分为七层 我们先讲五层 互联网的层级 每一层负责不同的通讯 他们的好处就是 层与层之间可以互不干扰的进行运转 这也是计算机自顶向下的一种封装吧 每一个层专注于自己的事 然后暴露好接口 上面的层只管调用这种接口就行啦</p>
<img src="/2020/12/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/wuceng.png" class="" title="This is an example image">

<h2 id="实体层和链接层"><a href="#实体层和链接层" class="headerlink" title="实体层和链接层"></a>实体层和链接层</h2><p>链接层实际上就是网卡之间的通信 通过找寻到 mac 地址 然后进行数据的传输 那么我们一般是通过 DNS 解析器 知道了目标主机的 ip 地址 但是我们实体层的传输是需要 mac 地址的 我们怎么知道 mac 地址呢<br>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的 MAC 地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p>
<p>第二种情况，如果两台主机在同一个子网络，那么我们可以用 ARP 协议，得到对方的 MAC 地址。ARP 协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的 IP 地址，在对方的 MAC 地址这一栏，填的是 FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出 IP 地址，与自身的 IP 地址进行比较。如果两者相同，都做出回复，向对方报告自己的 MAC 地址，否则就丢弃这个包。</p>
<p>总之，有了 ARP 协议之后，我们就可以得到同一个子网络内的主机 MAC 地址，可以把数据包发送到任意一台主机之上了。</p>
<p>到目前为止 我们解决了任意两台机器的传输问题 我们首先会看这个以太网的头 然后判断这个 ip 地址是不是属于同一个子网（利用子网掩码） 这个时候我们是不知道这个目的地的 mac 地址的 我们只能通过 ip 地址知道目前是在一个子网 现在我们要获取 mac 地址才能通讯啊 怎么获取呢 通过我们的 ARP 协议 上面提到过啦 要是不在同一个子网 那就直接发给网关 网关通过路由之类的 传输到目的地的子网 然后目的地的子网 嗯 这个时候通过子网掩码 就知道这个目的地是同一个子网啦 然后再通过 ARP 协议 获取 mac 地址 然后再进行通讯</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>我们现在的通讯 是通过 mac 地址进行两个机子的通讯 上文提到了 ip 和网关 这实际上是网络层之间的关系 上面的连接层和实体层更多的是在子网络 比如一个计算机机房 但是如果是上海的机子和广州的机子 那怎么办咧</p>
<p>必须找到一种方法，能够区分哪些 MAC 地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC 地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p>
<p>那么不同子网之间怎么进行连接呢 这个时候 我们就约定了一个地址 和一个 ip 协议 通过这个协议我们就可以在不同的子网之间进行通讯<br>ip 分为 v4 和 v6 代表着不同的协议 这里我们讲 v4 我们的 ip 层 ip 可以指定相对应的主机 不仅仅是 mac mac 只是在实体层进行数据传输 但是 ip 也可以确定是哪一个主机 在网络层我们在数据包里面再封装一个 ip 层的数据头 包含了目标 ip 和源 ip<br>在网络层 我们的主机会用子网掩码 判断是不是在当前子网 如果是 那就直接用 ARP 找到 mac 然后进行实体层的传输 如果不是 那么目的的 mac 就是网关 网关拿到这个 ip 然后查路由表 然后给其他路由 其他路由再拿到这个包 对比子网掩码 嗯 就是我这个子网 然后查 ip 的 mac 这样就实现了不同子网之间的交流 这个时候 两个子网的包的数据层的目的的 mac 都是网关的 mac 网关收不到目的 mac 因为根本不知道 mac 只会收到 ip 但是 mac 又是必须的 就拿着 ip 去找 mac 嗯</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>我们现在实现了 在子网里面 用 mac 进行数据的传输 也就是链接层和实体层 然后我们在网络层 利用 ip 和子网掩码 和网关 路由 实现了不同子网之间的交流 那么现在 我们不可能两个机子 就只有一个链接吧 比如我们的服务器 同时要和好几个人链接 这个时候 一个机子有端口这个概念 也就是我们的传输层</p>
<p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p>
<p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>“端口”是 0 到 65535 之间的一个整数，正好 16 个二进制位。0 到 1023 的端口被系统占用，用户只能选用大于 1023 的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>
<p>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix 系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p>
<p>这里面也涉及到了面试题 就是我们的有一些自留端口 究竟是干啥的 嗯</p>
<p>有层 当然有协议 UDP 和 TCP 就是在这里面的 这个是重点面试题 单独开一篇<br>这个协议指定了当前的这个应用 使用的是哪一个端口 这个端口出来的和进去的都是这个应用的 这样就不会直接给歪来 具体参考头的套娃</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层就是形形色色的协议的 我们需要知道的就是http和https协议啦 这里直接放上套娃图 然后下一篇讲一下我们的这个套娃图是怎么套娃和解套娃 然后讲一下TCP和UDP</p>
<img src="/2020/12/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/head.png" class="" title="This is an example image">]]></content>
  </entry>
  <entry>
    <title>剑指offer</title>
    <url>/2020/11/09/%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<h2 id="在面试的时候写代码必须要考虑边界值-特殊的输入-而不是一股脑的就开始写答案-面试官会更加考虑你的边界判断能力-以及脏输入-以及代码调试能力"><a href="#在面试的时候写代码必须要考虑边界值-特殊的输入-而不是一股脑的就开始写答案-面试官会更加考虑你的边界判断能力-以及脏输入-以及代码调试能力" class="headerlink" title="在面试的时候写代码必须要考虑边界值 特殊的输入 而不是一股脑的就开始写答案 面试官会更加考虑你的边界判断能力 以及脏输入 以及代码调试能力"></a>在面试的时候写代码必须要考虑边界值 特殊的输入 而不是一股脑的就开始写答案 面试官会更加考虑你的边界判断能力 以及脏输入 以及代码调试能力</h2><h2 id="在介绍项目经历的时候-要表现出自己的合作精神-沟通能力-以及自己良好的学习能力"><a href="#在介绍项目经历的时候-要表现出自己的合作精神-沟通能力-以及自己良好的学习能力" class="headerlink" title="在介绍项目经历的时候 要表现出自己的合作精神  沟通能力 以及自己良好的学习能力"></a>在介绍项目经历的时候 要表现出自己的合作精神  沟通能力 以及自己良好的学习能力</h2><h3 id="查找数组里面重复的元素"><a href="#查找数组里面重复的元素" class="headerlink" title="查找数组里面重复的元素"></a>查找数组里面重复的元素</h3><p>如果没有加以限制的话 那么就是傻逼题 如果是加以限制 比如鸽笼原理<br>在大小为n的数组里面放n+1个数字 那么必须至少两个数字是相同的 下面考虑 时间O(n) 空间O(1)的算法<br>如果是鸽笼原理 那么一个萝卜一个坑 顺序遍历数组 那么当前元素是a[i] 如果不是i 而是 k  那么就看看 a[k] 如果一样 那就找到 如果不一样那就交换 a[k] a[i] 让这个a[i] 回到自己的坑a[k] 的位置上 </p>
<p>如果要求不能改变数组 emmm  那就是 比如说在n+1空间里面放范围n的数字 那么肯定有重复的 那么就是  每一次扫描n+1空间里面所有的数字  然后将数字范围分为前后两个部分 看看前后两个部分的数字在n+1的空间里面出现了多少次 如果出现的比自己的范围大 那么就是在这个范围里面 类似于二分查找 再继续分 时间复杂度O(nlogn)</p>
]]></content>
  </entry>
  <entry>
    <title>探索底层-变量和函数的生命周期详解</title>
    <url>/2020/11/05/%E6%8E%A2%E7%B4%A2%E5%BA%95%E5%B1%82-%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>从红宝书里面看到var 和let变量 突然好奇他们的生命周期和我们常学的C和C++有什么区别  查找了网上博客 现在进行总结</p>
<h1 id="变量和函数的生命周期基本过程"><a href="#变量和函数的生命周期基本过程" class="headerlink" title="变量和函数的生命周期基本过程"></a>变量和函数的生命周期基本过程</h1><p>当引擎访问变量的时候，它们的生命周期包括下面几个阶段：</p>
<p>1.声明阶段：在作用域中注册一个变量<br>2.初始化阶段：分配内存，给作用域中的变量创建绑定。在这个阶段，变量自动地被初始化为undefined<br>3.赋值阶段：给已经初始化过的变量赋值<br>声明变量就是告诉js解释器 我现在这个名字就是个变量 但是这个时候还没初始化  对这个名字进行访问是报错的<br>初始化阶段之后就可以对这个变量进行访问了 这个时候分配了undefined 但是还是可以访问<br>赋值阶段 就是字面意思 把undefined 变成赋值的值</p>
<h1 id="var变量的生命周期"><a href="#var变量的生命周期" class="headerlink" title="var变量的生命周期"></a>var变量的生命周期</h1><p>var变量的作用域是函数作用域 而不是块作用域 我们常见的C++ 就是块作用域 在一个函数里面所有的var  都会被一个叫（变量提升） 的 在函数作用域的开始阶段 所有的 不论是在哪里写的var 变量都会在作用域头进行声明和初始化 这个时候是undefined  经历了初始化 意味着可以访问 于是有了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>输出undefined 和预想一样</p>
<h1 id="let变量的生命周期"><a href="#let变量的生命周期" class="headerlink" title="let变量的生命周期"></a>let变量的生命周期</h1><p>let变量就是把声明和初始化解耦合了 同时 let的作用域是块作用域 所以在块作用域的开头 let 变量还是会进行声明  注意是声明 这个时候只有这个名字 但是没分配内存 这个时候的变量 被储存在称之为暂时性死区的地方 连undefined都不是 所以这个时候进行访问就会出错 当解释到 let a的时候 开始进行初始化为undefined 或者进行赋值 let a =10； 变量退出暂时性死区 下面是例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// console.log(number); // =&gt; Throws ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> number;</span><br><span class="line"><span class="built_in">console</span>.log(number); <span class="comment">// =&gt; undefined</span></span><br><span class="line">number = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number); <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure>
<p>输出 error 第二个输出5 和预期一样</p>
<h1 id="函数的生命周期"><a href="#函数的生命周期" class="headerlink" title="函数的生命周期"></a>函数的生命周期</h1><p>函数在js里面 我理解也是一种变量 函数的声明 初始化 赋值 不论写在在父函数作用域的任何位置 都会被提升到一开始  所以任何时候都可以访问 就算是写在return 之后的函数 一个典型例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumArray</span>(<span class="params">array</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> array.reduce(sum);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不会报错 进行正常输出</p>
<h1 id="var-和let的其他区别"><a href="#var-和let的其他区别" class="headerlink" title="var 和let的其他区别"></a>var 和let的其他区别</h1><ol>
<li>var的全局声明 会成为window对象的属性 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// &#x27;Matt&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>for循环括号里面的变量的问题 如果是let变量 那么循环体里面传的都是当前 变量的一个副本 而不是 和var一样是当前变量 典型例子<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 你可能以为会输出 0、1、2、3、4</span></span><br><span class="line"><span class="comment">// 实际上会输出 5、5、5、5、5</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会输出 0、1、2、3、4</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>let 和 var  就是在各自的作用域进行了 声明和初始化的解耦合 理解这两个概念很重要<br>参考 <a href="https://blog.csdn.net/mike_chen2stockings/article/details/79577062">生命周期</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法-栈之Leetcode</title>
    <url>/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/</url>
    <content><![CDATA[<h1 id="最近做了几题关于栈的-然后也是关于求矩形最大面积的"><a href="#最近做了几题关于栈的-然后也是关于求矩形最大面积的" class="headerlink" title="最近做了几题关于栈的  然后也是关于求矩形最大面积的"></a>最近做了几题关于栈的  然后也是关于求矩形最大面积的</h1><p>这里面涉及到一些类似于动态规划的意思  比如说单调栈 就是用前面的结果可以用于后面  这里面也有涉及 动态规划算是比较难想到的一类算法题吧 然后下面会总结一下算法的思路 下一次遇到算法题就知道大致的思路了</p>
<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>直接上图</p>
<img src="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/rain.png" class="" title="This is an example image">
<p>这里面我们的思路就是  首先我们肯定是要遍历这个柱子的高度的 毋庸置疑<br>这个时候 我们要确定的是 我们什么时候就可以确定已经遍历的柱子可以接雨水了？<br>接了多少雨水？  我们是一次性计算出全部还是分布计算？<br>首先肯定是一部分计算 因为一般这种题  如果不是求最大 或者是最小 一般来说遍历一次我们就可以直接得出答案 那么什么时候开始计算接了多少雨水呢？<br>一个碗  左边高 右边低  根据木桶效应  遍历到右边的时候 我们才知道可以接到多少水<br>在计算多少水的时候 我们需要知道已经遍历的里面的水量  我们只需要知道最近的 几根柱子 所以根据栈的先进先出就可以知道<br>直接上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (pos.empty()&amp;&amp;height[i]==<span class="number">0</span>)</span><br><span class="line">      &#123; <span class="comment">//如果空 那就push进去 然后下一个儿</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (!pos.empty() &amp;&amp; height[i] &gt; height[pos.top()])</span><br><span class="line">      &#123;                      <span class="comment">//不空 而且比栈顶大 就说明 现在构成了一个碗  但是这个碗可能只有右边</span></span><br><span class="line">        <span class="keyword">int</span> top = pos.top(); <span class="comment">//保存当前讨论的那个柱子的位置 因为我们要访问前面的柱子 也就事我们要计算 当前这个一格宽的碗底 的水的高度</span></span><br><span class="line">        pos.pop();<span class="comment">//看左边碗底 如果是左边没有我碗底 那就无</span></span><br><span class="line">        <span class="keyword">if</span> (pos.empty())</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">//如果这个时候已经是空的 那么就五</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> realHeight = min(height[i], height[pos.top()]);<span class="comment">//看一下这个碗真正的高度  是左边碗墙和右边碗墙 i是当前比碗底高的右边碗墙  碗底被pop了 top就是左边碗墙</span></span><br><span class="line">        <span class="keyword">int</span> dis = i - pos.top() - <span class="number">1</span>;</span><br><span class="line">        ans += dis * (realHeight - height[top]);</span><br><span class="line">      &#125;</span><br><span class="line">      pos.push(i); <span class="comment">//进去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这一道题的突破口就是 我们计算水量的时候 计算的方法是 分块计算 每一次计算都是矩形  因为计算机最喜欢公式 如果是什么奇奇怪怪的俄罗斯方块 那当然不行  每一次都是矩形 宽度自然是坐标偏移量 高度就是我们的碗的左右高度的最小值减去碗底的高度  这样一来就可以实现啦<br>至于为什么使用栈 很多人都想不到 栈的特性就是先进先出  我们可以保存数据  然后很方便访问到最近的数据  我们的碗  当发现比碗底高 知道是右边碗墙  我们就需要访问左边碗墙 左边碗墙刚好是最近的数据 方便访问  访问完之后直接出栈  之前保留的数据又可以暴露  nice</p>
<h2 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a>最大矩形</h2><p>这里的最大矩形指的是  直接上图吧hhh</p>
<img src="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/zhuzhuangtu.png" class="" title="This is an example image">
<p>因为是求最大的矩形  我们粗略的想一想 有很多种可能  可能是高度很矮  但是很多个柱子组成  可能是高度很高  一柱擎天  但是不管怎么样 计算机最喜欢的就是公式 矩形的公式就是长和宽 首先有没有办法直接遍历一次就找到？ 好像没有 因为我们不知道后面矩形的情况<br>暴力法 直接枚举每一个高度  找到这个高度的最大的宽度  然后就知道当前高度的矩形的最大值 但是枚举的时候有没有更好的办法  我们找矩形的时候 要找到最左边的地方和最右边的地方<br>如果一个柱子比当前枚举的高度要大  那么就不是当前柱子的边界 那么是不是也不可能是后面柱子的边界呢？  当前柱子代表了我是之前最小的  那么就会直接把结果挡住 嗯 这里后面的计算边界就可以借鉴前面的结果 On 就能解决<br>维护一个单调栈  为什么是单调栈？？ 这是因为 我们要知道离当前枚举的高度 最近的状态 那么就是栈  然后看最近的状态 如果比老子大  那么就不是我的边界  出栈！ 下一个  一直从铜锣湾杀到尖沙咀 就知道边界了 如果杀光了 那么边界就是最左边0了</p>
<h3 id="举个例子-比如图上的"><a href="#举个例子-比如图上的" class="headerlink" title="举个例子 比如图上的"></a>举个例子 比如图上的</h3><p>2   1   5   6   2   3<br>2入栈  他的左边是-1<br>1入栈的时候 看到2  嗯？ 比老子大！ 爬 2出栈 当前栈空 左边界是0<br>1入栈<br>5入栈的时候 看到1 嗯 比我小  留着吧  结果是5和1  不可能会访问到2  因为1已经挡住了 2的价值就不在了 就可以节省时间和空间  当前栈内 1  5<br>6入栈和5相同 直接入栈  1 5 6<br>2入栈  干掉5  6  得到1  站内  1 2  很容易知道结果的正确性</p>
<p>On求出所有左边界 On求出右 再 On求出每一个的值 维护一个最大ans<br>上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heights)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights.empty())        <span class="comment">//检测异常 面试必备</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; leftPos;     <span class="comment">//左边的单调栈</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; rightPos;</span><br><span class="line">        <span class="keyword">int</span> left[heights.size()];   <span class="comment">//储存左边界</span></span><br><span class="line">        <span class="keyword">int</span> right[heights.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!leftPos.empty() &amp;&amp; heights[leftPos.top()] &gt;= heights[i])<span class="comment">//如果比老子大就给爷爬 而且当然不能事空的</span></span><br><span class="line">            &#123;</span><br><span class="line">                leftPos.pop();  <span class="comment">//爬</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftPos.empty())    <span class="comment">//如果已经是空的 证明穿了  直接给最左边的赋值  这里的-1 魔法数字~</span></span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = leftPos.top();            <span class="comment">//碰到比我小的 当我小弟留着</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            leftPos.push(i);    <span class="comment">//统一入栈  因为要访问最近的情况 符合栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heights.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//大同小异</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!rightPos.empty() &amp;&amp; heights[rightPos.top()] &gt;= heights[i])</span><br><span class="line">            &#123;</span><br><span class="line">                rightPos.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightPos.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = heights.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = rightPos.top();</span><br><span class="line">            &#125;</span><br><span class="line">            rightPos.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;        <span class="comment">//在这里我们得到了左边界和右边界  这里的 -1 和 size两个魔法数字就体现了 嗯 这个-1也是魔法数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = max(ans, heights[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总体来说 这题的思维方式就是 如果用人的想法去写 一般写不出来  计算矩形 首先知道高贺宽 高可能是很多个 我们需要枚举  高在枚举的时候已经知道了 剩下的就是宽  宽的话  每一个高的宽  就是找到比我小的 那就是边界了 可以用栈的性质去解决 下一题</p>
<h2 id="最大矩形-1"><a href="#最大矩形-1" class="headerlink" title="最大矩形"></a>最大矩形</h2><p>直接上图 这个和上一个不太一样看起来很男</p>
<img src="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/zuidajuxing2.png" class="" title="This is an example image">
<p>这个呢 我们也可以归结为柱状图的最大矩形 但是这个底可能是在每一层  所以这里我们需要遍历每一层 得出当前这一层的heights数组 然后直接调用上一题的函数<br>这里也有个小技巧  我们每一层的高度数组 和上一层有关系 只和上一层有关系 有人会说 和最近的有关系 那不就是栈 但是 只和最近 注意这个只字  那之前的雨我无瓜 那就不用站 直接if来更新就行<br>上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最大柱状图 其实是最大的为1的矩形  然后使用最大柱状图的解法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;matrix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matrix.empty())<span class="comment">//异常检测 面试搞</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">heights</span><span class="params">(n)</span></span>; <span class="comment">//进行矩形数组的高度的初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//输入第一层 如果是1  那么高度就是1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                heights[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                heights[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = largestRectangleArea(heights);<span class="comment">//来个答案先</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][k] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    heights[k]++;   <span class="comment">//如果是1  那么就在上一层的基础上+1  如果上一层是0  那也是1  不影响</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    heights[k] = <span class="number">0</span>;      <span class="comment">//如果是0  那就不可能是矩形的角  你上面再高都没用</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, largestRectangleArea(heights)); <span class="comment">//当前层的答案</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(v.size())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(v.size())</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; leftPos;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; rightPos;</span><br><span class="line">        <span class="keyword">if</span> (v.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!leftPos.empty() &amp;&amp; v[leftPos.top()] &gt;= v[i])</span><br><span class="line">            &#123;</span><br><span class="line">                leftPos.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftPos.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = leftPos.top();</span><br><span class="line">            &#125;</span><br><span class="line">            leftPos.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!rightPos.empty() &amp;&amp; v[rightPos.top()] &gt;= v[i])</span><br><span class="line">            &#123;</span><br><span class="line">                rightPos.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightPos.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = v.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = rightPos.top();</span><br><span class="line">            &#125;</span><br><span class="line">            rightPos.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = max(ans, v[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总的来说 柱状图的矩形还是很有用的 嗯 over  干就完了</p>
<h2 id="二叉树的锯齿遍历"><a href="#二叉树的锯齿遍历" class="headerlink" title="二叉树的锯齿遍历"></a>二叉树的锯齿遍历</h2><img src="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/juchi.png" class="" title="This is an example image">
<p>如题 二叉树的锯齿遍历 有多种解法 先来个我手撕的 当时看到标题是栈 就自觉地的使用的栈  发现一个栈不太行 因为要同时进行栈顶操作和入栈 而且要把栈直接pop空  所以 一边pop一边push  有点呆 所以直接来两个栈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; s1;       <span class="comment">//来两个栈  </span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; s2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;    <span class="comment">//来个ans</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root)          <span class="comment">//异常检测 爬</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        s1.push(root);  <span class="comment">//首先root先入栈 紧接着就是从右往左 所以入s1</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)           <span class="comment">//这里while  1 是因为 一开始s2是空的 所以不能判断西面的if</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>)           <span class="comment">//往一个空栈里加 这个空栈pop  一直到空</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">                <span class="keyword">while</span> (!s1.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode *temp = s1.top();</span><br><span class="line">                    s1.pop();</span><br><span class="line">                    a.push_back(temp-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span> (temp-&gt;left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        s2.push(temp-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (temp-&gt;right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        s2.push(temp-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(a);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">                <span class="keyword">while</span> (!s2.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode *temp = s2.top();</span><br><span class="line">                    s2.pop();</span><br><span class="line">                    a.push_back(temp-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span> (temp-&gt;right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        s1.push(temp-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (temp-&gt;left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        s1.push(temp-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(a);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s1.empty() &amp;&amp; s2.empty())&#123;      <span class="comment">//这里就是说的 不能在while进行循环 因为一开始有一个是空的 所以无法进循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一开始标签说的是栈 所以一直想的是栈  但是我们二叉树的遍历有两种 一种是基于栈的  DFS的遍历 然后通过栈的特点  可以访问最近的状态 进行回溯<br>一种就是万能BFS  可以求各种高度 宽度  这里讲一下BFS的方法<br>BFS传统来说就是左到右 但是其实判断一下cnt  然后选择是push到vetor的头还是尾就行了 代码就不放了 DFS 因为是递归实现 那就要传level  在相应的ans的层面上去进行push头还是尾 就说到这 溜了 看js</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法之折磨王</title>
    <url>/2020/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8A%98%E7%A3%A8%E7%8E%8B/</url>
    <content><![CDATA[<h1 id="总结一下二叉树的基本算法-很基本很基本-下面课文要求全文背诵"><a href="#总结一下二叉树的基本算法-很基本很基本-下面课文要求全文背诵" class="headerlink" title="总结一下二叉树的基本算法 很基本很基本 下面课文要求全文背诵"></a>总结一下二叉树的基本算法 很基本很基本 下面课文要求全文背诵</h1><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p>首先是递归的写法 很简单 就是当前的高度为 1 然后递归的进行左右子树的递归调用 取左右子树的最高 注意一开始要判断是不是空指针 如果是空指针的话 那么当前的高度就是 0 不能+1 上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTreeHeight</span><span class="params">(Node&lt;<span class="keyword">int</span>&gt;* tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tree) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left = getTreeHeight(tree-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = getTreeHeight(tree-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left &gt; right ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归版本 （一般的难点考察都是非递归的版本）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(pRoot=null)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">while</span> (len--)&#123;</span><br><span class="line">                TreeNode* temp=q.front();<span class="comment">//表头</span></span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left) q.push(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right) q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>非递归类似于 BFS 广度优先遍历 把每一层都遍历完之后 深度自然是+1</p>
<h2 id="二叉树的宽度-其宽度定义为各层结点数的最大值-其实就是顾名思义啦"><a href="#二叉树的宽度-其宽度定义为各层结点数的最大值-其实就是顾名思义啦" class="headerlink" title="二叉树的宽度 其宽度定义为各层结点数的最大值 其实就是顾名思义啦"></a>二叉树的宽度 其宽度定义为各层结点数的最大值 其实就是顾名思义啦</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">width</span><span class="params">(Node&lt;<span class="keyword">int</span>&gt; *bt)</span> <span class="comment">//求二叉树宽度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&lt;<span class="keyword">int</span>&gt; *&gt; q;</span><br><span class="line">    Node&lt;<span class="keyword">int</span>&gt; *p = bt;</span><br><span class="line">    <span class="keyword">int</span> len, width;</span><br><span class="line">    <span class="keyword">if</span> (!bt)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q.push(p);</span><br><span class="line">    width = len = q.size(); <span class="comment">//初始化，width表示当前比较过程中每一层节点个数的最大值，len为循环变量，表示每轮队列的长度，即每层的结点个数</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (len--) <span class="comment">//将上一层踢出去，下一层全部进来</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left)</span><br><span class="line">                q.push(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right)</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        len = q.size();  <span class="comment">//此时的len为刚刚进来的那一层的结点个数</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; width) <span class="comment">//和已知的最大宽度比较，擂台赛</span></span><br><span class="line">            width = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两份代码都很像 其实就是解决了二叉树的层次遍历 这个层次遍历我们可以得到深度和广度 嗯 非常不错 因此层次遍历也有了一个很好听的名字 叫做广度优先遍历 BFS  （breadth first search） 听起来高大上 其实就是利用队列实现的一个遍历算法</p>
<h2 id="二叉树的叶子的数目"><a href="#二叉树的叶子的数目" class="headerlink" title="二叉树的叶子的数目"></a>二叉树的叶子的数目</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leaves</span><span class="params">(<span class="keyword">const</span> BinaryNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123; <span class="comment">// if head is nullptr, return directly</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">const</span> BinaryNode *&gt; qbfs;</span><br><span class="line">  qbfs.push(head);</span><br><span class="line">  <span class="keyword">while</span> (!qbfs.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (qbfs.front()-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123; <span class="comment">// if current queue front has left child</span></span><br><span class="line">      qbfs.push(qbfs.front()-&gt;left);</span><br><span class="line">      flag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (qbfs.front()-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123; <span class="comment">// if current queue front has right child</span></span><br><span class="line">      qbfs.push(qbfs.front()-&gt;right);</span><br><span class="line">      flag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    qbfs.pop(); <span class="comment">// pop if we have alreay visit the BinaryNode</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans=cnt;</span><br><span class="line">  cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又是二叉树的广度遍历 这个BFS  其实就是遍历每一个节点 看看是不是两个指针都是空的 如果都是空 那么就是叶子节点 ans++  求内部节点也可以是相同的道理</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>除了BFS  还有DFS 深度优先遍历  DFS 直接从一道题开始说起</p>
<img src="/2020/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8A%98%E7%A3%A8%E7%8E%8B/DFS.png" class="" title="This is an example image">
<p>DFS 我们根据的是递归调用 如果没有到叶子节点 那么就继续调用DFS  继续深挖</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.emplace_back(root-&gt;val);</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; sum == <span class="number">0</span>) &#123;</span><br><span class="line">            ret.emplace_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, sum);</span><br><span class="line">        dfs(root-&gt;right, sum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        dfs(root, sum);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树进阶AVL"><a href="#二叉搜索树进阶AVL" class="headerlink" title="二叉搜索树进阶AVL"></a>二叉搜索树进阶AVL</h2><p>BST 其实就是左边和右边的节点的大小是有特定含义的二叉树  这里面的进阶版本就是AVL 平衡二叉树 AVL的基础其实就是BST  只是在进行插入的时候 进行了一些列的左旋和右旋 对BST的平衡性进行了一系列的平衡  下面说一下AVL的实现<br>先上代码 再一行一行的分析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">avlnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">avlnode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">avlnode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; AVLNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">avltree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AVLNode *root;</span><br><span class="line">&#125; AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree *<span class="title">CreateAVLTree</span><span class="params">()</span> <span class="comment">//创建一个Tree</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree *tree = <span class="keyword">new</span> AVLTree;</span><br><span class="line">    tree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RootHeight</span><span class="params">(<span class="keyword">const</span> AVLNode *root)</span> <span class="comment">//当前节点的高度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;height; <span class="comment">//返回当前节点高度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> <span class="comment">//求Max</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingleRotateWithLeft</span><span class="params">(AVLNode **root)</span> <span class="comment">//这里用的双指针真的想呕  其实这里就是要改变root  如果传进来的只是一个root的话 那么这个指针指向的东西就不能改变了 否则要穿指针的引用</span></span></span><br><span class="line"><span class="function"></span>&#123;                                         <span class="comment">//这里其实是右旋- -  with left乱起名</span></span><br><span class="line">    AVLNode *temp;</span><br><span class="line">    temp = (*root)-&gt;left;                                                             <span class="comment">//保存需要左旋的头结点</span></span><br><span class="line">    (*root)-&gt;left = temp-&gt;right;                                                      <span class="comment">//需要左旋的root的左边已经不需要了 因为左边要成为新的root</span></span><br><span class="line">    temp-&gt;right = *root;                                                              <span class="comment">//下一个节点的右边等于当前的root</span></span><br><span class="line">    (*root)-&gt;height = Max(RootHeight((*root)-&gt;left), RootHeight((*root)-&gt;right)) + <span class="number">1</span>; <span class="comment">//先更新已经被插到下面节点的height</span></span><br><span class="line">    temp-&gt;height = Max(RootHeight(temp-&gt;left), RootHeight(temp-&gt;right)) + <span class="number">1</span>;          <span class="comment">//再更新已经成为root的height这样得到的高度就是最高</span></span><br><span class="line">    *root = temp;                                                                     <span class="comment">//改变传进来的指针变为左边的子节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingleRotateWithRight</span><span class="params">(AVLNode **root)</span> <span class="comment">//左旋就是头变成左边的子节点  左边子节点的右边变成原来的root  原来的左边子节点的右边变成root的左边</span></span></span><br><span class="line"><span class="function"></span>&#123;                                          <span class="comment">//这里是左旋  也就是右边太高了 旋转到左边 那么就是右边子节点的左边是当前root</span></span><br><span class="line">    AVLNode *temp;</span><br><span class="line">    temp = (*root)-&gt;right;                                                            <span class="comment">//左旋的时候 保存右边的节点</span></span><br><span class="line">    (*root)-&gt;right = temp-&gt;left;                                                      <span class="comment">//左边因为下一行要变成root  所以先对root的右边进行赋值 不然的话就会丢失</span></span><br><span class="line">    temp-&gt;left = *root;                                                               <span class="comment">//要当做root的左边已经被利用完了 可以进行赋值了</span></span><br><span class="line">    (*root)-&gt;height = Max(RootHeight((*root)-&gt;left), RootHeight((*root)-&gt;right)) + <span class="number">1</span>; <span class="comment">//先更新成为子节点的高度</span></span><br><span class="line">    temp-&gt;height = Max(RootHeight(temp-&gt;left), RootHeight(temp-&gt;right)) + <span class="number">1</span>;          <span class="comment">//再更新成为root节点的高度</span></span><br><span class="line">    *root = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoubleRotateWithLeft</span><span class="params">(AVLNode **root)</span> <span class="comment">//先左旋再右旋  整体是右旋  那么就是左子节点先要左旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SingleRotateWithRight(&amp;(*root)-&gt;left);</span><br><span class="line">    SingleRotateWithLeft(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoubleRotateWithRight</span><span class="params">(AVLNode **root)</span> <span class="comment">//先右旋再左旋  整体是左旋 那么就是右子节点先右旋</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SingleRotateWithLeft(&amp;(*root)-&gt;right);</span><br><span class="line">    SingleRotateWithRight(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AVLInsert</span><span class="params">(AVLNode *&amp;root, <span class="keyword">int</span> data)</span> <span class="comment">//插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == root) <span class="comment">//如果要插入的地方是NULL  那么就在当前节点直接插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> AVLNode; <span class="comment">//就是创建一个新节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == root)   <span class="comment">//申请内存失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;key = data;</span><br><span class="line">        root-&gt;height = <span class="number">0</span>;</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; root-&gt;key)</span><br><span class="line">    &#123;</span><br><span class="line">        AVLInsert(root-&gt;left, data);                               <span class="comment">//从左边插入  因为按照传统功夫的插入  如果比pivot小 那么就是在左边插入</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> == RootHeight(root-&gt;left) - RootHeight(root-&gt;right)) <span class="comment">//如果不平衡了 为什么是左边-右边 因为插入在左边 不可能右边比左边高</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; root-&gt;left-&gt;key) <span class="comment">//如果是插入了左节点的左边 那么就是阶梯式 那么只需要单纯的右旋</span></span><br><span class="line">            &#123;</span><br><span class="line">                SingleRotateWithLeft(&amp;root); <span class="comment">//右旋</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                DoubleRotateWithLeft(&amp;root); <span class="comment">//如果是在左节点的右边 那么就是左节点先左旋 然后根节点右旋</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; root-&gt;key) <span class="comment">//大同小异</span></span><br><span class="line">    &#123;</span><br><span class="line">        AVLInsert(root-&gt;right, data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> == RootHeight(root-&gt;right) - RootHeight(root-&gt;left))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &gt; root-&gt;right-&gt;key)</span><br><span class="line">            &#123;</span><br><span class="line">                SingleRotateWithRight(&amp;root);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                DoubleRotateWithRight(&amp;root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;height = Max(RootHeight(root-&gt;left), RootHeight(root-&gt;right)) + <span class="number">1</span>;  <span class="comment">//插入完成之后 还要更新高度哦</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AVL的实现基本就是上述代码  这样我们的搜索每一次都可以接近log n  注意每次更新高度的时候 顺序的问题 先更新子节点的高度 然后更新父节点的高度</p>
<h2 id="看起来很简单的算法题—-寻找数组第k大的数"><a href="#看起来很简单的算法题—-寻找数组第k大的数" class="headerlink" title="看起来很简单的算法题—-寻找数组第k大的数"></a>看起来很简单的算法题—-寻找数组第k大的数</h2><h3 id="直接上On的解法-和快速排序相似的方法"><a href="#直接上On的解法-和快速排序相似的方法" class="headerlink" title="直接上On的解法  和快速排序相似的方法"></a>直接上On的解法  和快速排序相似的方法</h3><p>快速排序的理论就是  选择一个pivot  然后对当前的pivot 选择一个合适的位置 进行插入  那么这个插入的位置 就是这个数组里面 他确定的位置 那么要求第k大的数 就可以使用这个 这个只能求1个 而不是前k个大的数字  先上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;    <span class="comment">//这里的函数其实就是模拟了一趟快速排序</span></span><br><span class="line">  <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  swap(arr[left], arr[(left + right) / <span class="number">2</span>]);  <span class="comment">//这里是点睛之笔  如果无脑选择左边当做pivot 那么就会可能陷入出题人的坑  如果是顺序的话 那么时间复杂就会是n^2   这里的pivot 如果换做是一个random函数  这样的话就会更加趋近于平均的情况  这里选择的是中间的</span></span><br><span class="line">  <span class="keyword">int</span> i, j, base, temp;</span><br><span class="line">  i = left, j = right;</span><br><span class="line">  base = arr[left]; <span class="comment">//取最左边的数为基准数</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[j] &gt;= base &amp;&amp; i &lt; j)</span><br><span class="line">      j--;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] &lt;= base &amp;&amp; i &lt; j)</span><br><span class="line">      i++;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">      temp = arr[i];</span><br><span class="line">      arr[i] = arr[j];</span><br><span class="line">      arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//基准数归位</span></span><br><span class="line">  arr[left] = arr[i];</span><br><span class="line">  arr[i] = base;</span><br><span class="line">  <span class="keyword">return</span> i;       <span class="comment">//返回pivot应该呆的位置 如果这个位置就是k-1  就是k第k个小的数字 那么就ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select_kth_smallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">size_t</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (input.empty() || k &gt; input.size()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;wdnmd&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> input[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>, end = input.size() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> index;</span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    index = Partition(input, start, end);  <span class="comment">//先归位  然后获取这个pivot应该在的位置</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; k - <span class="number">1</span>)              <span class="comment">//如果这个位置比k小  那么这个第k个数肯定在这个pivot的右边 因为左边数字不够多了</span></span><br><span class="line">      start = index + <span class="number">1</span>;        <span class="comment">//排除这个pivot的左边 所以排除这个pivot在内的左边的数组</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; k - <span class="number">1</span>)</span><br><span class="line">      end = index;          <span class="comment">//和上面大同小异</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> input[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面选择第k小的数字使用了快速排序的pivot的归位然后使用递归 真不错</p>
<h2 id="判断一个二叉树是否平衡"><a href="#判断一个二叉树是否平衡" class="headerlink" title="判断一个二叉树是否平衡"></a>判断一个二叉树是否平衡</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTreeHeight</span><span class="params">(Node&lt;<span class="keyword">int</span>&gt;* tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tree) <span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left = getTreeHeight(tree-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = getTreeHeight(tree-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left &gt; right ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(Node&lt;<span class="keyword">int</span>&gt; *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="comment">//空树是平衡二叉树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> leftHeight = getTreeHeight(T-&gt;left); <span class="comment">//求左右子树的高度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rightHeight = getTreeHeight(T-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) <span class="comment">//判断根节点平衡因子不为-1、0、1时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (isBalanced(T-&gt;left) &amp;&amp; isBalanced(T-&gt;right)); <span class="comment">//递归调用，左右子树都为平衡二叉树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面的代码 通俗易懂 但是需要我理解的就是 如何使用递归 去得到树的高度  就是如果是空节点的话 那么就返回0  当前高度是0  如果不是空的  那么就递归返回两个子节点高度  然后取最大值 然后加上自己+1  判断是不是平衡 其实也就是判断左边的子节点是不是平衡的  注意 如果左边的高度等于右边的高度 那么还是不一定是平衡的 可能左右两边都是一条链  这个时候还是需要递归判断两个子节点是否是平衡的</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法折磨王--图初步</title>
    <url>/2020/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%8A%98%E7%A3%A8%E7%8E%8B-%E5%9B%BE%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<p>今天数据结构老师给了图 这里总结一下自己完全不会的东西 - -</p>
<h1 id="Valid-BFS"><a href="#Valid-BFS" class="headerlink" title="Valid BFS"></a>Valid BFS</h1><p>这一题意思就是 给定一系列的边的父亲和儿子节点 按照顺序 然后给定了一串序列  要判定当前序列是不是按照BFS输出  重点是 这里的BFS不是我们常说的二叉树的BFS 这里的是  我们首先取出这个队列的头 然后这个头的两个子节点 我们按照任意的顺序 push到这个队列里面 注意 这里重点是任意的顺序 而不是我们常说的 从左到右  所以这里我们不能直接BFS 然后比较  我们要使用双指针模仿我们的BFS  也就是我们当前的慢指针 就是我们的队列头 然后我们在BFS的时候 会把这个队列头插入队列里面 然后我们输出的顺序就是按照这个队列 那么我们的快指针就可以判断当前的值是不是慢指针的邻居 如果是的话 那就移动向下一个 直到当前快指针不是当前慢指针的儿子节点  这个判断是不是儿子节点我们可以通过map进行储存  如果是的话 那么map的值就是1嗯  然后如果是BFS正确结果的话 那么应该这个快指针可以直接遍历到尾巴 上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp[maxN]; <span class="comment">//用来储存是不是有效的边 注意这里是数组哦</span></span><br><span class="line"><span class="keyword">int</span> q[maxN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="comment">//这里面只要n-1条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        mp[u][v]  = <span class="number">1</span>; <span class="comment">//这里面保存的是两个顶点是不是有边  如果有的话 那就是正常的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//目标数组</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line">    <span class="keyword">if</span> (q[<span class="number">1</span>] == <span class="number">1</span>) <span class="comment">//如果第一个头不是1  那就是题目傻逼</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>;        <span class="comment">//快慢指针 这里面也就是双指针   这里是重点 我们这里定义的bfs是 每一次从队列里面抓出第一个</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//然后按照任意顺序去插入他的邻居到队列 这里面的任意和我们的先左后右是不一样的 这就是这题的难点</span></span><br><span class="line">            <span class="keyword">for</span> (j; mp[q[i]][q[j]]; ++j)</span><br><span class="line">                ;</span><br><span class="line">        <span class="keyword">if</span> (j == n + <span class="number">1</span>)<span class="comment">//如果遍历到最后 那就是yes</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一题看起来没那么复杂 还是可以写的 那么下面呢？</p>
<h1 id="Obsession-with-Robots"><a href="#Obsession-with-Robots" class="headerlink" title="Obsession with Robots"></a>Obsession with Robots</h1><p>题目讲的就是 有一个机器人 在一个无限大的地图上面跑  然后给定了操作 比如说 U就是往前走 R L就是左走右走  然后到达一个坐标 问你这个机器人到达这个目的地是不是最短距离  意思就是 这个机器人走的路线有没有捷径可以让自己走的更短 我们简单地理解都是 路径有没有成环的地方 如果有 那就证明有捷径（其实不一定 如果这个环上面和下面路径一样长）  所以不能判断是不是成环 应该判断是不是有捷径 直接上代码  这里我们使用的也是BFS 上面讲述了BFS的原理 然后比较无聊的问了不同的顺序push进队列 基本没有什么实用价值 下面我们就是使用正常的BFS 解题<br>BFS究竟用在什么地方呢？ 其实就是 当前的一个状态 我们有很多个操作可以达到子状态的时候  我们去遍历这一些子状态  通过队列进行遍历  还有就是图的比较简单地非递归遍历  我们这里的机器人就是 当前我们可以上下左右4个状态 我们就需要BFS这四种状态 然后判断是不是已经访问过之类的然后进行push进队列  上代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> M[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> T[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)<span class="comment">//初始化一个图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; j++)</span><br><span class="line">            M[i][j] = <span class="number">1</span>;<span class="comment">//全是障碍</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;<span class="comment">//输入路径</span></span><br><span class="line">    <span class="keyword">int</span> nowx = maxn / <span class="number">2</span>, nowy = maxn / <span class="number">2</span>;<span class="comment">//让这个B从图的中央开始走</span></span><br><span class="line">    M[nowx][nowy] = <span class="number">0</span>;<span class="comment">//开路  一开始的nowx 和nowy  就是开路</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (s[i])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            nowy++;</span><br><span class="line">            M[nowx][nowy] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">            nowx++;</span><br><span class="line">            M[nowx][nowy] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            nowx--;</span><br><span class="line">            M[nowx][nowy] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">            nowy--;</span><br><span class="line">            M[nowx][nowy] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//这里面走完这个图 开完路</span></span><br><span class="line">    <span class="keyword">int</span> enx = nowx, eny = nowy;</span><br><span class="line">    nowx = maxn / <span class="number">2</span>, nowy = maxn / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">    Q.push(<span class="built_in">make_pair</span>(nowx, nowy));</span><br><span class="line">    vis[nowx][nowy] = <span class="number">1</span>;        <span class="comment">//从头开始 已经访问过了</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())      <span class="comment">//跑bfs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; next = now;</span><br><span class="line">            <span class="keyword">switch</span> (i)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                next.first += <span class="number">1</span>;</span><br><span class="line">                next.second += <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                next.first += <span class="number">-1</span>;</span><br><span class="line">                next.second += <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                next.first += <span class="number">0</span>;</span><br><span class="line">                next.second += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                next.first += <span class="number">0</span>;</span><br><span class="line">                next.second += <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (vis[next.first][next.second])<span class="comment">//拜访过就下一个</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (M[next.first][next.second])<span class="comment">//障碍就下一个 证明没开路</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            T[next.first][next.second] = T[now.first][now.second] + <span class="number">1</span>;<span class="comment">//路程</span></span><br><span class="line">            vis[next.first][next.second] = <span class="number">1</span>;</span><br><span class="line">            Q.push(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T[enx][eny] &lt; s.size())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BUG&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里面的问题就是 这个机器人走的路径到底是不是最短的 也就是说有没有成环 就是从一开始走的时候  BFS就是把当前可能走到的位置直接标记了  比如我一开始就有捷径</span></span><br><span class="line"><span class="comment">可以走到我后面路径的位置  这个位置不是障碍物  然后标记是拜访过  然后就去这个地方  那么到时候在队列里面处理这个地方的时候 距离就是这个捷径+1 那么到终点的</span></span><br><span class="line"><span class="comment">距离就不是我们给的路径了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这里面是如何保证路径是最小的呢  因为我们是从头开始BFS的 有捷径就会先访问 这里也是BFS的优点</p>
<h1 id="Number-Clicker（双向BFS）"><a href="#Number-Clicker（双向BFS）" class="headerlink" title="Number Clicker（双向BFS）"></a>Number Clicker（双向BFS）</h1><p>嗯 双向BFS  听起来很牛逼 但是我们只要选好了数据结构 也没那么难  上面第一个 我们选择了MAP进行储存是不是当前两个点有边  第二个用了二维数组 进行储存我们走过的路径  二维数组更好体现了我们的路径 map体现的是边<br>这一题的意思就是给定两个数字 然后还有一个常数  然后第一个数字可以经过3种运算之后  得到第二个数字 问我们最少的操作数  还要输出我们是经过什么顺序的那种操作  这里我们肯定不能一次性在数组里面push 和pop  我们应该进行BFS然后储存当前的状态  这个状态包含什么呢 包含了我们上一个状态 上一个状态用了什么操作到当前状态  以及当前的步骤数 这里我们的key就是当前的状态 那就是map啦 储存一个struct 上代码  然后我们进行双向BFS  一边步骤数是减的 而且是负数 这里也是华点 然后我们从结果和开始双向BFS  然后如果当前的下一个状态已经被访问过了 那么就是相遇了 为什么呢 因为我们是BFS  具体的情况代码里说</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>//这里记录的是 当前的这个数字的  前身 以及前面用的是什么<span class="title">button</span> 和第几步</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> step, but;</span><br><span class="line">    LL pre;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;LL, Node&gt; path;<span class="comment">//这里建立的就是这个表 当前的LL对应的状态</span></span><br><span class="line">LL u, v, p;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">fpow</span><span class="params">(LL a, LL n)</span><span class="comment">//好家伙 快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            res = (res * a) % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(LL a, LL b, <span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, path[a].step - <span class="number">1</span> - path[b].step);</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">while</span> (a != u)</span><br><span class="line">    &#123;</span><br><span class="line">        Node ap = path[a];</span><br><span class="line">        S.push(ap.but);</span><br><span class="line">        a = ap.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, op);</span><br><span class="line">    <span class="keyword">while</span> (b != v)</span><br><span class="line">    &#123;</span><br><span class="line">        Node bp = path[b];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, bp.but);</span><br><span class="line">        b = bp.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    path.clear();</span><br><span class="line">    path[u] = (Node)&#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;<span class="comment">//双向BFS  为什么这里是BFS呢  其实BFS代表的就是 如果当前有很多个操作的状态 那么就我们需要记录每一种状态可能的结果  然后加入队列 等下下一轮的遍历</span></span><br><span class="line">    path[v] = (Node)&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;<span class="comment">//BFS的另一头</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;LL&gt; qf, qb;<span class="comment">//两个BFS的待处理的队列</span></span><br><span class="line">    qf.push(u);</span><br><span class="line">    qb.push(v);</span><br><span class="line">    <span class="keyword">while</span> (!qf.empty() || !qb.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!qf.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            LL x = qf.front();<span class="comment">//抓头</span></span><br><span class="line">            qf.pop();</span><br><span class="line">            Node xp = path[x];<span class="comment">//抓出当前这个头的状态</span></span><br><span class="line">            LL next = (x + <span class="number">1</span>) % p;<span class="comment">//第一个操作</span></span><br><span class="line">            Node np = path[next];<span class="comment">//map 如果没创建 那么就是0</span></span><br><span class="line">            <span class="keyword">if</span> (np.step == <span class="number">0</span>)</span><br><span class="line">            &#123; <span class="comment">//未访问</span></span><br><span class="line">                path[next] = (Node)&#123;xp.step + <span class="number">1</span>, <span class="number">1</span>, x&#125;;<span class="comment">//这个button之后的值的状态就是  步骤是+1  然后 使用的button就是1 x就是我们之前的</span></span><br><span class="line">                qf.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &lt; <span class="number">0</span>)<span class="comment">//当前的这个值的状态已经被初始化过了 那就是相遇啦  这里我们是可以保证是最短的 怎么说呢 想象一个树  每一层的状态*3  每一层代表了一个步骤  那么从上往下 这个的数的交点肯定是最小的 不可能绕弯路</span></span><br><span class="line">            &#123; <span class="comment">//相遇</span></span><br><span class="line">                Print(x, next, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next = (x + p - <span class="number">1</span>) % p; <span class="comment">//op2</span></span><br><span class="line">            np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (np.step == <span class="number">0</span>)<span class="comment">//这里也是华点  我们这里首先判断是不是访问过  如果不是 那就是第一次访问 然后因为是BFS  第一次访问肯定是最短的距离 所以直接保存</span></span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step + <span class="number">1</span>, <span class="number">2</span>, x&#125;;</span><br><span class="line">                qf.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &lt; <span class="number">0</span>)<span class="comment">//要是已经被保存过了  这里判断是不是相遇不是通过是不是已经保存 而是判断当前的step是不是和自己符号相反 因为如果是符号相同的话 那么现在的步骤肯定是比之前要多的 因为是BFS  如果符号相同 直接舍弃当前结果</span></span><br><span class="line">            &#123;</span><br><span class="line">                Print(x, next, <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next = fpow(x, p - <span class="number">2</span>);</span><br><span class="line">            np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (np.step == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step + <span class="number">1</span>, <span class="number">3</span>, x&#125;;</span><br><span class="line">                qf.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Print(x, next, <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!qb.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            LL x = qb.front();</span><br><span class="line">            qb.pop();</span><br><span class="line">            Node xp = path[x];</span><br><span class="line"></span><br><span class="line">            LL next = (x + p - <span class="number">1</span>) % p;</span><br><span class="line">            Node np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (!np.step)</span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step - <span class="number">1</span>, <span class="number">1</span>, x&#125;;</span><br><span class="line">                qb.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Print(next, x, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next = (x + <span class="number">1</span>) % p;</span><br><span class="line">            np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (!np.step)</span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step - <span class="number">1</span>, <span class="number">2</span>, x&#125;;</span><br><span class="line">                qb.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Print(next, x, <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next = fpow(x, p - <span class="number">2</span>);</span><br><span class="line">            np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (!np.step)</span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step - <span class="number">1</span>, <span class="number">3</span>, x&#125;;</span><br><span class="line">                qb.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Print(next, x, <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, tmp, T;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;u, &amp;v, &amp;p) == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (u == v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BFS();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>好了以上就是我们的全部内容了 其实今天有4题  我只看懂了3题  嗯  只写了3题 另外一个是树形DP 我爪巴</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法之二叉树补充</title>
    <url>/2020/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>今天翻看代码 发现二叉树的三种遍历还没怼上去 这里说的都是非递归版本 别问 问就是上流 这里补充一下  顺便总结一下最近的烂东西</p>
<h1 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> s = [];</span><br><span class="line">    <span class="keyword">let</span> move = root;</span><br><span class="line">    <span class="keyword">while</span> (move || s.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (move) &#123;</span><br><span class="line">            res.push(move.val);</span><br><span class="line">            s.push(move);</span><br><span class="line">            move = move.left;</span><br><span class="line">        &#125;</span><br><span class="line">        move = s.pop();</span><br><span class="line"></span><br><span class="line">        move = move.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> s = [];</span><br><span class="line">    <span class="keyword">let</span> move = root;</span><br><span class="line">    <span class="keyword">while</span> (move || s.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (move) &#123;</span><br><span class="line">            s.push(move);</span><br><span class="line">            move = move.left;</span><br><span class="line">        &#125;</span><br><span class="line">        move = s.pop();</span><br><span class="line">        res.push(move.val);</span><br><span class="line">        move = move.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h1><p>这里面有两种方法 两种都是基于栈 这里面因为是后序遍历  我们需要记录当前的点是否已经被访问过  这里有两种方法 一种是增加一个last指针 另外一种就是push两次  pop的时候判断是不是在栈里面 直接上代码</p>
<h2 id="基于last指针的后续遍历"><a href="#基于last指针的后续遍历" class="headerlink" title="基于last指针的后续遍历"></a>基于last指针的后续遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> s = [];</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> last = root;</span><br><span class="line">    <span class="keyword">let</span> move = root;</span><br><span class="line">    s.push(move);</span><br><span class="line">    <span class="keyword">while</span> (s.length != <span class="number">0</span>) &#123;</span><br><span class="line">        move = s[s.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> ((move.left === <span class="literal">null</span> &amp;&amp; move.right === <span class="literal">null</span>) || (last == move.left &amp;&amp; move.right === <span class="literal">null</span>) || last == move.right) &#123;</span><br><span class="line">            res.push(move.val);</span><br><span class="line">            last = move;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (move.right) &#123;</span><br><span class="line">                s.push(move.right);    <span class="comment">//这里注意 因为是后序遍历 先访问左边 再是右边 所以栈顶应该是左边  所以左边后入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (move.left) &#123;</span><br><span class="line">                s.push(move.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="基于双push-pop的后续遍历"><a href="#基于双push-pop的后续遍历" class="headerlink" title="基于双push pop的后续遍历"></a>基于双push pop的后续遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal_two_push = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> s = [];</span><br><span class="line">    <span class="keyword">let</span> move = root;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> [];    <span class="comment">//这一行的作用是 如果是空的 那么root进栈之后 访问他的left就会出错  因为null没有left</span></span><br><span class="line">    s.push(root);</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (s.length != <span class="number">0</span>) &#123;</span><br><span class="line">        move = s.pop();</span><br><span class="line">        <span class="keyword">if</span> (move != s[s.length - <span class="number">1</span>] || s.length == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push(move.val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (move.right) &#123;           <span class="comment">//没错 就是这里</span></span><br><span class="line">                s.push(move.right);    </span><br><span class="line">                s.push(move.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (move.left) &#123;</span><br><span class="line">                s.push(move.left);      <span class="comment">//注意 这里也是right先进栈  然后 left再进  </span></span><br><span class="line">                s.push(move.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="这里说一下前端CSS的flex"><a href="#这里说一下前端CSS的flex" class="headerlink" title="这里说一下前端CSS的flex"></a>这里说一下前端CSS的flex</h1><p>如果是左右布局 一左一右  左边的宽度需要自适应 参考如下代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  .left&#123;</span><br><span class="line">    <span class="selector-tag">flex</span>: 1;</span><br><span class="line">    <span class="selector-tag">margin-right</span><span class="selector-pseudo">:auto</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
</search>
