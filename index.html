<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Dream Starts Here">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Dream Starts Here">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zhongsihui">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Dream Starts Here</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dream Starts Here</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%92%8Cdijktra/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhongsihui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dream Starts Here">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%92%8Cdijktra/" class="post-title-link" itemprop="url">数据结构与算法之并查集和dijktra和走迷宫</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-24 22:11:56 / Modified: 23:07:52" itemprop="dateCreated datePublished" datetime="2020-12-24T22:11:56+08:00">2020-12-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>又是周四 今天继续讲图</p>
<h1 id="Dijkstra-算法-求最短路径-无向图"><a href="#Dijkstra-算法-求最短路径-无向图" class="headerlink" title="Dijkstra 算法 求最短路径 无向图"></a>Dijkstra 算法 求最短路径 无向图</h1><p>首先这个和走迷宫是不一样的 走迷宫和图不一样 图是顶点然后连边 但是迷宫可以说是图的搜索了 这个求最短路径一般来说不用到迷宫里面 用于我们的有向图的<br>求从一个顶点出发 到达所有顶点的值 如果到达的了的话<br>直接上代码吧 原理不多说了<br>还是说吧 就是维护一个状态数组 保存我们当前的状态 然后第一步 把 ans 数组全部置位 INT_MAX<br>然后第一步选择就是 source 把 ans[source]置位 0 自己到自己肯定最小就是 0<br>然后遍历所有 source 能到达的点 边权加上到达自己当前讨论的这个点 如果比数组中的状态要小 那么就更新我们的 ans 数组<br>这里不多说 直接上代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cases = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; cases;</span><br><span class="line">    <span class="keyword">while</span> (cases--)<span class="comment">//测例</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> vertexs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> edges = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; vertexs &gt;&gt; edges;<span class="comment">//点数和边数</span></span><br><span class="line">        <span class="keyword">int</span> g[vertexs + <span class="number">1</span>][vertexs + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(vertexs + <span class="number">1</span>, INT_MAX)</span></span>;<span class="comment">//我们的答案 第i个表示从source到i的最小值</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(vertexs + <span class="number">1</span>, <span class="number">0</span>)</span></span>;<span class="comment">//是不是已经讨论过了  也就是最小已经是确定的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges; i++)<span class="comment">//邻接矩阵</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> from, to, weight;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to &gt;&gt; weight;</span><br><span class="line">            g[from][to] = weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> source = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; source;</span><br><span class="line">        <span class="keyword">int</span> root = source;</span><br><span class="line">        <span class="keyword">int</span> now_dis = <span class="number">0</span>;<span class="comment">//当前  从source到当前讨论的这个顶点  距离最小值</span></span><br><span class="line">        visited[source] = <span class="number">1</span>;<span class="comment">// 这个头肯定访问过儿了</span></span><br><span class="line">        ans[source] = <span class="number">0</span>;<span class="comment">//00000</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs - <span class="number">1</span>; i++)<span class="comment">//因为是每一个点  所以除了头 要确定N-1个点的最小值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= vertexs; j++)<span class="comment">//看看当前讨论的点 和其他所有点的关系</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[j] == <span class="number">0</span>)<span class="comment">//如果没背讨论过</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g[source][j])<span class="comment">//而且source可以到达</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> dis = now_dis + g[source][j];<span class="comment">//到当前的距离 加上source到这个点的距离</span></span><br><span class="line">                        <span class="keyword">if</span> (dis &lt; ans[j])<span class="comment">//如果通过这个点到j  比之前的情况要小 贪心选择最小的</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            ans[j] = dis;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> minIndex = <span class="number">0</span>;<span class="comment">//这里是寻找我们的下一个source  这里贪心选择每一次都是最小的</span></span><br><span class="line">            <span class="keyword">while</span> (visited[minIndex] == <span class="number">1</span> || ans[minIndex] == INT_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                minIndex++;</span><br><span class="line">                <span class="keyword">if</span> (minIndex == vertexs + <span class="number">1</span>)<span class="comment">//这里是华点 如果有一些点到不了的话 那么minIndex就会爆 这里访问的话就会mem seg了</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minIndex == vertexs + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = minIndex; i &lt;= vertexs; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[i] == <span class="number">0</span> &amp;&amp; ans[i] &lt; ans[minIndex])</span><br><span class="line">                &#123;</span><br><span class="line">                    minIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//上面就是找到当前状态的最小值</span></span><br><span class="line">            now_dis = ans[minIndex];<span class="comment">//找到的当前状态的最小值 就是到达这个点的最小值了 根据贪心算法 不可能有更大的值</span></span><br><span class="line">            source = minIndex;</span><br><span class="line">            visited[source] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= vertexs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; root &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="走迷宫的最短路径-（矩阵两点的最短路径）"><a href="#走迷宫的最短路径-（矩阵两点的最短路径）" class="headerlink" title="走迷宫的最短路径 （矩阵两点的最短路径）"></a>走迷宫的最短路径 （矩阵两点的最短路径）</h1><p>题目就是 从给定的点 到指定的点 能不能走到 求最短路径 直接上代码吧</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//如果是0  那就是通路 如果是1  那就是障碍物</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    point(<span class="keyword">int</span> xn = <span class="number">0</span>, <span class="keyword">int</span> yn = <span class="number">0</span>) : x(xn), y(yn) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">const</span> point &amp;x, <span class="keyword">const</span> point &amp;y)</span><span class="comment">//两点是不是相等</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x.x == y.x) &amp;&amp; (y.y == x.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_nbr</span><span class="params">(<span class="keyword">const</span> point &amp;p, point &amp;neighbor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p.x &gt; <span class="number">0</span> &amp;&amp; g[p.x - <span class="number">1</span>][p.y] == <span class="number">0</span>)<span class="comment">//把上下左右  都给你访问一遍  相当于BFS  层次遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        neighbor.x = p.x - <span class="number">1</span>;</span><br><span class="line">        neighbor.y = p.y;</span><br><span class="line">        g[neighbor.x][neighbor.y] = <span class="number">1</span>;<span class="comment">//走过就要堵住</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.x &lt; n - <span class="number">1</span> &amp;&amp; g[p.x + <span class="number">1</span>][p.y] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        neighbor.x = p.x + <span class="number">1</span>;</span><br><span class="line">        neighbor.y = p.y;</span><br><span class="line">        g[neighbor.x][neighbor.y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.y &gt; <span class="number">0</span> &amp;&amp; g[p.x][p.y - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        neighbor.x = p.x;</span><br><span class="line">        neighbor.y = p.y - <span class="number">1</span>;</span><br><span class="line">        g[neighbor.x][neighbor.y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.y &lt; m - <span class="number">1</span> &amp;&amp; g[p.x][p.y + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        neighbor.x = p.x;</span><br><span class="line">        neighbor.y = p.y + <span class="number">1</span>;</span><br><span class="line">        g[neighbor.x][neighbor.y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tx, ty, sx, sy;</span><br><span class="line">    point p, neighbor;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; g[i][j];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty;</span><br><span class="line">    sx--;</span><br><span class="line">    sy--;</span><br><span class="line">    tx--;</span><br><span class="line">    ty--;<span class="comment">//读取目标 然后因为矩阵从0开始 所以嗯 你懂得</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;point&gt; q;</span><br><span class="line">    q.push(point(sx, sy));</span><br><span class="line">    g[sx][sy] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>, new_access = <span class="number">0</span>, old_access = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty() &amp;&amp; !isEqual(q.front(), point(tx, ty)))<span class="comment">//找光了 或者是找到了  就会跳出循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = q.front();</span><br><span class="line">        <span class="keyword">while</span> (get_nbr(p, neighbor))<span class="comment">//访问每一个可以访问到的下一个点</span></span><br><span class="line">        &#123;</span><br><span class="line">            q.push(neighbor);</span><br><span class="line">            new_access++;<span class="comment">//这里储存的是 下一个 即将要遍历的层有多少个</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q.pop();</span><br><span class="line">        old_access--;<span class="comment">//这里表示的是当前层有多少个顶点  处理完就--</span></span><br><span class="line">        <span class="keyword">if</span> (old_access == <span class="number">0</span>)<span class="comment">//当前层已经处理完了  让这个等于new  也就是下一层的点数</span></span><br><span class="line">        &#123;</span><br><span class="line">            old_access = new_access;</span><br><span class="line">            new_access = <span class="number">0</span>;</span><br><span class="line">            step++;<span class="comment">//步数++</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEqual(q.front(), point(tx, ty)))<span class="comment">//如果是因为找到了就弹出 那么就输出step</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; step;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集的概念 来自于我们有许多不同的集合 这些集合并不相交 这些集合里面内部的关系我们并不关心 我们只关心这一些集合之间相交的关系</p>
<blockquote>
<p>比如我们江湖上有许多门派 江湖上有上千万个人 不同人属于不同的门派 但是他们自己并不知道自己究竟是那一个门派的 只知道自己的引路人 自己的引路人同样也只知道自己的引路人 但是这样 江湖上两个陌生人见面 怎么样才能知道自己是不是同一个阵营呢？</p>
</blockquote>
<p>这里就应用到了并查集的知识 不同的门派代表不同的集合 我们并不关心这个集合里面的问题 只关心这两个人是不是同一个集合的 所以就是问题所在啦 我们可以在这个集合里面选择一个人作为我们所有人的老大 每个人都知道自己的老大就是他 新加入的人 引路人直接告诉他我们的老大就是他 并不需要把引路人当做老大 这样就 ok</p>
<blockquote>
<p>上面讲述的其实是压缩路径的算法 原本的算法是 引路人问引路人 一层一层找到老大 但是压缩路径之后就只有两层 这样的话 因为不关心集合里面的顺序 所以无所谓 加大的查找的速度</p>
</blockquote>
<p>这里上一道题 我们班级有很多的朋友圈 朋友的朋友就是我的朋友 下面给一个无向图 下面判断这个无向图是不是构成一个朋友圈 就是判断每一个在集合里面的人是不是和其他人都是朋友</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">father</span><span class="params">(<span class="number">150000</span>)</span></span>;<span class="comment">// 这里储存的是 自己的老大是谁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//找老大  找老大的途中 我们一开始 输入的边 意思就是我们只能找到自己的引路人 这个函数就是 引路人告诉他 老大就是我的引路人 一直递归下去 就会找到门派老大  这个递归是个华点 可以进行路径压缩  因为一开始的是没有压缩过的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == father[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> father[x] = findFather(father[x]);<span class="comment">//赋值 告诉他  以后找我的老大就行了 别来找我了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;ll&gt; <span class="title">num</span><span class="params">(<span class="number">150000</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)<span class="comment">//一开始很多个集合</span></span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//给定了边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">int</span> q = findFather(x);<span class="comment">//找我的老大</span></span><br><span class="line">        <span class="keyword">int</span> p = findFather(y);<span class="comment">//同上</span></span><br><span class="line">        father[q] = p;<span class="comment">//老大相同 这一步相当于没做  如果老大不同  那就让一个老大 是另一个的老大 怎么 不服？  爪巴！ 这样的话 如果不进行路径压缩 无疑多了一层  所以这里体现了路径压缩的重要性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)<span class="comment">//这个函数是计算每一个老大有多少个小弟  num数组代表的是 以findFather为老大的集合有多少个</span></span><br><span class="line">    &#123;</span><br><span class="line">        num[findFather(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)<span class="comment">//如果是valid的朋友圈 意思就是任意两个人都是朋友 那么这个朋友圈就有n*(n-1)/2 条边  然后把每一个朋友圈应该的边数加起来</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += (num[i] * (num[i] - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == m)<span class="comment">//如果我们的真正的 输入的边m  等于这么多 那么就是valid 为什么呢 因为这里约定不会输入重复的边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>图图图  秃秃秃  over！</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/23/CSS%E4%B9%8B%E9%9A%BE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%92%8C%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhongsihui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dream Starts Here">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/23/CSS%E4%B9%8B%E9%9A%BE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%92%8C%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/" class="post-title-link" itemprop="url">CSS之难题解决和知识补充</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-23 23:38:37" itemprop="dateCreated datePublished" datetime="2020-12-23T23:38:37+08:00">2020-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-27 23:14:46" itemprop="dateModified" datetime="2020-12-27T23:14:46+08:00">2020-12-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这里学习一下 CSS 很多的之前没用过的东西</p>
<style>
div{
    margin-bottom:20px;
}
@keyframes ants {
  to {
    background-position: 100%;
  }
}
#test1 {
  height: 200px;
  width: 200px;
  background: linear-gradient(to right, red 50%, blue 50%);
  background-size: 30px 100%;
}
#test2 {
  height: 200px;
  width: 200px;
  background: repeating-linear-gradient(
    45deg,
    red,
    red 15px,
    blue 0,
    blue 30px
  );
}
#test3 {
  height: 200px;
  width: 200px;
  background-color: blue;
  background-size: 30px 30px;
  background-image: linear-gradient(white 1px, transparent 0), linear-gradient(90deg, white
        1px, transparent 0);
}
#test4 {
  height: 200px;
  width: 200px;
  background-color: blue;
  background-size: 30px 30px;
  background-image: radial-gradient(red 30%, transparent 0);
}
#test5 {
  height: 200px;
  width: 200px;
  background-color: blue;
  background-size: 30px 30px;
  background-image: linear-gradient(45deg, red 25%, transparent 0),
    linear-gradient(45deg, transparent 75%, red 0), linear-gradient(
      45deg,
      red 25%,
      transparent 0
    ), linear-gradient(45deg, transparent 75%, red 0);
  background-position: 0 0, 15px 15px, 15px 15px, 0 0;
}
#test6 {
  height: 200px;
  width: 200px;
  background-color: blue;
  background-size: 30px 30px;
  background-image: linear-gradient(
      45deg,
      red 25%,
      transparent 0,
      transparent 75%,
      red 0
    ), linear-gradient(45deg, red 25%, transparent 0, transparent 75%, red 0);

  background-position: 0 0, 15px 15px, 15px 15px, 0 0;
}
#test7 {
  width: 200px;
  height: 100px;
  padding: 20px;
  border: 1px solid transparent;
  background-image: linear-gradient(white, white), repeating-linear-gradient(-45deg, black
        0, black 25%, white 25%, white 50%);
  background-size: 20px 20px;
  background-clip: padding-box, border-box;
  background-position: 0;
  animation: ants 12s linear infinite;
}
#test8 {
  height: 200px;
  width: 300px;
  background-color: blue;
  border-radius: 50%/50%;
}
    </style>

<h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><p>上来就是一个 RGBA 和 HSLA<br>RGBA 都比较熟悉了 A === Alpha 透明度啦<br>HSLA A=== 透明度<br>其实都是颜色 问题不是很大 和前端的关系不大 但是面试可能问到颜色的其他的函数 这里补充一下</p>
<h1 id="border-我不知道的秘密"><a href="#border-我不知道的秘密" class="headerlink" title="border 我不知道的秘密"></a>border 我不知道的秘密</h1><p>border 其实就是边框 但是我们不知道的是 边框默认是会覆盖掉我们的 div 标签内部的东西的<br>这个时候 有一个属性叫做 background-clip<br>顾名思义 这个属性是确定我们的背景是如何进行保留的 三个值</p>
<ul>
<li>padding-box 从 padding 就开始有背景了 这个时候 div 的大小是 content+padding+border</li>
<li>content-box 从 content 才会有背景 这个时候如果设置 padding 那么就是无背景的 padding</li>
<li>border-box border 覆盖背景</li>
</ul>
<p>所以设置外边框 或者是四周的阴影之类的 直接使用 background-clip 设置为 padding-box 然后进行 border 样式的修改就 ok 啦</p>
<p>但是有一个缺点就是 我们只能设置一个边框 如果要多个边框？</p>
<h1 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h1><p>这个属性是 CSS3 的 其实他的原理很简单 就是在我们的盒子模型的后面一层 加上一个指定大小的 颜色色块 我们可以设置这个颜色色块的延伸 可以设置模糊度 可以设置这个颜色色块的位置 以及内阴影还是外阴影 我们甚至可以设置许多个阴影<br>我们只需要设置不同的延伸就行啦 注意必须比前一个大</p>
<h1 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h1><p>设置描边 当然是描边框啦 这个是在边框之外的 但是和边框不同的是 边框是占据大小的 但是 outline 是不占据大小的</p>
<blockquote>
<p>至此为止 我们现在给 div 加上边框有几种办法</p>
<ol>
<li>直接加 border 但是这个时候要注意 border 占据大小</li>
</ol>
</blockquote>
<pre><code>- border-box
- padding-box
- content-box</code></pre>
<blockquote>
<ol start="2">
<li>border 外面套 outline outline 不占据大小</li>
<li>直接 box-shadow 无偏移 伸张量就是大小</li>
<li>多层边框就是多个 box-shadow</li>
</ol>
</blockquote>
<pre><code>- 两个边框可以border+outline</code></pre>
<h1 id="垂直和水平条纹的-CSS-实现"><a href="#垂直和水平条纹的-CSS-实现" class="headerlink" title="垂直和水平条纹的 CSS 实现"></a>垂直和水平条纹的 CSS 实现</h1><p>直接上代码</p>
<div id="test1"></div>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test1</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, red <span class="number">50%</span>, blue <span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 liner-gradient 默认是从下到上 然后偏转的角度是顺时针 或者我们可以直接使用 to right 这种关键字</p>
<div id="test2"></div>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test2</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">repeating-linear-gradient</span>(</span><br><span class="line">    <span class="number">45deg</span>,</span><br><span class="line">    red,</span><br><span class="line">    red <span class="number">15px</span>,</span><br><span class="line">    blue <span class="number">0</span>,</span><br><span class="line">    blue <span class="number">30px</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现桌布-背景"><a href="#实现桌布-背景" class="headerlink" title="实现桌布 背景"></a>实现桌布 背景</h1><blockquote>
<p>桌布就是背景加上分割线啦<br>实际上就是应用了我们的渐变 然后控制我们的线条的渐变控制在 1 2px 也就是线条的粗细 然后紧接着通过控制 background-size 控制我们方格的大小</p>
</blockquote>
<div id="test3"></div>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test3</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(white <span class="number">1px</span>, transparent <span class="number">0</span>), <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, white</span><br><span class="line">        <span class="number">1px</span>, transparent <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现圆点排列"><a href="#实现圆点排列" class="headerlink" title="实现圆点排列"></a>实现圆点排列</h1><div id="test4"></div>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test4</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(red <span class="number">30%</span>, transparent <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里解释一下我们的 radial-gradient 就是从背景的中心进行拓展</p>
<blockquote>
<p>通过多个 background-image 的叠加 我们就可以实现很多种不同的图片</p>
</blockquote>
<h1 id="棋盘布局-国际象棋"><a href="#棋盘布局-国际象棋" class="headerlink" title="棋盘布局 国际象棋"></a>棋盘布局 国际象棋</h1><div id="test5"></div>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test5</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, red <span class="number">25%</span>, transparent <span class="number">0</span>),</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent <span class="number">75%</span>, red <span class="number">0</span>), <span class="built_in">linear-gradient</span>(</span><br><span class="line">      <span class="number">45deg</span>,</span><br><span class="line">      red <span class="number">25%</span>,</span><br><span class="line">      transparent <span class="number">0</span></span><br><span class="line">    ), <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent <span class="number">75%</span>, red <span class="number">0</span>);</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>, <span class="number">15px</span> <span class="number">15px</span>, <span class="number">15px</span> <span class="number">15px</span>, <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是分别构造了 25%的三角形边角 然后原来两张图 不加上 position 是分布在右上角和左下角 然后通过移动我们的 background-image 的 position 用四张图 构成一个 30*30 的重复方块<br>上面当然也可以两个 linear 就搞定</p>
<div id="test6"></div>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test6</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(</span><br><span class="line">      <span class="number">45deg</span>,</span><br><span class="line">      red <span class="number">25%</span>,</span><br><span class="line">      transparent <span class="number">0</span>,</span><br><span class="line">      transparent <span class="number">75%</span>,</span><br><span class="line">      red <span class="number">0</span></span><br><span class="line">    ), <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, red <span class="number">25%</span>, transparent <span class="number">0</span>, transparent <span class="number">75%</span>, red <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>, <span class="number">15px</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题之-实现蚂蚁行军效果"><a href="#面试题之-实现蚂蚁行军效果" class="headerlink" title="面试题之 实现蚂蚁行军效果"></a>面试题之 实现蚂蚁行军效果</h1><p>直接上效果</p>
<div id="test7"></div>
康康代码

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test7</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(white, white), <span class="built_in">repeating-linear-gradient</span>(-<span class="number">45deg</span>, black</span><br><span class="line">        <span class="number">0</span>, black <span class="number">25%</span>, white <span class="number">25%</span>, white <span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background-clip</span>: padding-box, border-box;</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">animation</span>: ants <span class="number">12s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> ants &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">100%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的华点就是 我们首先设置我们的背景颜色是白色 这里的背景是运用到之前我们说的 border-clip 实现的是简单的背景剪切 这样从 padding 开始的背景都是白色<br>然后我们再加多一层背景 运用了之前说到的 linear-gradient 实现了我们的条纹背景 观察上面实现的条纹背景 发现只截取周边的 1px 就形成了我们静态的虚线边框 这个遮盖用的就是我们的 border-box 实现的 背景从 border 开始 这样 padding-box 就会覆盖掉我们的内部的条纹 然后加上一个 animation 就实现了我们的动态效果</p>
<h1 id="实现椭圆半圆角"><a href="#实现椭圆半圆角" class="headerlink" title="实现椭圆半圆角"></a>实现椭圆半圆角</h1><p>我们的 border-radius 可以接受两个值 可以指定两个值 一个是 a 轴 一个 b 轴 期间用/间隔 下面直接上例子</p>
<div id="test8"></div>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test8</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>/<span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是指定了 a 轴和 b 轴 就可以动态绑定我们的椭圆了 这样只要是长度比高度大 那就会自适应变成椭圆</p>
<ul>
<li>我们一般的两个值都是通过/分隔开的</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%84%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9B%BE%E4%B9%8B%E9%82%BB%E6%8E%A5%E8%A1%A8%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhongsihui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dream Starts Here">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%84%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9B%BE%E4%B9%8B%E9%82%BB%E6%8E%A5%E8%A1%A8%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">数据结构预算法之图之邻接表之拓扑排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-23 19:41:17 / Modified: 22:34:23" itemprop="dateCreated datePublished" datetime="2020-12-23T19:41:17+08:00">2020-12-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这里总结一下上一周的数据结构 大体上就是 邻接表的实现 邻接矩阵和邻接表 以及我们的拓扑排序</p>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>拓扑排序可以用于排序我们的有向图 形成一种依赖关系 他的排序原理还可以用于判断一个有向图是不是有环 下面直接上代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 1000</span></span><br><span class="line"><span class="comment">// 边表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> adjvex; <span class="comment">//边指向哪个顶点的索引</span></span><br><span class="line">	<span class="keyword">int</span> weight;</span><br><span class="line">	EdgeNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 顶点表结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VertexNode</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> value; <span class="comment">//顶点的值，为了简化与序号相同，第一个是0</span></span><br><span class="line">	EdgeNode *firstedge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 图结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphList</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	VertexNode adjList[MAXVEX];</span><br><span class="line">	<span class="keyword">int</span> numVertex;</span><br><span class="line">	<span class="keyword">int</span> numEdges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这上面的代码 用于我们的邻接表进行图的储存 这是比较官方的做法 可以背诵 下面是根据上图的数据结构进行的拓扑排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphcircle</span><span class="params">(GraphList *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = g-&gt;numVertex;<span class="comment">//点的个数</span></span><br><span class="line">    <span class="keyword">int</span> visited[size] = &#123;<span class="number">0</span>&#125;;<span class="comment">//访问数组</span></span><br><span class="line">    <span class="keyword">int</span> in[g-&gt;numVertex] = &#123;<span class="number">0</span>&#125;;<span class="comment">//入度数组</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">//已经排序的数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)<span class="comment">//首先我们访问每一个点的邻接表  然后对每一条边的入度进行递增</span></span><br><span class="line">    &#123;</span><br><span class="line">        EdgeNode *move = g-&gt;adjList[i].firstedge;<span class="comment">//第i个点的邻接表的头 因为这里我们邻接表用的是一个链表进行实现 然后保存了表头  这里创建一个我们链表里面常用的move指针</span></span><br><span class="line">        <span class="keyword">while</span> (move)<span class="comment">//遍历这个邻接表</span></span><br><span class="line">        &#123;</span><br><span class="line">            in[move-&gt;adjvex]++;<span class="comment">//入度++</span></span><br><span class="line">            move = move-&gt;next;<span class="comment">//下一个儿</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//看到队列是不是就想到了BFS咧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)<span class="comment">//这个循环 首先是把我们的入度为0的都抓出来 因为我们拓扑排序可以是很多起点呀</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())<span class="comment">//对这个队列里面 已经是入度为0的点进行寻找下一个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> from = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        ans++;<span class="comment">//这里是对排序的结果进行输出 你想咋输出就咋输出  这里是一个妙用 下面会讲到</span></span><br><span class="line">        EdgeNode *move = g-&gt;adjList[from].firstedge;<span class="comment">//访问邻接表</span></span><br><span class="line">        <span class="keyword">while</span> (move)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//if (visited[move-&gt;adjvex] == 0)</span></span><br><span class="line"></span><br><span class="line">            in[move-&gt;adjvex]--;<span class="comment">//删除指向下一个的边 也就是下一个的入度--</span></span><br><span class="line">            <span class="keyword">if</span> (in[move-&gt;adjvex] == <span class="number">0</span>)<span class="comment">//如果入度是0  那么就证明这个就是下一个边啦 加入队列  注意我们这个时候 队列里储存的永远都是入度为0的点</span></span><br><span class="line">            &#123;</span><br><span class="line">                q.push(move-&gt;adjvex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            move = move-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans != g-&gt;numVertex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;has circle&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no circle&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此 我们就有了一个拓扑排序结果的输出的出口了  这里我们对排序的结果进行计数的原因就是 我们如果这个有向图里面是有环的 那么这个排序的数量就不会等于我们的点数了<br>上面的实现 如果变成邻接矩阵 其实也是一样的 直接在矩阵的相应的行里面进行查找就行了</p>
<p>上面实现了我们使用BFS 实现了我们的拓扑排序 然后根据拓扑排序的性质 知道了我们的有向图是否有环下面我们讲一下比较难懂的饿递归的DFS<br>从一道题出发  给定了一个依赖关系 需要判断是否有环 直接上代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="comment">//bool valid = true;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="comment">//输出我们的环</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == v)</span><br><span class="line">            &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (pos; pos &lt; s.size(); pos++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// for (int i = s.size() - 1; i &gt;= 0; i--)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; s[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visited2[u] = <span class="number">1</span>;</span><br><span class="line">        s.push_back(u);</span><br><span class="line">        visited[u] = <span class="number">1</span>;        <span class="comment">//当前路径  访问过当前这个b了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : edges[u]) <span class="comment">//邻接矩阵 的第一个</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) <span class="comment">//没访问过哦</span></span><br><span class="line">            &#123;</span><br><span class="line">                dfs(v); <span class="comment">//深搜！ 进去！</span></span><br><span class="line">                <span class="comment">// if (!valid)</span></span><br><span class="line">                <span class="comment">// &#123;</span></span><br><span class="line">                <span class="comment">//     return;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) <span class="comment">//哦？ 已经访问过了 嗯 环  干他</span></span><br><span class="line">            &#123;</span><br><span class="line">                printStack(v);</span><br><span class="line">                <span class="comment">//return;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">0</span>; <span class="comment">//回溯</span></span><br><span class="line">        s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;prerequisites)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        visited2.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;info : prerequisites)</span><br><span class="line">        &#123;</span><br><span class="line">            edges[info[<span class="number">0</span>]].push_back(info[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; p; <span class="comment">//有12361    012350   0450三个环</span></span><br><span class="line">    p.push_back(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">0</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">3</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">5</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">3</span>, <span class="number">6</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">6</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    s.canFinish(<span class="number">7</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面的思想就是 我们给每一个点加上一个状态  也就是直接在visited数组上面操作就行<br>0 就是从来没有访问过  就是在以当前为起点没有访问过<br>1 就是当前起点已经访问过了  针对一次DFS而言 因为最后会恢复成0</p>
<p>这里面我们要求是输出所有的环 可能就会比较麻烦 我们不能直接返回有环  如果要返回有环 则直接看注释掉的代码<br>这里面的环是有重复的 需要操作一下  怎么操作 我不会~</p>
<p>下面是判断是不是有环</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : edges[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;prerequisites)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        edges.resize(numCourses);</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;info : prerequisites)</span><br><span class="line">        &#123;</span><br><span class="line">            edges[info[<span class="number">0</span>]].push_back(info[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; p;</span><br><span class="line">    p.push_back(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">0</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">3</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">5</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    p.push_back(&#123;<span class="number">4</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    s.canFinish(<span class="number">6</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以 一个是判断有没有环  直接有环返回就行 而且可以剪枝  根据如果深搜之后 全局变量表示没有环 那么就是没有环了也就是说以这个为起点 直接搜到底 没有环 这个点肯定不参与构成环<br>这个算法不能求出所有的环 因为在当前的路走了一遍发现有环之后 不管如何都会置位2 那么再有环经过这里 那么就因为是2 就不会走这里了 2 就是 当前之后 肯定没环！  其实求所有环也可以剪枝 当前之后肯定没环置位2 dfs返回一个bool 而不是一个全局变量搞定 这里脑子不转了 就到这吧<br>讲了DFS和BFS 邻接表 拓扑排序</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/20/JS%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AD%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhongsihui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dream Starts Here">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/20/JS%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96%E5%92%8C%E9%97%AD%E5%8C%85/" class="post-title-link" itemprop="url">JS尾调用优化和闭包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-20 22:25:54" itemprop="dateCreated datePublished" datetime="2020-12-20T22:25:54+08:00">2020-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-22 20:25:43" itemprop="dateModified" datetime="2020-12-22T20:25:43+08:00">2020-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好久没看 JS 了 这里重拾一下 为了准备明年去面试试试水 加油打工人 加油 干饭人 期末考试也要加油</p>
<h1 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h1><p>这里说的尾调用就是 我们的函数的递归调用 一个函数返回的是另外一个函数的返回值 这个时候 ES6 的引擎就会进行尾调用优化 我们学 C++知道 函数调用的时候有一个函数栈 要是递归太多层 那么就会 stack overflow ES6 对这种递归尾调用进行优化的时候就是 比如如下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> innerFunction(); <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当代码执行到 outer 的时候 就会把 outer 的函数 push 进函数栈 然后继续执行 执行到 return 语句的时候 如果没有 ES6 优化 那就是直接 push inner 进函数栈<br>这个时候 ES6 的优化就会发现 这个函数的返回值其实就是 inner 的返回值 这个时候发现吧 outer pop 掉也没有关系 这样就会直接 pop outer 然后 push inner 这样就节省的空间</p>
<h2 id="尾部调用优化的条件"><a href="#尾部调用优化的条件" class="headerlink" title="尾部调用优化的条件"></a>尾部调用优化的条件</h2><ol>
<li>首先得是尾部调用</li>
<li>其次得是严格模式</li>
<li>调用之后没有对返回值进行额外操作 直接进行返回</li>
<li>尾部调用是个闭包<blockquote>
<p>闭包后面再讲 来点例子</p>
</blockquote>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无优化：尾调用没有返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  innerFunction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用没有直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> innerFunctionResult = innerFunction();</span><br><span class="line">  <span class="keyword">return</span> innerFunctionResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用返回后必须转型为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> innerFunction().toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用是一个闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innerFunction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论是不是递归调用 只要是尾部调用 ES6 都会去识别 ES6 没那么聪明 不会去判断是不是递归调用 只要在尾部调用了函数 都叫做尾部调用</p>
<blockquote>
<p>为什么是严格模式 因为如果不是严格模式 那么就可以访问 arguments.callee.caller 这样就会访问前面的函数帧 这样 pop 之后就访问不到了</p>
</blockquote>
<h2 id="补充知识-函数如何判断是不是以-new-关键字进行调用"><a href="#补充知识-函数如何判断是不是以-new-关键字进行调用" class="headerlink" title="补充知识 函数如何判断是不是以 new 关键字进行调用"></a>补充知识 函数如何判断是不是以 new 关键字进行调用</h2><p>函数调用的时候 传入一个名字为 new 的对象 里面有一个 target 属性 如果为 1 的话 那么就是使用 new 关键字进行调用的</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><blockquote>
<blockquote>
<p>听说面试最喜欢这个 这里补充一下<br>闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。比如，下面是之前展示的 createComparisonFunction() 函数</p>
</blockquote>
</blockquote>
<p>函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。</p>
<blockquote>
<p>我们讨论的闭包 其实就是在不同的函数的活动对象里面 通过作用域链 对其他父函数 或者是父对象 的上下文里面的局部变量进行引用 通俗一点讲 就是顺着作用域链找到你家 然后进行访问</p>
</blockquote>
<p>我们知道的垃圾回收的知识 引用计数 只要变量还有被引用 那么垃圾回收装置就不会进行回收 这个时候闭包就会出现这个问题 比如我们下面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value1 = object1[propertyName];        <span class="comment">//引用了propertyName</span></span><br><span class="line">    <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;....&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;....&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="function"><span class="keyword">function</span> = <span class="title">creatComparionFunction</span>(<span class="params"><span class="string">&#x27;aaa&#x27;</span></span>)(<span class="params">obj1,obj2</span>);</span></span><br></pre></td></tr></table></figure>

<p>这里面 这个函数工厂返回的匿名函数引用了 我们传给函数工厂的 propertyName 变量 让我们回顾一下 最后一行代码 首先创建了一个 create 的函数栈 然后创建了这个函数的作用域链 作用域链是根据 这个函数的 scope 进行复制</p>
<ol>
<li>创建作用域链 根据 scope</li>
<li>创建函数的活动对象 活动对象上面有说</li>
<li>把活动对象怼在作用域链的最前端</li>
<li>执行函数</li>
</ol>
<p>这个时候 let function 拿着这个返回的函数 这个函数引用这个 create 的活动对象里面的 propertyName 根据引用计数 这个时候这个函数的活动对象并不会被释放 和我们常常理解的 这个函数执行完之后 就弹出函数栈不同 这就是闭包</p>
<p>当我们执行 function 的时候 这个时候创建的函数活动对象会在 作用域链的 create 的 活动对象前面进行加上 function 本身的活动对象</p>
<blockquote>
<p>总的来说 闭包就是一个上下文里面的一个函数引用了在作用域链上游的变量 导致上游变量的内存因为引用计数的问题不能正确释放</p>
</blockquote>
<h2 id="闭包的面试题"><a href="#闭包的面试题" class="headerlink" title="闭包的面试题"></a>闭包的面试题</h2><blockquote>
<p>这里整理的只是我在网上随手找的 具体的其实还是要实际应用的时候再学习 有一说一 不怕我们对于技术栈的信息量的差异 还是怕我们实际应用的经验的缺失 自己的懒惰以及 我们本身至上的缺陷造就了学习速度的上界 所导致的恶性循环</p>
</blockquote>
<p>IIFE immediately invoked function expression<br>这其实就是为了防止我们的变量外泄 我们需要的就是当前变量只在当前作用域 而且当当前作用域失效之后就进行销毁这个变量 如果我们使用的是 var 变量 这个变量会注册在全局 这样的话 每次我们对这个变量进行取值的时候 就会取得这个在全局作用域的变量 如下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="comment">// 达不到目的！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面很显然 var 被注册在了全局作用 所以每次点击这个 div 的时候 显示的都是 lengtth 这个时候 我们可以使用函数工厂 返回一个回调函数 这个函数工厂接受的变量也是 var 但是只是对当时 var 的值的一个引用 把这个值传进去之后 根据当前 var 的值 进行工厂函数的创建</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>); <span class="comment">//这里面 addEventListener 可以添加到立即执行函数里面  直接传进来一个i  然后数组的i 的event 等于一个function  引用这个i</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(</span><br><span class="line">    <span class="string">&quot;click&quot;</span>,</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">frozenCounter</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//保存在这一行的参数里面</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(frozenCounter);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针不戳 但是注意这里会形成闭包哦 这里是把当前的值传进了函数 保存在了函数的参数里面<br>或者是 直接使用外部的变量 然后使用一个本地的闭包之内的保存下来 这样我们的闭包函数就不用传参了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(</span><br><span class="line">    <span class="string">&quot;click&quot;</span>,</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> frozenCounter = i;</span><br><span class="line">        <span class="built_in">console</span>.log(frozenCounter);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来一道鬼屎题 这里面的 key 在注释里面给出了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n, o</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    fun: <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fun(m, n);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = fun(<span class="number">0</span>);</span><br><span class="line">a.fun(<span class="number">1</span>);</span><br><span class="line">a.fun(<span class="number">2</span>);</span><br><span class="line">a.fun(<span class="number">3</span>); <span class="comment">//undefined,?,?,?</span></span><br><span class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>); <span class="comment">//undefined,?,?,?</span></span><br><span class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>);</span><br><span class="line">c.fun(<span class="number">2</span>);</span><br><span class="line">c.fun(<span class="number">3</span>); <span class="comment">//undefined,?,?,?</span></span><br><span class="line"><span class="comment">//问:三行a,b,c的输出分别是什么？</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>答案是</p>
<ol>
<li>undefined，0,0,0</li>
<li>undefined，0,1,2</li>
<li>undefined，0,1,1</li>
</ol>
</blockquote>
<p>首先执行了 fun(0) 这里面第一个参数是 0 第二个参数没给 所以 console 出来肯定是 undefined 这没啥问题</p>
<p>然后我们返回了一个对象 这个对象里面有一个 key 为 fun 的一个函数 接受一个参数 然后调用 fun 函数 这里面要清楚的是 这个调用的 fun 并不是我们说的递归调用 递归调用的函数必须是 arguments.callee 或者是非匿名函数 所以这里面调用的 fun 只能是有名字的 最外层的 fun</p>
<p>到现在为止 执行完 fun(0) 我们得到了一个对象 这个对象里面有一个 key 为 fun 的函数 这个函数接受一个参数 加上我们的 n 参数作为第二个参数 调用最外层的 fun 进行返回</p>
<p>执行了 fun(0) a 为返回的对象 执行 a.fun(1) 这个时候 1 作为我们 a 这个对象的 fun 函数的唯一参数 然后调用最外层的 fun 函数 作为 第一个参数 第二个参数 n 从哪里来呢？ 这里就是闭包的概念</p>
<p>我们一开始传入一个 0 作为最外层 fun 函数的第一个参数 n 因为我们 return 的这个对象里 还有对于 n 这个参数的引用 根据引用计数的内存回收原则 这个 n 还是会被保留在函数的作用域链里面 这个时候 当我们这个 1 作为第一个参数 第二个参数 n 就会从作用域链里面去找 就会找到原来闭包的时候的传入的那个 n 也就是 0 这个时候 console 出来的第二个参数就是 n 就是我们一开始创建闭包的那个 0 所以无论我们这个闭包产生的对象调用的函数的参数是什么 第二个参数永远都是我们产生闭包的时候的那个 0</p>
<p>后面两个 在执行完 fun(0)之后产生了第一题的 a 然后执行 fun(0).fun(1) 就相当于 a.fun(1) 输出还是 0</p>
<p>但是这个时候再执行这个函数的返回值的时候 这个时候回去找的第二个参数 n 就是我们上一层闭包传进去的第一个参数 n 上一层闭包传进去的第一个参数 刚好就是我们的 key 为 fun 的函数传进去的 m 参数 也就是 1 啦 这里好好理解一下 我懒得讲了 第一个能理解 进行一下解耦合 后面的都不难其实</p>
<h2 id="闭包作为私有方法和变量的创建方法"><a href="#闭包作为私有方法和变量的创建方法" class="headerlink" title="闭包作为私有方法和变量的创建方法"></a>闭包作为私有方法和变量的创建方法</h2><p>这里比如说我们需要一个计数器 当然可以声明一个计数器变量 但是当我们需要很多计数器的时候呢<br>这个时候 我们就可以使用闭包 把一个计数的变量放在闭包的私有变量里面 然后对外暴露一个++ 的函数 相当于在构造函数里面使用了闭包 就是我们产生的新的对象 对构造函数里面的变量进行了引用 这样 构造函数的局部变量的引用计数就不会是 0 这样就可以进行访问了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.getCount = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cnt = <span class="keyword">new</span> Counter();</span><br><span class="line">cnt.add(); <span class="comment">//1</span></span><br><span class="line">cnt.add(); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(cnt.getCount()); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(cnt.count); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>上面的这个例子 就是我们在创建 Counter 的时候 对每一个 Counter 维护了一个 count 因为不是 this.xx 所以不能进行成员访问 对外是私有的</p>
<p>我们也可以创建一个共享的私有变量 通过一个立即执行函数 创建一个函数栈进行闭包保留我们这些私有的 共享的变量以及方法 为什么是立即执行函数呢 首先 为什么是立即 因为是只执行一次 其次为什么是函数 因为要使用函数的作用域链 根据引用计数不为 0 保留我们的私有变量和函数 上例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有函数 不属于任何 但是可以在这个函数里面进行赋值或者作为子函数调用  只有在当前块可以访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构造函数 这里会直接注册在global</span></span><br><span class="line">  MyObject = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="comment">// 公有和特权方法</span></span><br><span class="line">  MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//操作原型链</span></span><br><span class="line">    privateVariable++;</span><br><span class="line">    <span class="built_in">console</span>.log(privateVariable);</span><br><span class="line">    <span class="keyword">return</span> privateFunction();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(); <span class="comment">//立即执行</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> MyObject();</span><br><span class="line"><span class="built_in">console</span>.log(a.publicMethod()); <span class="comment">//11  false</span></span><br><span class="line"><span class="built_in">console</span>.log(a.publicMethod()); <span class="comment">//12  false</span></span><br></pre></td></tr></table></figure>

<p>表明都是公有的啊 都是三维的</p>
<p>over！ 面试希望闭包无敌</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9C%9F%E6%9C%AB%E4%B8%B4%E6%97%B6%E6%8A%B1%E4%BD%9B%E8%84%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhongsihui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dream Starts Here">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9C%9F%E6%9C%AB%E4%B8%B4%E6%97%B6%E6%8A%B1%E4%BD%9B%E8%84%9A/" class="post-title-link" itemprop="url">计算机组成原理之期末临时抱佛脚</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-14 11:22:40 / Modified: 15:44:21" itemprop="dateCreated datePublished" datetime="2020-12-14T11:22:40+08:00">2020-12-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>临时抱佛脚 不知道还来不来得及  只记录了觉得记不住的东西</p>
<h1 id="第一章-计算机概要"><a href="#第一章-计算机概要" class="headerlink" title="第一章 计算机概要"></a>第一章 计算机概要</h1><h2 id="主储存器-运行内存"><a href="#主储存器-运行内存" class="headerlink" title="主储存器 运行内存~"></a>主储存器 运行内存~</h2><p>储存器的结构<br>DRAM dynamic random access memory 动态随机存取存储器  访问不同的地址的数据的速度都是一样的 在断电之后 数据消失<br>SRAM static ~ 速度更快  相当于DRAM里面的缓存  具体效果可以参考CPU的三级缓存  越高级 越快 越小 越贵</p>
<p>以上都是我们断电之后就会消失的储存器<br>当然还有断电之后不会消失的储存器 磁盘  我们把会消失的叫做主储存器 后者叫做二级储存器</p>
<h2 id="二级储存器-硬盘和闪存"><a href="#二级储存器-硬盘和闪存" class="headerlink" title="二级储存器 硬盘和闪存"></a>二级储存器 硬盘和闪存</h2><p>闪存就是比硬盘小 比硬盘快 比硬盘贵  而且不会断电消失</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU当然讲究性能<br>性能的两个度量指标<br>execution time 响应时间<br>bandwidth   吞吐率<br>性能之比就是执行相同的程序所需要的时间之比的倒数</p>
<h2 id="CPU性能"><a href="#CPU性能" class="headerlink" title="CPU性能"></a>CPU性能</h2><p>时钟周期       时钟周期就是CPU的上升沿和下降沿的时间差 这里不同的CPU有不同的时钟周期<br>CPI         cycle per instruction  平均每一条指令需要的时钟周期<br>指令数          从高级语言编译成汇编语言的数目<br>CPU频率         就是我们买的时候看到的GHz =  1/时钟周期</p>
<p><span style='color:red; font-size:30px'>key：       T = N * CPI / CPU频率 = N * CPI * 时钟周期 </span></p>
<h1 id="第二章-计算机指令"><a href="#第二章-计算机指令" class="headerlink" title="第二章 计算机指令"></a>第二章 计算机指令</h1><p>我们的指令一般是从op code和funct code 就能知道是什么操作<br>从op code 知道后面的指令的分割方法  有不同类型的指令</p>
<p>R type指令<br>op code 一般是0    re  rt 代表source寄存器 rd 是把结果储存的寄存器 shamt是移位  func 就是function code</p>
<table>
<thead>
<tr>
<th align="center">op (6)</th>
<th align="center">rs (5)</th>
<th align="center">rt (5)</th>
<th align="center">rd (5)</th>
<th align="center">shamt (5)</th>
<th align="center">func (6)</th>
</tr>
</thead>
</table>
<h2 id="转移地址表"><a href="#转移地址表" class="headerlink" title="转移地址表"></a>转移地址表</h2><p>就是把我们mips代码里面的前面的标签 转换成一个类似于map的数据结构<br>然后  每次进行branch  或者是j  jr的时候 就会在这个map里面 用标签作为key 去查找map里面的值 然后load 地址到寄存器里面  然后再跳转到寄存器的储存的地址</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8Bkmp%E7%AE%97%E6%B3%95%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhongsihui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dream Starts Here">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8Bkmp%E7%AE%97%E6%B3%95%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/" class="post-title-link" itemprop="url">数据结构与算法之kmp算法和哈夫曼树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-10 20:39:07 / Modified: 21:11:31" itemprop="dateCreated datePublished" datetime="2020-12-10T20:39:07+08:00">2020-12-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天数据结构课实验整了两个新东西 这里总结一下</p>
<h1 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h1><p>明明在讲图 突然来个字符串 不知道助教是怎么想的<br>kmp算法  其实实现的就是 从一个字符串里面寻找另外一个字符串是不是他的子串 按照我们暴力的解法 我们可以使用两个指针 从source和target两个字符串里面开始遍历 如果匹配的话 那么就继续 如果遍历到了target的尾部 那就证明找到成功 返回source指针的减去target长度的位置<br>如果发现有一个字符不匹配的话 那么两个指针都需要回退 回退的长度是target指针移动的长度<br>但是我们这里发现 如果发现不匹配了 那么之前匹配的结果可以继续利用 不需要全部回退完<br>这里可以利用的部分就是 我们的target字符串其中  后缀和前缀的重合度  比如说<br>ABCDEFG<b>ABKAB</b>UI<b>ABKABD</b>BB<br>ABKABD<br>这里面 当我们匹配前面的ABKAB的之后 下一个字母U  不是D 所以不匹配<br>如果按照暴力  这个时候应该是退回到B  target退回到A<br>但是这个时候 kmp算法就说 我们可以 只回退tar的指针 不回退source 的指针 为什么呢  其实就是 我们发现其中已经有字符不匹配的时候 我们就在已经匹配的字符里面去找可能成为开头的字符 什么意思呢 就是比如我们已经匹配的ABKAB  这个时候发现D不匹配 我们在ABKAB里面去找可能为tar开头的字符<br>因为匹配的字符我们是知道的  所以我们就可以直接知道当前字符串tar只需要回退多少格  而不是都重来<br>我们给每一个tar的字符的位置都给了一个匹配上的表 代表着当前我们如果匹配不上 那么tar 指针需要回退多少格 就不用再次匹配我们已经知道的 匹配过的头了<br>这个算法的核心就是  找到这个数组 对应着tar的每一个字符的匹配值<br>通俗的讲  就是求前缀和后缀的交集的最长的长度<br>直接上代码吧</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10000</span>];   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">(<span class="keyword">char</span>* t)</span> </span>&#123;        <span class="comment">//求这个数组  具体的方法见代码 我自己理解不是很透彻 </span></span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> (j &lt; <span class="built_in">strlen</span>(t) - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span> || t[j] == t[k]) &#123;</span><br><span class="line">      j++;</span><br><span class="line">      k++;</span><br><span class="line">      a[j] = k;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      k = a[k];     <span class="comment">//同一个子串里面用了kmp  妙  我讲不清楚</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span> *x, <span class="keyword">char</span> *y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    next(x);</span><br><span class="line">    <span class="keyword">int</span> len1=<span class="built_in">strlen</span>(y);</span><br><span class="line">    <span class="keyword">int</span> len2=<span class="built_in">strlen</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len1&amp;&amp;j&lt;len2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||y[i]==x[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j=a[j];<span class="comment">//如果不匹配 那么就回退到我们记录的地方 sourcce不用回退</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=len2)</span><br><span class="line">        <span class="keyword">return</span> i-len2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>哈夫曼树就是 最优树  每一个叶子节点有不同的权值 叶子节点的权值乘以到叶子的路径长度的值最小 我们称之为哈夫曼树 用于压缩算法  对不同出现频率的进行编码  出现频率高的就在树的比较靠近根节点的位置 出现频率低的就在远离根节点的位置</p>
<h2 id="构建哈弗曼树的原理"><a href="#构建哈弗曼树的原理" class="headerlink" title="构建哈弗曼树的原理"></a>构建哈弗曼树的原理</h2><p>首先每一个字符对应着一个权值  构成一个数组  我们每一次取出两个权值最小的字符 将他们从队列里面剔除  然后连成一个新的节点的二叉树  然后push进数组 权值为二者权值的和  重复这个过程<br>使用优先队列可以轻易每次得到最小的两个 然后push就完事了 具体不是很难</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>         //这里面节点储存着<span class="title">char</span>和权值</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    Node(<span class="keyword">long</span> <span class="keyword">long</span> val, <span class="keyword">char</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">        left = <span class="literal">NULL</span>;</span><br><span class="line">        right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node *a, <span class="keyword">const</span> Node *b)</span> <span class="keyword">const</span><span class="comment">//比较函数  注意这里的操作符是()  包装在一个结构体里面</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node *root, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;path)</span><span class="comment">//后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postorder(root-&gt;left, path);</span><br><span class="line">        postorder(root-&gt;right, path);</span><br><span class="line">        path.push_back(root-&gt;a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Node *, <span class="built_in">vector</span>&lt;Node *&gt;, cmp&gt; pq;<span class="comment">//优先队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">        Node *t = <span class="keyword">new</span> Node(val, a);<span class="comment">//cin初始化</span></span><br><span class="line">        pq.push(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pq.size() == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pq.top()-&gt;val &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//边缘检测</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node *a = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        Node *b = pq.top();</span><br><span class="line">        pq.pop();<span class="comment">//抓头 两个 并且pop</span></span><br><span class="line">        Node *sum = <span class="keyword">new</span> Node(a-&gt;val + b-&gt;val, <span class="string">&#x27; &#x27;</span>);<span class="comment">//把和抓紧去 并且push</span></span><br><span class="line">        <span class="keyword">if</span> (a-&gt;val &lt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            sum-&gt;left = b;</span><br><span class="line">            sum-&gt;right = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a-&gt;val &gt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            sum-&gt;right = b;</span><br><span class="line">            sum-&gt;left = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a-&gt;val == b-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a-&gt;a &lt; b-&gt;a)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum-&gt;left = b;</span><br><span class="line">                    sum-&gt;right = a;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    sum-&gt;right = b;</span><br><span class="line">                    sum-&gt;left = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       <span class="comment">//这谁在左边谁在右边自己定</span></span><br><span class="line">        root = sum;<span class="comment">//每一次更新树根 因为最后会连成一整棵树 得到的就是root</span></span><br><span class="line">        pq.push(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ans;</span><br><span class="line">    postorder(root, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : ans)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到此结束</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A1%A5%E5%85%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhongsihui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dream Starts Here">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A1%A5%E5%85%85/" class="post-title-link" itemprop="url">数据结构与算法之二叉树补充</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-09 23:50:31 / Modified: 23:59:34" itemprop="dateCreated datePublished" datetime="2020-12-09T23:50:31+08:00">2020-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天翻看代码 发现二叉树的三种遍历还没怼上去 这里说的都是非递归版本 别问 问就是上流 这里补充一下  顺便总结一下最近的烂东西</p>
<h1 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> s = [];</span><br><span class="line">    <span class="keyword">let</span> move = root;</span><br><span class="line">    <span class="keyword">while</span> (move || s.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (move) &#123;</span><br><span class="line">            res.push(move.val);</span><br><span class="line">            s.push(move);</span><br><span class="line">            move = move.left;</span><br><span class="line">        &#125;</span><br><span class="line">        move = s.pop();</span><br><span class="line"></span><br><span class="line">        move = move.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> s = [];</span><br><span class="line">    <span class="keyword">let</span> move = root;</span><br><span class="line">    <span class="keyword">while</span> (move || s.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (move) &#123;</span><br><span class="line">            s.push(move);</span><br><span class="line">            move = move.left;</span><br><span class="line">        &#125;</span><br><span class="line">        move = s.pop();</span><br><span class="line">        res.push(move.val);</span><br><span class="line">        move = move.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h1><p>这里面有两种方法 两种都是基于栈 这里面因为是后序遍历  我们需要记录当前的点是否已经被访问过  这里有两种方法 一种是增加一个last指针 另外一种就是push两次  pop的时候判断是不是在栈里面 直接上代码</p>
<h2 id="基于last指针的后续遍历"><a href="#基于last指针的后续遍历" class="headerlink" title="基于last指针的后续遍历"></a>基于last指针的后续遍历</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> s = [];</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> last = root;</span><br><span class="line">    <span class="keyword">let</span> move = root;</span><br><span class="line">    s.push(move);</span><br><span class="line">    <span class="keyword">while</span> (s.length != <span class="number">0</span>) &#123;</span><br><span class="line">        move = s[s.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> ((move.left === <span class="literal">null</span> &amp;&amp; move.right === <span class="literal">null</span>) || (last == move.left &amp;&amp; move.right === <span class="literal">null</span>) || last == move.right) &#123;</span><br><span class="line">            res.push(move.val);</span><br><span class="line">            last = move;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (move.right) &#123;</span><br><span class="line">                s.push(move.right);    <span class="comment">//这里注意 因为是后序遍历 先访问左边 再是右边 所以栈顶应该是左边  所以左边后入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (move.left) &#123;</span><br><span class="line">                s.push(move.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="基于双push-pop的后续遍历"><a href="#基于双push-pop的后续遍历" class="headerlink" title="基于双push pop的后续遍历"></a>基于双push pop的后续遍历</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal_two_push = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> s = [];</span><br><span class="line">    <span class="keyword">let</span> move = root;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> [];    <span class="comment">//这一行的作用是 如果是空的 那么root进栈之后 访问他的left就会出错  因为null没有left</span></span><br><span class="line">    s.push(root);</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (s.length != <span class="number">0</span>) &#123;</span><br><span class="line">        move = s.pop();</span><br><span class="line">        <span class="keyword">if</span> (move != s[s.length - <span class="number">1</span>] || s.length == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push(move.val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (move.right) &#123;           <span class="comment">//没错 就是这里</span></span><br><span class="line">                s.push(move.right);    </span><br><span class="line">                s.push(move.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (move.left) &#123;</span><br><span class="line">                s.push(move.left);      <span class="comment">//注意 这里也是right先进栈  然后 left再进  </span></span><br><span class="line">                s.push(move.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="这里说一下前端CSS的flex"><a href="#这里说一下前端CSS的flex" class="headerlink" title="这里说一下前端CSS的flex"></a>这里说一下前端CSS的flex</h1><p>如果是左右布局 一左一右  左边的宽度需要自适应 参考如下代码</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  .left&#123;</span><br><span class="line">    <span class="selector-tag">flex</span>: 1;</span><br><span class="line">    <span class="selector-tag">margin-right</span><span class="selector-pseudo">:auto</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%8A%98%E7%A3%A8%E7%8E%8B-%E5%9B%BE%E5%88%9D%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhongsihui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dream Starts Here">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%8A%98%E7%A3%A8%E7%8E%8B-%E5%9B%BE%E5%88%9D%E6%AD%A5/" class="post-title-link" itemprop="url">数据结构与算法折磨王--图初步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-03 21:50:27 / Modified: 22:58:52" itemprop="dateCreated datePublished" datetime="2020-12-03T21:50:27+08:00">2020-12-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天数据结构老师给了图 这里总结一下自己完全不会的东西 - -</p>
<h1 id="Valid-BFS"><a href="#Valid-BFS" class="headerlink" title="Valid BFS"></a>Valid BFS</h1><p>这一题意思就是 给定一系列的边的父亲和儿子节点 按照顺序 然后给定了一串序列  要判定当前序列是不是按照BFS输出  重点是 这里的BFS不是我们常说的二叉树的BFS 这里的是  我们首先取出这个队列的头 然后这个头的两个子节点 我们按照任意的顺序 push到这个队列里面 注意 这里重点是任意的顺序 而不是我们常说的 从左到右  所以这里我们不能直接BFS 然后比较  我们要使用双指针模仿我们的BFS  也就是我们当前的慢指针 就是我们的队列头 然后我们在BFS的时候 会把这个队列头插入队列里面 然后我们输出的顺序就是按照这个队列 那么我们的快指针就可以判断当前的值是不是慢指针的邻居 如果是的话 那就移动向下一个 直到当前快指针不是当前慢指针的儿子节点  这个判断是不是儿子节点我们可以通过map进行储存  如果是的话 那么map的值就是1嗯  然后如果是BFS正确结果的话 那么应该这个快指针可以直接遍历到尾巴 上代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp[maxN]; <span class="comment">//用来储存是不是有效的边 注意这里是数组哦</span></span><br><span class="line"><span class="keyword">int</span> q[maxN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="comment">//这里面只要n-1条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        mp[u][v]  = <span class="number">1</span>; <span class="comment">//这里面保存的是两个顶点是不是有边  如果有的话 那就是正常的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//目标数组</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line">    <span class="keyword">if</span> (q[<span class="number">1</span>] == <span class="number">1</span>) <span class="comment">//如果第一个头不是1  那就是题目傻逼</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>;        <span class="comment">//快慢指针 这里面也就是双指针   这里是重点 我们这里定义的bfs是 每一次从队列里面抓出第一个</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//然后按照任意顺序去插入他的邻居到队列 这里面的任意和我们的先左后右是不一样的 这就是这题的难点</span></span><br><span class="line">            <span class="keyword">for</span> (j; mp[q[i]][q[j]]; ++j)</span><br><span class="line">                ;</span><br><span class="line">        <span class="keyword">if</span> (j == n + <span class="number">1</span>)<span class="comment">//如果遍历到最后 那就是yes</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一题看起来没那么复杂 还是可以写的 那么下面呢？</p>
<h1 id="Obsession-with-Robots"><a href="#Obsession-with-Robots" class="headerlink" title="Obsession with Robots"></a>Obsession with Robots</h1><p>题目讲的就是 有一个机器人 在一个无限大的地图上面跑  然后给定了操作 比如说 U就是往前走 R L就是左走右走  然后到达一个坐标 问你这个机器人到达这个目的地是不是最短距离  意思就是 这个机器人走的路线有没有捷径可以让自己走的更短 我们简单地理解都是 路径有没有成环的地方 如果有 那就证明有捷径（其实不一定 如果这个环上面和下面路径一样长）  所以不能判断是不是成环 应该判断是不是有捷径 直接上代码  这里我们使用的也是BFS 上面讲述了BFS的原理 然后比较无聊的问了不同的顺序push进队列 基本没有什么实用价值 下面我们就是使用正常的BFS 解题<br>BFS究竟用在什么地方呢？ 其实就是 当前的一个状态 我们有很多个操作可以达到子状态的时候  我们去遍历这一些子状态  通过队列进行遍历  还有就是图的比较简单地非递归遍历  我们这里的机器人就是 当前我们可以上下左右4个状态 我们就需要BFS这四种状态 然后判断是不是已经访问过之类的然后进行push进队列  上代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> M[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> T[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)<span class="comment">//初始化一个图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; j++)</span><br><span class="line">            M[i][j] = <span class="number">1</span>;<span class="comment">//全是障碍</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;<span class="comment">//输入路径</span></span><br><span class="line">    <span class="keyword">int</span> nowx = maxn / <span class="number">2</span>, nowy = maxn / <span class="number">2</span>;<span class="comment">//让这个B从图的中央开始走</span></span><br><span class="line">    M[nowx][nowy] = <span class="number">0</span>;<span class="comment">//开路  一开始的nowx 和nowy  就是开路</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (s[i])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            nowy++;</span><br><span class="line">            M[nowx][nowy] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">            nowx++;</span><br><span class="line">            M[nowx][nowy] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            nowx--;</span><br><span class="line">            M[nowx][nowy] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">            nowy--;</span><br><span class="line">            M[nowx][nowy] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//这里面走完这个图 开完路</span></span><br><span class="line">    <span class="keyword">int</span> enx = nowx, eny = nowy;</span><br><span class="line">    nowx = maxn / <span class="number">2</span>, nowy = maxn / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">    Q.push(<span class="built_in">make_pair</span>(nowx, nowy));</span><br><span class="line">    vis[nowx][nowy] = <span class="number">1</span>;        <span class="comment">//从头开始 已经访问过了</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())      <span class="comment">//跑bfs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; next = now;</span><br><span class="line">            <span class="keyword">switch</span> (i)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                next.first += <span class="number">1</span>;</span><br><span class="line">                next.second += <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                next.first += <span class="number">-1</span>;</span><br><span class="line">                next.second += <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                next.first += <span class="number">0</span>;</span><br><span class="line">                next.second += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                next.first += <span class="number">0</span>;</span><br><span class="line">                next.second += <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (vis[next.first][next.second])<span class="comment">//拜访过就下一个</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (M[next.first][next.second])<span class="comment">//障碍就下一个 证明没开路</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            T[next.first][next.second] = T[now.first][now.second] + <span class="number">1</span>;<span class="comment">//路程</span></span><br><span class="line">            vis[next.first][next.second] = <span class="number">1</span>;</span><br><span class="line">            Q.push(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T[enx][eny] &lt; s.size())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BUG&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里面的问题就是 这个机器人走的路径到底是不是最短的 也就是说有没有成环 就是从一开始走的时候  BFS就是把当前可能走到的位置直接标记了  比如我一开始就有捷径</span></span><br><span class="line"><span class="comment">可以走到我后面路径的位置  这个位置不是障碍物  然后标记是拜访过  然后就去这个地方  那么到时候在队列里面处理这个地方的时候 距离就是这个捷径+1 那么到终点的</span></span><br><span class="line"><span class="comment">距离就不是我们给的路径了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这里面是如何保证路径是最小的呢  因为我们是从头开始BFS的 有捷径就会先访问 这里也是BFS的优点</p>
<h1 id="Number-Clicker（双向BFS）"><a href="#Number-Clicker（双向BFS）" class="headerlink" title="Number Clicker（双向BFS）"></a>Number Clicker（双向BFS）</h1><p>嗯 双向BFS  听起来很牛逼 但是我们只要选好了数据结构 也没那么难  上面第一个 我们选择了MAP进行储存是不是当前两个点有边  第二个用了二维数组 进行储存我们走过的路径  二维数组更好体现了我们的路径 map体现的是边<br>这一题的意思就是给定两个数字 然后还有一个常数  然后第一个数字可以经过3种运算之后  得到第二个数字 问我们最少的操作数  还要输出我们是经过什么顺序的那种操作  这里我们肯定不能一次性在数组里面push 和pop  我们应该进行BFS然后储存当前的状态  这个状态包含什么呢 包含了我们上一个状态 上一个状态用了什么操作到当前状态  以及当前的步骤数 这里我们的key就是当前的状态 那就是map啦 储存一个struct 上代码  然后我们进行双向BFS  一边步骤数是减的 而且是负数 这里也是华点 然后我们从结果和开始双向BFS  然后如果当前的下一个状态已经被访问过了 那么就是相遇了 为什么呢 因为我们是BFS  具体的情况代码里说</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>//这里记录的是 当前的这个数字的  前身 以及前面用的是什么<span class="title">button</span> 和第几步</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> step, but;</span><br><span class="line">    LL pre;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;LL, Node&gt; path;<span class="comment">//这里建立的就是这个表 当前的LL对应的状态</span></span><br><span class="line">LL u, v, p;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">fpow</span><span class="params">(LL a, LL n)</span><span class="comment">//好家伙 快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            res = (res * a) % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(LL a, LL b, <span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, path[a].step - <span class="number">1</span> - path[b].step);</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">while</span> (a != u)</span><br><span class="line">    &#123;</span><br><span class="line">        Node ap = path[a];</span><br><span class="line">        S.push(ap.but);</span><br><span class="line">        a = ap.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, op);</span><br><span class="line">    <span class="keyword">while</span> (b != v)</span><br><span class="line">    &#123;</span><br><span class="line">        Node bp = path[b];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, bp.but);</span><br><span class="line">        b = bp.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    path.clear();</span><br><span class="line">    path[u] = (Node)&#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;<span class="comment">//双向BFS  为什么这里是BFS呢  其实BFS代表的就是 如果当前有很多个操作的状态 那么就我们需要记录每一种状态可能的结果  然后加入队列 等下下一轮的遍历</span></span><br><span class="line">    path[v] = (Node)&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;<span class="comment">//BFS的另一头</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;LL&gt; qf, qb;<span class="comment">//两个BFS的待处理的队列</span></span><br><span class="line">    qf.push(u);</span><br><span class="line">    qb.push(v);</span><br><span class="line">    <span class="keyword">while</span> (!qf.empty() || !qb.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!qf.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            LL x = qf.front();<span class="comment">//抓头</span></span><br><span class="line">            qf.pop();</span><br><span class="line">            Node xp = path[x];<span class="comment">//抓出当前这个头的状态</span></span><br><span class="line">            LL next = (x + <span class="number">1</span>) % p;<span class="comment">//第一个操作</span></span><br><span class="line">            Node np = path[next];<span class="comment">//map 如果没创建 那么就是0</span></span><br><span class="line">            <span class="keyword">if</span> (np.step == <span class="number">0</span>)</span><br><span class="line">            &#123; <span class="comment">//未访问</span></span><br><span class="line">                path[next] = (Node)&#123;xp.step + <span class="number">1</span>, <span class="number">1</span>, x&#125;;<span class="comment">//这个button之后的值的状态就是  步骤是+1  然后 使用的button就是1 x就是我们之前的</span></span><br><span class="line">                qf.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &lt; <span class="number">0</span>)<span class="comment">//当前的这个值的状态已经被初始化过了 那就是相遇啦  这里我们是可以保证是最短的 怎么说呢 想象一个树  每一层的状态*3  每一层代表了一个步骤  那么从上往下 这个的数的交点肯定是最小的 不可能绕弯路</span></span><br><span class="line">            &#123; <span class="comment">//相遇</span></span><br><span class="line">                Print(x, next, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next = (x + p - <span class="number">1</span>) % p; <span class="comment">//op2</span></span><br><span class="line">            np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (np.step == <span class="number">0</span>)<span class="comment">//这里也是华点  我们这里首先判断是不是访问过  如果不是 那就是第一次访问 然后因为是BFS  第一次访问肯定是最短的距离 所以直接保存</span></span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step + <span class="number">1</span>, <span class="number">2</span>, x&#125;;</span><br><span class="line">                qf.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &lt; <span class="number">0</span>)<span class="comment">//要是已经被保存过了  这里判断是不是相遇不是通过是不是已经保存 而是判断当前的step是不是和自己符号相反 因为如果是符号相同的话 那么现在的步骤肯定是比之前要多的 因为是BFS  如果符号相同 直接舍弃当前结果</span></span><br><span class="line">            &#123;</span><br><span class="line">                Print(x, next, <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next = fpow(x, p - <span class="number">2</span>);</span><br><span class="line">            np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (np.step == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step + <span class="number">1</span>, <span class="number">3</span>, x&#125;;</span><br><span class="line">                qf.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Print(x, next, <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!qb.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            LL x = qb.front();</span><br><span class="line">            qb.pop();</span><br><span class="line">            Node xp = path[x];</span><br><span class="line"></span><br><span class="line">            LL next = (x + p - <span class="number">1</span>) % p;</span><br><span class="line">            Node np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (!np.step)</span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step - <span class="number">1</span>, <span class="number">1</span>, x&#125;;</span><br><span class="line">                qb.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Print(next, x, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next = (x + <span class="number">1</span>) % p;</span><br><span class="line">            np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (!np.step)</span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step - <span class="number">1</span>, <span class="number">2</span>, x&#125;;</span><br><span class="line">                qb.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Print(next, x, <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next = fpow(x, p - <span class="number">2</span>);</span><br><span class="line">            np = path[next];</span><br><span class="line">            <span class="keyword">if</span> (!np.step)</span><br><span class="line">            &#123;</span><br><span class="line">                path[next] = (Node)&#123;xp.step - <span class="number">1</span>, <span class="number">3</span>, x&#125;;</span><br><span class="line">                qb.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (np.step &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Print(next, x, <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, tmp, T;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;u, &amp;v, &amp;p) == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (u == v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BFS();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>好了以上就是我们的全部内容了 其实今天有4题  我只看懂了3题  嗯  只写了3题 另外一个是树形DP 我爪巴</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhongsihui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dream Starts Here">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">互联网协议入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-01 21:18:19 / Modified: 23:28:39" itemprop="dateCreated datePublished" datetime="2020-12-01T21:18:19+08:00">2020-12-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="互联网协议"><a href="#互联网协议" class="headerlink" title="互联网协议"></a>互联网协议</h1><p>今天体侧+打球 没写算法题 总结一下互联网协议安慰一下自己<br>互联网协议分为很多层 我们先讲互联网的五层模型 里面的一些细节可以再分 分为七层 我们先讲五层 互联网的层级 每一层负责不同的通讯 他们的好处就是 层与层之间可以互不干扰的进行运转 这也是计算机自顶向下的一种封装吧 每一个层专注于自己的事 然后暴露好接口 上面的层只管调用这种接口就行啦</p>
<img src="/2020/12/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/wuceng.png" class="" title="This is an example image">

<h2 id="实体层和链接层"><a href="#实体层和链接层" class="headerlink" title="实体层和链接层"></a>实体层和链接层</h2><p>链接层实际上就是网卡之间的通信 通过找寻到 mac 地址 然后进行数据的传输 那么我们一般是通过 DNS 解析器 知道了目标主机的 ip 地址 但是我们实体层的传输是需要 mac 地址的 我们怎么知道 mac 地址呢<br>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的 MAC 地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p>
<p>第二种情况，如果两台主机在同一个子网络，那么我们可以用 ARP 协议，得到对方的 MAC 地址。ARP 协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的 IP 地址，在对方的 MAC 地址这一栏，填的是 FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出 IP 地址，与自身的 IP 地址进行比较。如果两者相同，都做出回复，向对方报告自己的 MAC 地址，否则就丢弃这个包。</p>
<p>总之，有了 ARP 协议之后，我们就可以得到同一个子网络内的主机 MAC 地址，可以把数据包发送到任意一台主机之上了。</p>
<p>到目前为止 我们解决了任意两台机器的传输问题 我们首先会看这个以太网的头 然后判断这个 ip 地址是不是属于同一个子网（利用子网掩码） 这个时候我们是不知道这个目的地的 mac 地址的 我们只能通过 ip 地址知道目前是在一个子网 现在我们要获取 mac 地址才能通讯啊 怎么获取呢 通过我们的 ARP 协议 上面提到过啦 要是不在同一个子网 那就直接发给网关 网关通过路由之类的 传输到目的地的子网 然后目的地的子网 嗯 这个时候通过子网掩码 就知道这个目的地是同一个子网啦 然后再通过 ARP 协议 获取 mac 地址 然后再进行通讯</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>我们现在的通讯 是通过 mac 地址进行两个机子的通讯 上文提到了 ip 和网关 这实际上是网络层之间的关系 上面的连接层和实体层更多的是在子网络 比如一个计算机机房 但是如果是上海的机子和广州的机子 那怎么办咧</p>
<p>必须找到一种方法，能够区分哪些 MAC 地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC 地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p>
<p>那么不同子网之间怎么进行连接呢 这个时候 我们就约定了一个地址 和一个 ip 协议 通过这个协议我们就可以在不同的子网之间进行通讯<br>ip 分为 v4 和 v6 代表着不同的协议 这里我们讲 v4 我们的 ip 层 ip 可以指定相对应的主机 不仅仅是 mac mac 只是在实体层进行数据传输 但是 ip 也可以确定是哪一个主机 在网络层我们在数据包里面再封装一个 ip 层的数据头 包含了目标 ip 和源 ip<br>在网络层 我们的主机会用子网掩码 判断是不是在当前子网 如果是 那就直接用 ARP 找到 mac 然后进行实体层的传输 如果不是 那么目的的 mac 就是网关 网关拿到这个 ip 然后查路由表 然后给其他路由 其他路由再拿到这个包 对比子网掩码 嗯 就是我这个子网 然后查 ip 的 mac 这样就实现了不同子网之间的交流 这个时候 两个子网的包的数据层的目的的 mac 都是网关的 mac 网关收不到目的 mac 因为根本不知道 mac 只会收到 ip 但是 mac 又是必须的 就拿着 ip 去找 mac 嗯</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>我们现在实现了 在子网里面 用 mac 进行数据的传输 也就是链接层和实体层 然后我们在网络层 利用 ip 和子网掩码 和网关 路由 实现了不同子网之间的交流 那么现在 我们不可能两个机子 就只有一个链接吧 比如我们的服务器 同时要和好几个人链接 这个时候 一个机子有端口这个概念 也就是我们的传输层</p>
<p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p>
<p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>“端口”是 0 到 65535 之间的一个整数，正好 16 个二进制位。0 到 1023 的端口被系统占用，用户只能选用大于 1023 的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>
<p>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix 系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p>
<p>这里面也涉及到了面试题 就是我们的有一些自留端口 究竟是干啥的 嗯</p>
<p>有层 当然有协议 UDP 和 TCP 就是在这里面的 这个是重点面试题 单独开一篇<br>这个协议指定了当前的这个应用 使用的是哪一个端口 这个端口出来的和进去的都是这个应用的 这样就不会直接给歪来 具体参考头的套娃</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层就是形形色色的协议的 我们需要知道的就是http和https协议啦 这里直接放上套娃图 然后下一篇讲一下我们的这个套娃图是怎么套娃和解套娃 然后讲一下TCP和UDP</p>
<img src="/2020/12/01/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/head.png" class="" title="This is an example image">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhongsihui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dream Starts Here">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/" class="post-title-link" itemprop="url">数据结构与算法-栈之Leetcode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-29 19:15:16 / Modified: 21:43:59" itemprop="dateCreated datePublished" datetime="2020-11-29T19:15:16+08:00">2020-11-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="最近做了几题关于栈的-然后也是关于求矩形最大面积的"><a href="#最近做了几题关于栈的-然后也是关于求矩形最大面积的" class="headerlink" title="最近做了几题关于栈的  然后也是关于求矩形最大面积的"></a>最近做了几题关于栈的  然后也是关于求矩形最大面积的</h1><p>这里面涉及到一些类似于动态规划的意思  比如说单调栈 就是用前面的结果可以用于后面  这里面也有涉及 动态规划算是比较难想到的一类算法题吧 然后下面会总结一下算法的思路 下一次遇到算法题就知道大致的思路了</p>
<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>直接上图</p>
<img src="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/rain.png" class="" title="This is an example image">
<p>这里面我们的思路就是  首先我们肯定是要遍历这个柱子的高度的 毋庸置疑<br>这个时候 我们要确定的是 我们什么时候就可以确定已经遍历的柱子可以接雨水了？<br>接了多少雨水？  我们是一次性计算出全部还是分布计算？<br>首先肯定是一部分计算 因为一般这种题  如果不是求最大 或者是最小 一般来说遍历一次我们就可以直接得出答案 那么什么时候开始计算接了多少雨水呢？<br>一个碗  左边高 右边低  根据木桶效应  遍历到右边的时候 我们才知道可以接到多少水<br>在计算多少水的时候 我们需要知道已经遍历的里面的水量  我们只需要知道最近的 几根柱子 所以根据栈的先进先出就可以知道<br>直接上代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (pos.empty()&amp;&amp;height[i]==<span class="number">0</span>)</span><br><span class="line">      &#123; <span class="comment">//如果空 那就push进去 然后下一个儿</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (!pos.empty() &amp;&amp; height[i] &gt; height[pos.top()])</span><br><span class="line">      &#123;                      <span class="comment">//不空 而且比栈顶大 就说明 现在构成了一个碗  但是这个碗可能只有右边</span></span><br><span class="line">        <span class="keyword">int</span> top = pos.top(); <span class="comment">//保存当前讨论的那个柱子的位置 因为我们要访问前面的柱子 也就事我们要计算 当前这个一格宽的碗底 的水的高度</span></span><br><span class="line">        pos.pop();<span class="comment">//看左边碗底 如果是左边没有我碗底 那就无</span></span><br><span class="line">        <span class="keyword">if</span> (pos.empty())</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">//如果这个时候已经是空的 那么就五</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> realHeight = min(height[i], height[pos.top()]);<span class="comment">//看一下这个碗真正的高度  是左边碗墙和右边碗墙 i是当前比碗底高的右边碗墙  碗底被pop了 top就是左边碗墙</span></span><br><span class="line">        <span class="keyword">int</span> dis = i - pos.top() - <span class="number">1</span>;</span><br><span class="line">        ans += dis * (realHeight - height[top]);</span><br><span class="line">      &#125;</span><br><span class="line">      pos.push(i); <span class="comment">//进去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这一道题的突破口就是 我们计算水量的时候 计算的方法是 分块计算 每一次计算都是矩形  因为计算机最喜欢公式 如果是什么奇奇怪怪的俄罗斯方块 那当然不行  每一次都是矩形 宽度自然是坐标偏移量 高度就是我们的碗的左右高度的最小值减去碗底的高度  这样一来就可以实现啦<br>至于为什么使用栈 很多人都想不到 栈的特性就是先进先出  我们可以保存数据  然后很方便访问到最近的数据  我们的碗  当发现比碗底高 知道是右边碗墙  我们就需要访问左边碗墙 左边碗墙刚好是最近的数据 方便访问  访问完之后直接出栈  之前保留的数据又可以暴露  nice</p>
<h2 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a>最大矩形</h2><p>这里的最大矩形指的是  直接上图吧hhh</p>
<img src="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/zhuzhuangtu.png" class="" title="This is an example image">
<p>因为是求最大的矩形  我们粗略的想一想 有很多种可能  可能是高度很矮  但是很多个柱子组成  可能是高度很高  一柱擎天  但是不管怎么样 计算机最喜欢的就是公式 矩形的公式就是长和宽 首先有没有办法直接遍历一次就找到？ 好像没有 因为我们不知道后面矩形的情况<br>暴力法 直接枚举每一个高度  找到这个高度的最大的宽度  然后就知道当前高度的矩形的最大值 但是枚举的时候有没有更好的办法  我们找矩形的时候 要找到最左边的地方和最右边的地方<br>如果一个柱子比当前枚举的高度要大  那么就不是当前柱子的边界 那么是不是也不可能是后面柱子的边界呢？  当前柱子代表了我是之前最小的  那么就会直接把结果挡住 嗯 这里后面的计算边界就可以借鉴前面的结果 On 就能解决<br>维护一个单调栈  为什么是单调栈？？ 这是因为 我们要知道离当前枚举的高度 最近的状态 那么就是栈  然后看最近的状态 如果比老子大  那么就不是我的边界  出栈！ 下一个  一直从铜锣湾杀到尖沙咀 就知道边界了 如果杀光了 那么边界就是最左边0了</p>
<h3 id="举个例子-比如图上的"><a href="#举个例子-比如图上的" class="headerlink" title="举个例子 比如图上的"></a>举个例子 比如图上的</h3><p>2   1   5   6   2   3<br>2入栈  他的左边是-1<br>1入栈的时候 看到2  嗯？ 比老子大！ 爬 2出栈 当前栈空 左边界是0<br>1入栈<br>5入栈的时候 看到1 嗯 比我小  留着吧  结果是5和1  不可能会访问到2  因为1已经挡住了 2的价值就不在了 就可以节省时间和空间  当前栈内 1  5<br>6入栈和5相同 直接入栈  1 5 6<br>2入栈  干掉5  6  得到1  站内  1 2  很容易知道结果的正确性</p>
<p>On求出所有左边界 On求出右 再 On求出每一个的值 维护一个最大ans<br>上代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heights)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights.empty())        <span class="comment">//检测异常 面试必备</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; leftPos;     <span class="comment">//左边的单调栈</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; rightPos;</span><br><span class="line">        <span class="keyword">int</span> left[heights.size()];   <span class="comment">//储存左边界</span></span><br><span class="line">        <span class="keyword">int</span> right[heights.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!leftPos.empty() &amp;&amp; heights[leftPos.top()] &gt;= heights[i])<span class="comment">//如果比老子大就给爷爬 而且当然不能事空的</span></span><br><span class="line">            &#123;</span><br><span class="line">                leftPos.pop();  <span class="comment">//爬</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftPos.empty())    <span class="comment">//如果已经是空的 证明穿了  直接给最左边的赋值  这里的-1 魔法数字~</span></span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = leftPos.top();            <span class="comment">//碰到比我小的 当我小弟留着</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            leftPos.push(i);    <span class="comment">//统一入栈  因为要访问最近的情况 符合栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heights.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//大同小异</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!rightPos.empty() &amp;&amp; heights[rightPos.top()] &gt;= heights[i])</span><br><span class="line">            &#123;</span><br><span class="line">                rightPos.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightPos.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = heights.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = rightPos.top();</span><br><span class="line">            &#125;</span><br><span class="line">            rightPos.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;        <span class="comment">//在这里我们得到了左边界和右边界  这里的 -1 和 size两个魔法数字就体现了 嗯 这个-1也是魔法数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = max(ans, heights[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总体来说 这题的思维方式就是 如果用人的想法去写 一般写不出来  计算矩形 首先知道高贺宽 高可能是很多个 我们需要枚举  高在枚举的时候已经知道了 剩下的就是宽  宽的话  每一个高的宽  就是找到比我小的 那就是边界了 可以用栈的性质去解决 下一题</p>
<h2 id="最大矩形-1"><a href="#最大矩形-1" class="headerlink" title="最大矩形"></a>最大矩形</h2><p>直接上图 这个和上一个不太一样看起来很男</p>
<img src="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/zuidajuxing2.png" class="" title="This is an example image">
<p>这个呢 我们也可以归结为柱状图的最大矩形 但是这个底可能是在每一层  所以这里我们需要遍历每一层 得出当前这一层的heights数组 然后直接调用上一题的函数<br>这里也有个小技巧  我们每一层的高度数组 和上一层有关系 只和上一层有关系 有人会说 和最近的有关系 那不就是栈 但是 只和最近 注意这个只字  那之前的雨我无瓜 那就不用站 直接if来更新就行<br>上代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最大柱状图 其实是最大的为1的矩形  然后使用最大柱状图的解法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;matrix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matrix.empty())<span class="comment">//异常检测 面试搞</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">heights</span><span class="params">(n)</span></span>; <span class="comment">//进行矩形数组的高度的初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//输入第一层 如果是1  那么高度就是1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                heights[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                heights[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = largestRectangleArea(heights);<span class="comment">//来个答案先</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][k] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    heights[k]++;   <span class="comment">//如果是1  那么就在上一层的基础上+1  如果上一层是0  那也是1  不影响</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    heights[k] = <span class="number">0</span>;      <span class="comment">//如果是0  那就不可能是矩形的角  你上面再高都没用</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, largestRectangleArea(heights)); <span class="comment">//当前层的答案</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(v.size())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(v.size())</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; leftPos;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; rightPos;</span><br><span class="line">        <span class="keyword">if</span> (v.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!leftPos.empty() &amp;&amp; v[leftPos.top()] &gt;= v[i])</span><br><span class="line">            &#123;</span><br><span class="line">                leftPos.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftPos.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = leftPos.top();</span><br><span class="line">            &#125;</span><br><span class="line">            leftPos.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!rightPos.empty() &amp;&amp; v[rightPos.top()] &gt;= v[i])</span><br><span class="line">            &#123;</span><br><span class="line">                rightPos.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightPos.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = v.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = rightPos.top();</span><br><span class="line">            &#125;</span><br><span class="line">            rightPos.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = max(ans, v[i] * (right[i] - left[i] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总的来说 柱状图的矩形还是很有用的 嗯 over  干就完了</p>
<h2 id="二叉树的锯齿遍历"><a href="#二叉树的锯齿遍历" class="headerlink" title="二叉树的锯齿遍历"></a>二叉树的锯齿遍历</h2><img src="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88%E4%B9%8BLeetcode/juchi.png" class="" title="This is an example image">
<p>如题 二叉树的锯齿遍历 有多种解法 先来个我手撕的 当时看到标题是栈 就自觉地的使用的栈  发现一个栈不太行 因为要同时进行栈顶操作和入栈 而且要把栈直接pop空  所以 一边pop一边push  有点呆 所以直接来两个栈</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; s1;       <span class="comment">//来两个栈  </span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; s2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;    <span class="comment">//来个ans</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root)          <span class="comment">//异常检测 爬</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        s1.push(root);  <span class="comment">//首先root先入栈 紧接着就是从右往左 所以入s1</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)           <span class="comment">//这里while  1 是因为 一开始s2是空的 所以不能判断西面的if</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>)           <span class="comment">//往一个空栈里加 这个空栈pop  一直到空</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">                <span class="keyword">while</span> (!s1.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode *temp = s1.top();</span><br><span class="line">                    s1.pop();</span><br><span class="line">                    a.push_back(temp-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span> (temp-&gt;left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        s2.push(temp-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (temp-&gt;right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        s2.push(temp-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(a);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">                <span class="keyword">while</span> (!s2.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode *temp = s2.top();</span><br><span class="line">                    s2.pop();</span><br><span class="line">                    a.push_back(temp-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span> (temp-&gt;right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        s1.push(temp-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (temp-&gt;left)</span><br><span class="line">                    &#123;</span><br><span class="line">                        s1.push(temp-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(a);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s1.empty() &amp;&amp; s2.empty())&#123;      <span class="comment">//这里就是说的 不能在while进行循环 因为一开始有一个是空的 所以无法进循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一开始标签说的是栈 所以一直想的是栈  但是我们二叉树的遍历有两种 一种是基于栈的  DFS的遍历 然后通过栈的特点  可以访问最近的状态 进行回溯<br>一种就是万能BFS  可以求各种高度 宽度  这里讲一下BFS的方法<br>BFS传统来说就是左到右 但是其实判断一下cnt  然后选择是push到vetor的头还是尾就行了 代码就不放了 DFS 因为是递归实现 那就要传level  在相应的ans的层面上去进行push头还是尾 就说到这 溜了 看js</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhongsihui"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Zhongsihui</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhongsh57" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhongsh57" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:839518416@qq.com" title="E-Mail → mailto:839518416@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhongsihui</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
